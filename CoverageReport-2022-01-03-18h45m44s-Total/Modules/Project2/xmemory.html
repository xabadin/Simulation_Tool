<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>xmemory</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// xmemory internal header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _XMEMORY_
#define _XMEMORY_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;cstdint&gt;
#include &lt;cstdlib&gt;
#include &lt;limits&gt;
#include &lt;new&gt;
#include &lt;xatomic.h&gt;
#include &lt;xutility&gt;

#if _HAS_CXX20
#include &lt;tuple&gt;
#endif // _HAS_CXX20

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// STRUCT TEMPLATE _Tidy_guard
template &lt;class _Ty&gt;
struct _NODISCARD _Tidy_guard { // class with destructor that calls _Tidy
    _Ty* _Target;
<span style = "background-color:#dfd">    _CONSTEXPR20_DYNALLOC ~_Tidy_guard() {
        if (_Target) {</span>
<span style = "background-color:#fdd">            _Target-&gt;_Tidy();</span>
        }
<span style = "background-color:#dfd">    }</span>
};

// STRUCT TEMPLATE _Tidy_deallocate_guard
template &lt;class _Ty&gt;
struct _NODISCARD _Tidy_deallocate_guard { // class with destructor that calls _Tidy_deallocate
    _Ty* _Target;
    _CONSTEXPR20_DYNALLOC ~_Tidy_deallocate_guard() {
        if (_Target) {
            _Target-&gt;_Tidy_deallocate();
        }
    }
};

// VARIABLE TEMPLATE _Nothrow_compare
template &lt;class _Keycmp, class _Lhs, class _Rhs&gt;
_INLINE_VAR constexpr bool _Nothrow_compare = noexcept(
    static_cast&lt;bool&gt;(_STD declval&lt;const _Keycmp&amp;&gt;()(_STD declval&lt;const _Lhs&amp;&gt;(), _STD declval&lt;const _Rhs&amp;&gt;())));

// FUNCTION TEMPLATE _Get_size_of_n
template &lt;size_t _Ty_size&gt;
<span style = "background-color:#dfd">_NODISCARD constexpr size_t _Get_size_of_n(const size_t _Count) {
    constexpr bool _Overflow_is_possible = _Ty_size &gt; 1;</span>

    if constexpr (_Overflow_is_possible) {
<span style = "background-color:#dfd">        constexpr size_t _Max_possible = static_cast&lt;size_t&gt;(-1) / _Ty_size;
        if (_Count &gt; _Max_possible) {</span>
<span style = "background-color:#fdd">            _Throw_bad_array_new_length(); // multiply overflow</span>
        }
    }

<span style = "background-color:#dfd">    return _Count * _Ty_size;
}</span>

// VARIABLE TEMPLATE _New_alignof
template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t _New_alignof = (_STD max)(alignof(_Ty),
    static_cast&lt;size_t&gt;(__STDCPP_DEFAULT_NEW_ALIGNMENT__) // TRANSITION, VSO-522105
);

// STRUCT _Default_allocate_traits
struct _Default_allocate_traits {
    __declspec(allocator) static
#ifdef __clang__ // Clang and MSVC implement P0784R7 differently; see GH-1532
        _CONSTEXPR20_DYNALLOC
#endif // __clang__
<span style = "background-color:#dfd">        void* _Allocate(const size_t _Bytes) {
        return ::operator new(_Bytes);
    }</span>

#ifdef __cpp_aligned_new
    __declspec(allocator) static
#ifdef __clang__ // Clang and MSVC implement P0784R7 differently; see GH-1532
        _CONSTEXPR20_DYNALLOC
#endif // __clang__
        void* _Allocate_aligned(const size_t _Bytes, const size_t _Align) {
#ifdef __clang__ // Clang and MSVC implement P0784R7 differently; see GH-1532
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            return ::operator new(_Bytes);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
#endif // __clang__
        {
            return ::operator new (_Bytes, align_val_t{_Align});
        }
    }
#endif // __cpp_aligned_new
};

constexpr bool _Is_pow_2(const size_t _Value) noexcept {
    return _Value != 0 &amp;&amp; (_Value &amp; (_Value - 1)) == 0;
}

#if defined(_M_IX86) || defined(_M_X64)
constexpr size_t _Big_allocation_threshold = 4096;
constexpr size_t _Big_allocation_alignment = 32;

static_assert(2 * sizeof(void*) &lt;= _Big_allocation_alignment,
    "Big allocation alignment should at least match vector register alignment");
static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");

#ifdef _DEBUG
constexpr size_t _Non_user_size = 2 * sizeof(void*) + _Big_allocation_alignment - 1;
#else // _DEBUG
constexpr size_t _Non_user_size = sizeof(void*) + _Big_allocation_alignment - 1;
#endif // _DEBUG

#ifdef _WIN64
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;
#else // ^^^ _WIN64 ^^^ // vvv !_WIN64 vvv
constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAUL;
#endif // _WIN64

// FUNCTION _Allocate_manually_vector_aligned
template &lt;class _Traits&gt;
<span style = "background-color:#dfd">__declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes) {</span>
    // allocate _Bytes manually aligned to at least _Big_allocation_alignment
<span style = "background-color:#dfd">    const size_t _Block_size = _Non_user_size + _Bytes;
    if (_Block_size &lt;= _Bytes) {</span>
<span style = "background-color:#fdd">        _Throw_bad_array_new_length(); // add overflow</span>
    }

<span style = "background-color:#dfd">    const uintptr_t _Ptr_container = reinterpret_cast&lt;uintptr_t&gt;(_Traits::_Allocate(_Block_size));
    _STL_VERIFY(_Ptr_container != 0, "invalid argument"); // validate even in release since we're doing p[-1]
    void* const _Ptr = reinterpret_cast&lt;void*&gt;((_Ptr_container + _Non_user_size) &amp; ~(_Big_allocation_alignment - 1));
    static_cast&lt;uintptr_t*&gt;(_Ptr)[-1] = _Ptr_container;</span>

#ifdef _DEBUG
<span style = "background-color:#dfd">    static_cast&lt;uintptr_t*&gt;(_Ptr)[-2] = _Big_allocation_sentinel;</span>
#endif // _DEBUG
<span style = "background-color:#dfd">    return _Ptr;
}</span>

// FUNCTION TEMPLATE _Adjust_manually_vector_aligned
<span style = "background-color:#dfd">inline void _Adjust_manually_vector_aligned(void*&amp; _Ptr, size_t&amp; _Bytes) {</span>
    // adjust parameters from _Allocate_manually_vector_aligned to pass to operator delete
<span style = "background-color:#dfd">    _Bytes += _Non_user_size;</span>

<span style = "background-color:#dfd">    const uintptr_t* const _Ptr_user = reinterpret_cast&lt;uintptr_t*&gt;(_Ptr);
    const uintptr_t _Ptr_container   = _Ptr_user[-1];</span>

    // If the following asserts, it likely means that we are performing
    // an aligned delete on memory coming from an unaligned allocation.
<span style = "background-color:#dfd">    _STL_ASSERT(_Ptr_user[-2] == _Big_allocation_sentinel, "invalid argument");</span>

    // Extra paranoia on aligned allocation/deallocation; ensure _Ptr_container is
    // in range [_Min_back_shift, _Non_user_size]
#ifdef _DEBUG
<span style = "background-color:#dfd">    constexpr uintptr_t _Min_back_shift = 2 * sizeof(void*);</span>
#else // ^^^ _DEBUG ^^^ // vvv !_DEBUG vvv
    constexpr uintptr_t _Min_back_shift = sizeof(void*);
#endif // _DEBUG
<span style = "background-color:#dfd">    const uintptr_t _Back_shift = reinterpret_cast&lt;uintptr_t&gt;(_Ptr) - _Ptr_container;
    _STL_VERIFY(_Back_shift &gt;= _Min_back_shift &amp;&amp; _Back_shift &lt;= _Non_user_size, "invalid argument");
    _Ptr = reinterpret_cast&lt;void*&gt;(_Ptr_container);
}</span>
#endif // defined(_M_IX86) || defined(_M_X64)

// FUNCTION TEMPLATES _Allocate and _Deallocate
#ifdef __cpp_aligned_new
template &lt;size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t&lt;(_Align &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__), int&gt; = 0&gt;
__declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {
    // allocate _Bytes when __cpp_aligned_new &amp;&amp; _Align &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__
    if (_Bytes == 0) {
        return nullptr;
    }

#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
    if (_STD is_constant_evaluated()) {
        return _Traits::_Allocate(_Bytes);
    } else
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
        size_t _Passed_align = _Align;
#if defined(_M_IX86) || defined(_M_X64)
        if (_Bytes &gt;= _Big_allocation_threshold) {
            // boost the alignment of big allocations to help autovectorization
            _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
        }
#endif // defined(_M_IX86) || defined(_M_X64)
        return _Traits::_Allocate_aligned(_Bytes, _Passed_align);
    }
}

template &lt;size_t _Align, enable_if_t&lt;(_Align &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__), int&gt; = 0&gt;
_CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, const size_t _Bytes) noexcept {
    // deallocate storage allocated by _Allocate when __cpp_aligned_new &amp;&amp; _Align &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__
#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
    if (_STD is_constant_evaluated()) {
        ::operator delete(_Ptr);
    } else
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
        size_t _Passed_align = _Align;
#if defined(_M_IX86) || defined(_M_X64)
        if (_Bytes &gt;= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization
            _Passed_align = (_STD max)(_Align, _Big_allocation_alignment);
        }
#endif // defined(_M_IX86) || defined(_M_X64)
        ::operator delete (_Ptr, _Bytes, align_val_t{_Passed_align});
    }
}

#define _HAS_ALIGNED_NEW 1
#else // ^^^ __cpp_aligned_new ^^^ / vvv !__cpp_aligned_new vvv
#define _HAS_ALIGNED_NEW 0
#endif // __cpp_aligned_new

template &lt;size_t _Align, class _Traits = _Default_allocate_traits,
    enable_if_t&lt;(!_HAS_ALIGNED_NEW || _Align &lt;= __STDCPP_DEFAULT_NEW_ALIGNMENT__), int&gt; = 0&gt;
<span style = "background-color:#dfd">__declspec(allocator) _CONSTEXPR20_DYNALLOC void* _Allocate(const size_t _Bytes) {</span>
    // allocate _Bytes when !_HAS_ALIGNED_NEW || _Align &lt;= __STDCPP_DEFAULT_NEW_ALIGNMENT__
#if defined(_M_IX86) || defined(_M_X64)
#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
    if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
<span style = "background-color:#dfd">        if (_Bytes &gt;= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization
            return _Allocate_manually_vector_aligned&lt;_Traits&gt;(_Bytes);</span>
        }
    }
#endif // defined(_M_IX86) || defined(_M_X64)

<span style = "background-color:#dfd">    if (_Bytes != 0) {
        return _Traits::_Allocate(_Bytes);</span>
    }

<span style = "background-color:#fdd">    return nullptr;</span>
<span style = "background-color:#dfd">}</span>

template &lt;size_t _Align, enable_if_t&lt;(!_HAS_ALIGNED_NEW || _Align &lt;= __STDCPP_DEFAULT_NEW_ALIGNMENT__), int&gt; = 0&gt;
<span style = "background-color:#dfd">_CONSTEXPR20_DYNALLOC void _Deallocate(void* _Ptr, size_t _Bytes) noexcept {</span>
    // deallocate storage allocated by _Allocate when !_HAS_ALIGNED_NEW || _Align &lt;= __STDCPP_DEFAULT_NEW_ALIGNMENT__
#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
    if (_STD is_constant_evaluated()) {
        ::operator delete(_Ptr);
    } else
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
#if defined(_M_IX86) || defined(_M_X64)
<span style = "background-color:#dfd">        if (_Bytes &gt;= _Big_allocation_threshold) { // boost the alignment of big allocations to help autovectorization
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);</span>
        }
#endif // defined(_M_IX86) || defined(_M_X64)
<span style = "background-color:#dfd">        ::operator delete(_Ptr, _Bytes);</span>
    }
<span style = "background-color:#dfd">}</span>

#undef _HAS_ALIGNED_NEW

// FUNCTION TEMPLATE _Global_new
template &lt;class _Ty, class... _Types&gt;
_Ty* _Global_new(_Types&amp;&amp;... _Args) { // acts as "new" while disallowing user overload selection
    struct _NODISCARD _Guard_type {
        void* _Result;
        ~_Guard_type() {
            if (_Result) {
                _Deallocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Result, sizeof(_Ty));
            }
        }
    };

    _Guard_type _Guard{_Allocate&lt;_New_alignof&lt;_Ty&gt;&gt;(sizeof(_Ty))};
    ::new (_Guard._Result) _Ty(_STD forward&lt;_Types&gt;(_Args)...);
    return static_cast&lt;_Ty*&gt;(_STD exchange(_Guard._Result, nullptr));
}

// ALIAS TEMPLATE _Rebind_pointer_t
template &lt;class _Ptr, class _Ty&gt;
using _Rebind_pointer_t = typename pointer_traits&lt;_Ptr&gt;::template rebind&lt;_Ty&gt;;

// FUNCTION TEMPLATE _Refancy
template &lt;class _Pointer, enable_if_t&lt;!is_pointer_v&lt;_Pointer&gt;, int&gt; = 0&gt;
_CONSTEXPR20 _Pointer _Refancy(typename pointer_traits&lt;_Pointer&gt;::element_type* _Ptr) noexcept {
    return pointer_traits&lt;_Pointer&gt;::pointer_to(*_Ptr);
}

template &lt;class _Pointer, enable_if_t&lt;is_pointer_v&lt;_Pointer&gt;, int&gt; = 0&gt;
_CONSTEXPR20 _Pointer _Refancy(_Pointer _Ptr) noexcept {
    return _Ptr;
}

// FUNCTION TEMPLATE _Destroy_in_place
template &lt;class _NoThrowFwdIt, class _NoThrowSentinel&gt;
_CONSTEXPR20_DYNALLOC void _Destroy_range(_NoThrowFwdIt _First, _NoThrowSentinel _Last) noexcept;

template &lt;class _Ty&gt;
<span style = "background-color:#fdd">_CONSTEXPR20_DYNALLOC void _Destroy_in_place(_Ty&amp; _Obj) noexcept {</span>
    if constexpr (is_array_v&lt;_Ty&gt;) {
        _Destroy_range(_Obj, _Obj + extent_v&lt;_Ty&gt;);
    } else {
        _Obj.~_Ty();
    }
<span style = "background-color:#fdd">}</span>

#if _HAS_CXX17
// FUNCTION TEMPLATE destroy_at
template &lt;class _Ty&gt;
_CONSTEXPR20_DYNALLOC void destroy_at(_Ty* const _Location) noexcept /* strengthened */ {
#if _HAS_CXX20
    if constexpr (is_array_v&lt;_Ty&gt;) {
        _Destroy_range(_STD begin(*_Location), _STD end(*_Location));
    } else
#endif // _HAS_CXX20
    {
        _Location-&gt;~_Ty();
    }
}
#endif // _HAS_CXX17

// FUNCTION TEMPLATE _Const_cast
template &lt;class _Ptrty&gt;
auto _Const_cast(_Ptrty _Ptr) noexcept { // remove constness from a fancy pointer
    using _Elem       = typename pointer_traits&lt;_Ptrty&gt;::element_type;
    using _Modifiable = remove_const_t&lt;_Elem&gt;;
    using _Dest       = typename pointer_traits&lt;_Ptrty&gt;::template rebind&lt;_Modifiable&gt;;

    return pointer_traits&lt;_Dest&gt;::pointer_to(const_cast&lt;_Modifiable&amp;&gt;(*_Ptr));
}

template &lt;class _Ty&gt;
auto _Const_cast(_Ty* _Ptr) noexcept {
    return const_cast&lt;remove_const_t&lt;_Ty&gt;*&gt;(_Ptr);
}

// STRUCT TEMPLATE _Get_pointer_type
template &lt;class _Ty, class = void&gt;
struct _Get_pointer_type {
    using type = typename _Ty::value_type*;
};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Get_pointer_type&lt;_Ty, void_t&lt;typename _Ty::pointer&gt;&gt; {
    using type = typename _Ty::pointer;
};
_STL_RESTORE_DEPRECATED_WARNING

// STRUCT TEMPLATE _Get_const_pointer_type
template &lt;class _Ty, class = void&gt;
struct _Get_const_pointer_type {
    using _Ptrty = typename _Get_pointer_type&lt;_Ty&gt;::type;
    using _Valty = typename _Ty::value_type;
    using type   = typename pointer_traits&lt;_Ptrty&gt;::template rebind&lt;const _Valty&gt;;
};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Get_const_pointer_type&lt;_Ty, void_t&lt;typename _Ty::const_pointer&gt;&gt; {
    using type = typename _Ty::const_pointer;
};
_STL_RESTORE_DEPRECATED_WARNING

// STRUCT TEMPLATE _Get_void_pointer_type
template &lt;class _Ty, class = void&gt;
struct _Get_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type&lt;_Ty&gt;::type;
    using type   = typename pointer_traits&lt;_Ptrty&gt;::template rebind&lt;void&gt;;
};

template &lt;class _Ty&gt;
struct _Get_void_pointer_type&lt;_Ty, void_t&lt;typename _Ty::void_pointer&gt;&gt; {
    using type = typename _Ty::void_pointer;
};

// STRUCT TEMPLATE _Get_const_void_pointer_type
template &lt;class _Ty, class = void&gt;
struct _Get_const_void_pointer_type {
    using _Ptrty = typename _Get_pointer_type&lt;_Ty&gt;::type;
    using type   = typename pointer_traits&lt;_Ptrty&gt;::template rebind&lt;const void&gt;;
};

template &lt;class _Ty&gt;
struct _Get_const_void_pointer_type&lt;_Ty, void_t&lt;typename _Ty::const_void_pointer&gt;&gt; {
    using type = typename _Ty::const_void_pointer;
};

// STRUCT TEMPLATE _Get_difference_type
template &lt;class _Ty, class = void&gt;
struct _Get_difference_type {
    using _Ptrty = typename _Get_pointer_type&lt;_Ty&gt;::type;
    using type   = typename pointer_traits&lt;_Ptrty&gt;::difference_type;
};

template &lt;class _Ty&gt;
struct _Get_difference_type&lt;_Ty, void_t&lt;typename _Ty::difference_type&gt;&gt; {
    using type = typename _Ty::difference_type;
};

// STRUCT TEMPLATE _Get_size_type
template &lt;class _Ty, class = void&gt;
struct _Get_size_type {
    using type = make_unsigned_t&lt;typename _Get_difference_type&lt;_Ty&gt;::type&gt;;
};

template &lt;class _Ty&gt;
struct _Get_size_type&lt;_Ty, void_t&lt;typename _Ty::size_type&gt;&gt; {
    using type = typename _Ty::size_type;
};

// STRUCT TEMPLATE _Get_propagate_on_container_copy
template &lt;class _Ty, class = void&gt;
struct _Get_propagate_on_container_copy {
    using type = false_type;
};

template &lt;class _Ty&gt;
struct _Get_propagate_on_container_copy&lt;_Ty, void_t&lt;typename _Ty::propagate_on_container_copy_assignment&gt;&gt; {
    using type = typename _Ty::propagate_on_container_copy_assignment;
};

// STRUCT TEMPLATE _Get_propagate_on_container_move
template &lt;class _Ty, class = void&gt;
struct _Get_propagate_on_container_move {
    using type = false_type;
};

template &lt;class _Ty&gt;
struct _Get_propagate_on_container_move&lt;_Ty, void_t&lt;typename _Ty::propagate_on_container_move_assignment&gt;&gt; {
    using type = typename _Ty::propagate_on_container_move_assignment;
};

// STRUCT TEMPLATE _Get_propagate_on_container_swap
template &lt;class _Ty, class = void&gt;
struct _Get_propagate_on_container_swap {
    using type = false_type;
};

template &lt;class _Ty&gt;
struct _Get_propagate_on_container_swap&lt;_Ty, void_t&lt;typename _Ty::propagate_on_container_swap&gt;&gt; {
    using type = typename _Ty::propagate_on_container_swap;
};

// STRUCT TEMPLATE _Get_is_always_equal
template &lt;class _Ty, class = void&gt;
struct _Get_is_always_equal {
    using type = bool_constant&lt;is_empty_v&lt;_Ty&gt;&gt;;
};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Get_is_always_equal&lt;_Ty, void_t&lt;typename _Ty::is_always_equal&gt;&gt; {
    using type = typename _Ty::is_always_equal;
};
_STL_RESTORE_DEPRECATED_WARNING

// STRUCT TEMPLATE _Get_rebind_type
template &lt;class _Ty, class _Other, class = void&gt;
struct _Get_rebind_type {
    using type = typename _Replace_first_parameter&lt;_Other, _Ty&gt;::type;
};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty, class _Other&gt;
struct _Get_rebind_type&lt;_Ty, _Other, void_t&lt;typename _Ty::template rebind&lt;_Other&gt;::other&gt;&gt; {
    using type = typename _Ty::template rebind&lt;_Other&gt;::other;
};
_STL_RESTORE_DEPRECATED_WARNING

// STRUCT TEMPLATE _Is_default_allocator
template &lt;class _Ty&gt;
class allocator;

template &lt;class _Alloc, class = void&gt;
struct _Is_default_allocator : false_type {};

template &lt;class _Ty&gt;
struct _Is_default_allocator&lt;allocator&lt;_Ty&gt;, void_t&lt;typename allocator&lt;_Ty&gt;::_From_primary&gt;&gt;
    : is_same&lt;typename allocator&lt;_Ty&gt;::_From_primary, allocator&lt;_Ty&gt;&gt;::type {};

// ALIAS TEMPLATES _Uses_default_construct
template &lt;class _Void, class... _Types&gt;
struct _Has_no_allocator_construct : true_type {};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Alloc, class _Ptr, class... _Args&gt;
struct _Has_no_allocator_construct&lt;
    void_t&lt;decltype(_STD declval&lt;_Alloc&amp;&gt;().construct(_STD declval&lt;_Ptr&gt;(), _STD declval&lt;_Args&gt;()...))&gt;, _Alloc, _Ptr,
    _Args...&gt; : false_type {};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Alloc, class _Ptr, class... _Args&gt;
using _Uses_default_construct =
    disjunction&lt;_Is_default_allocator&lt;_Alloc&gt;, _Has_no_allocator_construct&lt;void, _Alloc, _Ptr, _Args...&gt;&gt;;

// ALIAS TEMPLATE _Uses_default_destroy AND _Uses_default_destroy_t
template &lt;class _Alloc, class _Ptr, class = void&gt;
struct _Has_no_alloc_destroy : true_type {};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Alloc, class _Ptr&gt;
struct _Has_no_alloc_destroy&lt;_Alloc, _Ptr, void_t&lt;decltype(_STD declval&lt;_Alloc&amp;&gt;().destroy(_STD declval&lt;_Ptr&gt;()))&gt;&gt;
    : false_type {};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Alloc, class _Ptr&gt;
using _Uses_default_destroy = disjunction&lt;_Is_default_allocator&lt;_Alloc&gt;, _Has_no_alloc_destroy&lt;_Alloc, _Ptr&gt;&gt;;

template &lt;class _Alloc, class _Ptr&gt;
using _Uses_default_destroy_t = typename _Uses_default_destroy&lt;_Alloc, _Ptr&gt;::type;

// STRUCT TEMPLATE _Has_allocate_hint
template &lt;class _Alloc, class _Size_type, class _Const_void_pointer, class = void&gt;
struct _Has_allocate_hint : false_type {};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Alloc, class _Size_type, class _Const_void_pointer&gt;
struct _Has_allocate_hint&lt;_Alloc, _Size_type, _Const_void_pointer,
    void_t&lt;decltype(_STD declval&lt;_Alloc&amp;&gt;().allocate(
        _STD declval&lt;const _Size_type&amp;&gt;(), _STD declval&lt;const _Const_void_pointer&amp;&gt;()))&gt;&gt; : true_type {};
_STL_RESTORE_DEPRECATED_WARNING

// STRUCT TEMPLATE _Has_max_size
template &lt;class _Alloc, class = void&gt;
struct _Has_max_size : false_type {};

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Alloc&gt;
struct _Has_max_size&lt;_Alloc, void_t&lt;decltype(_STD declval&lt;const _Alloc&amp;&gt;().max_size())&gt;&gt; : true_type {};
_STL_RESTORE_DEPRECATED_WARNING

// STRUCT TEMPLATE _Has_select_on_container_copy_construction
template &lt;class _Alloc, class = void&gt;
struct _Has_select_on_container_copy_construction : false_type {};

template &lt;class _Alloc&gt;
struct _Has_select_on_container_copy_construction&lt;_Alloc,
    void_t&lt;decltype(_STD declval&lt;const _Alloc&amp;&gt;().select_on_container_copy_construction())&gt;&gt; : true_type {};

// STRUCT TEMPLATE allocator_traits
template &lt;class _Alloc&gt;
struct allocator_traits;

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Alloc&gt;
struct _Normal_allocator_traits { // defines traits for allocators
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = typename _Get_pointer_type&lt;_Alloc&gt;::type;
    using const_pointer      = typename _Get_const_pointer_type&lt;_Alloc&gt;::type;
    using void_pointer       = typename _Get_void_pointer_type&lt;_Alloc&gt;::type;
    using const_void_pointer = typename _Get_const_void_pointer_type&lt;_Alloc&gt;::type;

    using size_type       = typename _Get_size_type&lt;_Alloc&gt;::type;
    using difference_type = typename _Get_difference_type&lt;_Alloc&gt;::type;

    using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy&lt;_Alloc&gt;::type;
    using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move&lt;_Alloc&gt;::type;
    using propagate_on_container_swap            = typename _Get_propagate_on_container_swap&lt;_Alloc&gt;::type;
    using is_always_equal                        = typename _Get_is_always_equal&lt;_Alloc&gt;::type;

    template &lt;class _Other&gt;
    using rebind_alloc = typename _Get_rebind_type&lt;_Alloc, _Other&gt;::type;

    template &lt;class _Other&gt;
    using rebind_traits = allocator_traits&lt;rebind_alloc&lt;_Other&gt;&gt;;

    _NODISCARD static _CONSTEXPR20_DYNALLOC __declspec(allocator) pointer
        allocate(_Alloc&amp; _Al, _CRT_GUARDOVERFLOW const size_type _Count) {
        return _Al.allocate(_Count);
    }

    _NODISCARD static _CONSTEXPR20_DYNALLOC __declspec(allocator) pointer
        allocate(_Alloc&amp; _Al, _CRT_GUARDOVERFLOW const size_type _Count, const const_void_pointer _Hint) {
        if constexpr (_Has_allocate_hint&lt;_Alloc, size_type, const_void_pointer&gt;::value) {
            return _Al.allocate(_Count, _Hint);
        } else {
            return _Al.allocate(_Count);
        }
    }

    static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc&amp; _Al, pointer _Ptr, size_type _Count) {
        _Al.deallocate(_Ptr, _Count);
    }

    template &lt;class _Ty, class... _Types&gt;
    static _CONSTEXPR20_DYNALLOC void construct(_Alloc&amp; _Al, _Ty* _Ptr, _Types&amp;&amp;... _Args) {
        if constexpr (_Uses_default_construct&lt;_Alloc, _Ty*, _Types...&gt;::value) {
            (void) _Al; // TRANSITION, DevCom-1004719
#ifdef __cpp_lib_constexpr_dynamic_alloc
            _STD construct_at(_Ptr, _STD forward&lt;_Types&gt;(_Args)...);
#else // __cpp_lib_constexpr_dynamic_alloc
            ::new (static_cast&lt;void*&gt;(_Ptr)) _Ty(_STD forward&lt;_Types&gt;(_Args)...);
#endif // __cpp_lib_constexpr_dynamic_alloc
        } else {
            _Al.construct(_Ptr, _STD forward&lt;_Types&gt;(_Args)...);
        }
    }

    template &lt;class _Ty&gt;
    static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&amp; _Al, _Ty* _Ptr) {
        if constexpr (_Uses_default_destroy&lt;_Alloc, _Ty*&gt;::value) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
            _STD destroy_at(_Ptr);
#else // __cpp_lib_constexpr_dynamic_alloc
            _Ptr-&gt;~_Ty();
#endif // __cpp_lib_constexpr_dynamic_alloc
        } else {
            _Al.destroy(_Ptr);
        }
    }

    _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&amp; _Al) noexcept {
        if constexpr (_Has_max_size&lt;_Alloc&gt;::value) {
            return _Al.max_size();
        } else {
            return (numeric_limits&lt;size_type&gt;::max)() / sizeof(value_type);
        }
    }

    _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc&amp; _Al) {
        if constexpr (_Has_select_on_container_copy_construction&lt;_Alloc&gt;::value) {
            return _Al.select_on_container_copy_construction();
        } else {
            return _Al;
        }
    }
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Alloc&gt;
struct _Default_allocator_traits { // traits for std::allocator
    using allocator_type = _Alloc;
    using value_type     = typename _Alloc::value_type;

    using pointer            = value_type*;
    using const_pointer      = const value_type*;
    using void_pointer       = void*;
    using const_void_pointer = const void*;

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_copy_assignment = false_type;
    using propagate_on_container_move_assignment = true_type;
    using propagate_on_container_swap            = false_type;
    using is_always_equal                        = true_type;

    template &lt;class _Other&gt;
    using rebind_alloc = allocator&lt;_Other&gt;;

    template &lt;class _Other&gt;
    using rebind_traits = allocator_traits&lt;allocator&lt;_Other&gt;&gt;;

    _NODISCARD static _CONSTEXPR20_DYNALLOC __declspec(allocator) pointer
        allocate(_Alloc&amp; _Al, _CRT_GUARDOVERFLOW const size_type _Count) {
#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
        if (_STD is_constant_evaluated()) {
            return _Al.allocate(_Count);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            (void) _Al;
            return static_cast&lt;pointer&gt;(
                _Allocate&lt;_New_alignof&lt;value_type&gt;&gt;(_Get_size_of_n&lt;sizeof(value_type)&gt;(_Count)));
        }
    }

    _NODISCARD static _CONSTEXPR20_DYNALLOC __declspec(allocator) pointer
        allocate(_Alloc&amp; _Al, _CRT_GUARDOVERFLOW const size_type _Count, const_void_pointer) {
#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
        if (_STD is_constant_evaluated()) {
            return _Al.allocate(_Count);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            (void) _Al;
            return static_cast&lt;pointer&gt;(
                _Allocate&lt;_New_alignof&lt;value_type&gt;&gt;(_Get_size_of_n&lt;sizeof(value_type)&gt;(_Count)));
        }
    }

<span style = "background-color:#dfd">    static _CONSTEXPR20_DYNALLOC void deallocate(_Alloc&amp; _Al, const pointer _Ptr, const size_type _Count) {</span>
        // no overflow check on the following multiply; we assume _Allocate did that check
#ifdef __cpp_lib_constexpr_dynamic_alloc // TRANSITION, GH-1532
        if (_STD is_constant_evaluated()) {
            _Al.deallocate(_Ptr, _Count);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            (void) _Al;
<span style = "background-color:#dfd">            _Deallocate&lt;_New_alignof&lt;value_type&gt;&gt;(_Ptr, sizeof(value_type) * _Count);</span>
        }
<span style = "background-color:#dfd">    }</span>

    template &lt;class _Objty, class... _Types&gt;
<span style = "background-color:#dfd">    static _CONSTEXPR20_DYNALLOC void construct(_Alloc&amp;, _Objty* const _Ptr, _Types&amp;&amp;... _Args) {</span>
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            _STD construct_at(_Ptr, _STD forward&lt;_Types&gt;(_Args)...);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward&lt;_Types&gt;(_Args)...);
        }
<span style = "background-color:#dfd">    }</span>

    template &lt;class _Uty&gt;
    static _CONSTEXPR20_DYNALLOC void destroy(_Alloc&amp;, _Uty* const _Ptr) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        _STD destroy_at(_Ptr);
#else // __cpp_lib_constexpr_dynamic_alloc
        _Ptr-&gt;~_Uty();
#endif // __cpp_lib_constexpr_dynamic_alloc
    }

<span style = "background-color:#dfd">    _NODISCARD static _CONSTEXPR20_DYNALLOC size_type max_size(const _Alloc&amp;) noexcept {
        return static_cast&lt;size_t&gt;(-1) / sizeof(value_type);
    }</span>

<span style = "background-color:#dfd">    _NODISCARD static _CONSTEXPR20_DYNALLOC _Alloc select_on_container_copy_construction(const _Alloc&amp; _Al) {
        return _Al;
    }</span>
};

template &lt;class _Alloc&gt;
struct allocator_traits : conditional_t&lt;_Is_default_allocator&lt;_Alloc&gt;::value, _Default_allocator_traits&lt;_Alloc&gt;,
                              _Normal_allocator_traits&lt;_Alloc&gt;&gt; {};

// _Choose_pocca returns whether an attempt to propagate allocators is necessary in copy assignment operations.
// Note that even when false_type, callers should call _Pocca as we want to assign allocators even when equal.
template &lt;class _Alloc&gt;
using _Choose_pocca = bool_constant&lt;allocator_traits&lt;_Alloc&gt;::propagate_on_container_copy_assignment::value
                                    &amp;&amp; !allocator_traits&lt;_Alloc&gt;::is_always_equal::value&gt;;

struct _Equal_allocators {}; // usually allows contents to be stolen (e.g. with swap)
using _Propagate_allocators    = true_type; // usually allows the allocator to be propagated, and then contents stolen
using _No_propagate_allocators = false_type; // usually turns moves into copies

template &lt;class _Alloc&gt;
using _Choose_pocma = conditional_t&lt;allocator_traits&lt;_Alloc&gt;::is_always_equal::value, _Equal_allocators,
    typename allocator_traits&lt;_Alloc&gt;::propagate_on_container_move_assignment::type&gt;;

// ALIAS TEMPLATE _Rebind_alloc_t
template &lt;class _Alloc, class _Value_type&gt;
using _Rebind_alloc_t = typename allocator_traits&lt;_Alloc&gt;::template rebind_alloc&lt;_Value_type&gt;;

// ALIAS TEMPLATE _Maybe_rebind_alloc_t
// If _Alloc is already rebound appropriately, binds an lvalue reference to it, avoiding a copy. Otherwise, creates a
// rebound copy.
template &lt;class _Alloc, class _Value_type&gt;
using _Maybe_rebind_alloc_t =
    typename _Select&lt;is_same_v&lt;typename _Alloc::value_type, _Value_type&gt;&gt;::template _Apply&lt;_Alloc&amp;,
        _Rebind_alloc_t&lt;_Alloc, _Value_type&gt;&gt;;

// VARIABLE TEMPLATE _Is_simple_alloc_v
template &lt;class _Alloc&gt; // tests if allocator has simple addressing
_INLINE_VAR constexpr bool _Is_simple_alloc_v = is_same_v&lt;typename allocator_traits&lt;_Alloc&gt;::size_type, size_t&gt;&amp;&amp;
    is_same_v&lt;typename allocator_traits&lt;_Alloc&gt;::difference_type, ptrdiff_t&gt;&amp;&amp;
        is_same_v&lt;typename allocator_traits&lt;_Alloc&gt;::pointer, typename _Alloc::value_type*&gt;&amp;&amp;
            is_same_v&lt;typename allocator_traits&lt;_Alloc&gt;::const_pointer, const typename _Alloc::value_type*&gt;;

// STRUCT TEMPLATE _Simple_types
template &lt;class _Value_type&gt;
struct _Simple_types { // wraps types from allocators with simple addressing for use in iterators
                       // and other SCARY machinery
    using value_type      = _Value_type;
    using size_type       = size_t;
    using difference_type = ptrdiff_t;
    using pointer         = value_type*;
    using const_pointer   = const value_type*;
};

// CLASS TEMPLATE allocator
template &lt;class _Ty&gt;
class allocator {
public:
    static_assert(!is_const_v&lt;_Ty&gt;, "The C++ Standard forbids containers of const elements "
                                    "because allocator&lt;const T&gt; is ill-formed.");

    using _From_primary = allocator;

    using value_type = _Ty;

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef _Ty* pointer;
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef const _Ty* const_pointer;

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef _Ty&amp; reference;
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef const _Ty&amp; const_reference;
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    using is_always_equal _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = true_type;

    template &lt;class _Other&gt;
    struct _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS rebind {
        using other = allocator&lt;_Other&gt;;
    };

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD _Ty* address(_Ty&amp; _Val) const noexcept {
        return _STD addressof(_Val);
    }

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD const _Ty* address(const _Ty&amp; _Val) const noexcept {
        return _STD addressof(_Val);
    }
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

<span style = "background-color:#dfd">    constexpr allocator() noexcept {}</span>

    constexpr allocator(const allocator&amp;) noexcept = default;
    template &lt;class _Other&gt;
<span style = "background-color:#dfd">    constexpr allocator(const allocator&lt;_Other&gt;&amp;) noexcept {}</span>
    _CONSTEXPR20_DYNALLOC ~allocator()       = default;
    _CONSTEXPR20_DYNALLOC allocator&amp; operator=(const allocator&amp;) = default;

<span style = "background-color:#dfd">    _CONSTEXPR20_DYNALLOC void deallocate(_Ty* const _Ptr, const size_t _Count) {</span>
        // no overflow check on the following multiply; we assume _Allocate did that check
<span style = "background-color:#dfd">        _Deallocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Ptr, sizeof(_Ty) * _Count);
    }</span>

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_DYNALLOC __declspec(allocator) _Ty* allocate(_CRT_GUARDOVERFLOW const size_t _Count) {
        return static_cast&lt;_Ty*&gt;(_Allocate&lt;_New_alignof&lt;_Ty&gt;&gt;(_Get_size_of_n&lt;sizeof(_Ty)&gt;(_Count)));
    }</span>

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD __declspec(allocator) _Ty* allocate(
        _CRT_GUARDOVERFLOW const size_t _Count, const void*) {
        return allocate(_Count);
    }

    template &lt;class _Objty, class... _Types&gt;
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void construct(_Objty* const _Ptr, _Types&amp;&amp;... _Args) {
        ::new (_Voidify_iter(_Ptr)) _Objty(_STD forward&lt;_Types&gt;(_Args)...);
    }

    template &lt;class _Uty&gt;
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS void destroy(_Uty* const _Ptr) {
        _Ptr-&gt;~_Uty();
    }

    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS _NODISCARD size_t max_size() const noexcept {
        return static_cast&lt;size_t&gt;(-1) / sizeof(_Ty);
    }
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS
};

// CLASS allocator&lt;void&gt;
template &lt;&gt;
class allocator&lt;void&gt; {
public:
    using value_type = void;
#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef void* pointer;
    _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS typedef const void* const_pointer;
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS

    using size_type       = size_t;
    using difference_type = ptrdiff_t;

    using propagate_on_container_move_assignment = true_type;

#if _HAS_DEPRECATED_ALLOCATOR_MEMBERS
    using is_always_equal _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS = true_type;

    template &lt;class _Other&gt;
    struct _CXX17_DEPRECATE_OLD_ALLOCATOR_MEMBERS rebind {
        using other = allocator&lt;_Other&gt;;
    };
#endif // _HAS_DEPRECATED_ALLOCATOR_MEMBERS
};

template &lt;class _Ty, class _Other&gt;
_NODISCARD _CONSTEXPR20_DYNALLOC bool operator==(const allocator&lt;_Ty&gt;&amp;, const allocator&lt;_Other&gt;&amp;) noexcept {
    return true;
}

#if !_HAS_CXX20
template &lt;class _Ty, class _Other&gt;
_NODISCARD bool operator!=(const allocator&lt;_Ty&gt;&amp;, const allocator&lt;_Other&gt;&amp;) noexcept {
    return false;
}
#endif // !_HAS_CXX20

#if _HAS_CXX17
// ALIAS TEMPLATE _Guide_size_type_t FOR DEDUCTION GUIDES, N4687 26.5.4.1 [unord.map.overview]/4
template &lt;class _Alloc&gt;
using _Guide_size_type_t =
    typename allocator_traits&lt;conditional_t&lt;_Is_allocator&lt;_Alloc&gt;::value, _Alloc, allocator&lt;int&gt;&gt;&gt;::size_type;
#endif // _HAS_CXX17

// ALIAS TEMPLATE _Alloc_ptr_t
template &lt;class _Alloc&gt;
using _Alloc_ptr_t = typename allocator_traits&lt;_Alloc&gt;::pointer;

// ALIAS_TEMPLATE _Alloc_size_t
template &lt;class _Alloc&gt;
using _Alloc_size_t = typename allocator_traits&lt;_Alloc&gt;::size_type;

// FUNCTION TEMPLATE _Pocca
template &lt;class _Alloc&gt;
_CONSTEXPR20 void _Pocca(_Alloc&amp; _Left, const _Alloc&amp; _Right) noexcept {
    if constexpr (allocator_traits&lt;_Alloc&gt;::propagate_on_container_copy_assignment::value) {
        _Left = _Right;
    }
}

// FUNCTION TEMPLATE _Pocma
template &lt;class _Alloc&gt;
_CONSTEXPR20 void _Pocma(_Alloc&amp; _Left, _Alloc&amp; _Right) noexcept { // (maybe) propagate on container move assignment
    if constexpr (allocator_traits&lt;_Alloc&gt;::propagate_on_container_move_assignment::value) {
        _Left = _STD move(_Right);
    }
}

// FUNCTION TEMPLATE _Pocs
template &lt;class _Alloc&gt;
_CONSTEXPR20 void _Pocs(_Alloc&amp; _Left, _Alloc&amp; _Right) noexcept {
    if constexpr (allocator_traits&lt;_Alloc&gt;::propagate_on_container_swap::value) {
        _Swap_adl(_Left, _Right);
    } else {
        _STL_ASSERT(_Left == _Right, "containers incompatible for swap");
    }
}

// FUNCTION TEMPLATE _Destroy_range WITH ALLOC
template &lt;class _Alloc&gt;
_CONSTEXPR20_DYNALLOC void _Destroy_range(
<span style = "background-color:#dfd">    _Alloc_ptr_t&lt;_Alloc&gt; _First, const _Alloc_ptr_t&lt;_Alloc&gt; _Last, _Alloc&amp; _Al) noexcept {</span>
    // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
    using _Ty = typename _Alloc::value_type;
    if constexpr (!conjunction_v&lt;is_trivially_destructible&lt;_Ty&gt;, _Uses_default_destroy&lt;_Alloc, _Ty*&gt;&gt;) {
        for (; _First != _Last; ++_First) {
            allocator_traits&lt;_Alloc&gt;::destroy(_Al, _Unfancy(_First));
        }
    }
<span style = "background-color:#dfd">}</span>

// FUNCTION TEMPLATE _Destroy_range
template &lt;class _NoThrowFwdIt, class _NoThrowSentinel&gt;
_CONSTEXPR20_DYNALLOC void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowSentinel _Last) noexcept {
    // note that this is an optimization for debug mode codegen; in release mode the BE removes all of this
    if constexpr (!is_trivially_destructible_v&lt;_Iter_value_t&lt;_NoThrowFwdIt&gt;&gt;) {
        for (; _First != _Last; ++_First) {
            _Destroy_in_place(*_First);
        }
    }
}

// FUNCTION TEMPLATE _Convert_size
template &lt;class _Size_type&gt;
_NODISCARD constexpr _Size_type _Convert_size(const size_t _Len) noexcept {
    // convert size_t to _Size_type, avoiding truncation
    if (_Len &gt; (numeric_limits&lt;_Size_type&gt;::max)()) {
        _Xlength_error("size_t too long for _Size_type");
    }

    return static_cast&lt;_Size_type&gt;(_Len);
}

template &lt;&gt;
<span style = "background-color:#dfd">_NODISCARD constexpr size_t _Convert_size&lt;size_t&gt;(const size_t _Len) noexcept {</span>
    // convert size_t to size_t, unchanged
<span style = "background-color:#dfd">    return _Len;
}</span>

// FUNCTION TEMPLATE _Deallocate_plain
template &lt;class _Alloc&gt;
<span style = "background-color:#dfd">_CONSTEXPR20_DYNALLOC void _Deallocate_plain(_Alloc&amp; _Al, typename _Alloc::value_type* const _Ptr) noexcept {</span>
    // deallocate a plain pointer using an allocator
    using _Alloc_traits = allocator_traits&lt;_Alloc&gt;;
    if constexpr (is_same_v&lt;_Alloc_ptr_t&lt;_Alloc&gt;, typename _Alloc::value_type*&gt;) {
<span style = "background-color:#dfd">        _Alloc_traits::deallocate(_Al, _Ptr, 1);</span>
    } else {
        using _Ptr_traits = pointer_traits&lt;_Alloc_ptr_t&lt;_Alloc&gt;&gt;;
        _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
    }
<span style = "background-color:#dfd">}</span>

// FUNCTION TEMPLATE _Delete_plain_internal
template &lt;class _Alloc&gt;
<span style = "background-color:#dfd">_CONSTEXPR20_DYNALLOC void _Delete_plain_internal(_Alloc&amp; _Al, typename _Alloc::value_type* const _Ptr) noexcept {</span>
    // destroy *_Ptr in place, then deallocate _Ptr using _Al; used for internal container types the user didn't name
    using _Ty = typename _Alloc::value_type;
    _Ptr-&gt;~_Ty();
<span style = "background-color:#dfd">    _Deallocate_plain(_Al, _Ptr);
}</span>

// STRUCT TEMPLATE _Alloc_construct_ptr
template &lt;class _Alloc&gt;
struct _Alloc_construct_ptr { // pointer used to help construct 1 _Alloc::value_type without EH
    using pointer = _Alloc_ptr_t&lt;_Alloc&gt;;
    _Alloc&amp; _Al;
    pointer _Ptr;

    _CONSTEXPR20_DYNALLOC explicit _Alloc_construct_ptr(_Alloc&amp; _Al_) : _Al(_Al_), _Ptr(nullptr) {}

    _NODISCARD _CONSTEXPR20_DYNALLOC pointer _Release() noexcept { // disengage *this and return contained pointer
        return _STD exchange(_Ptr, nullptr);
    }

    _CONSTEXPR20_DYNALLOC void _Allocate() { // disengage *this, then allocate a new memory block
        _Ptr = nullptr; // if allocate throws, prevents double-free
        _Ptr = _Al.allocate(1);
    }

    _CONSTEXPR20_DYNALLOC ~_Alloc_construct_ptr() { // if this instance is engaged, deallocate storage
        if (_Ptr) {
            _Al.deallocate(_Ptr, 1);
        }
    }

    _Alloc_construct_ptr(const _Alloc_construct_ptr&amp;) = delete;
    _Alloc_construct_ptr&amp; operator=(const _Alloc_construct_ptr&amp;) = delete;
};

// CLASSES _Container_base*, _Iterator_base*
struct _Fake_allocator {};

struct _Container_base0 {
    _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept {}
    _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base0&amp;) noexcept {}
    _CONSTEXPR20_CONTAINER void _Alloc_proxy(const _Fake_allocator&amp;) noexcept {}
    _CONSTEXPR20_CONTAINER void _Reload_proxy(const _Fake_allocator&amp;, const _Fake_allocator&amp;) noexcept {}
};

struct _Iterator_base0 {
    _CONSTEXPR20_CONTAINER void _Adopt(const void*) noexcept {}
    _CONSTEXPR20_CONTAINER const _Container_base0* _Getcont() const noexcept {
        return nullptr;
    }

    static constexpr bool _Unwrap_when_unverified = true;
};

// CLASS _Container_proxy
struct _Container_base12;
struct _Container_proxy { // store head of iterator chain and back pointer
    _CONSTEXPR20_CONTAINER _Container_proxy() noexcept = default;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_) {}</span>

    const _Container_base12* _Mycont       = nullptr;
<span style = "background-color:#dfd">    mutable _Iterator_base12* _Myfirstiter = nullptr;</span>
};

struct _Container_base12 {
public:
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Container_base12() noexcept = default;</span>

    _Container_base12(const _Container_base12&amp;) = delete;
    _Container_base12&amp; operator=(const _Container_base12&amp;) = delete;

    _CONSTEXPR20_CONTAINER void _Orphan_all() noexcept;
    _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators(_Container_base12&amp;) noexcept;

    template &lt;class _Alloc&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Alloc_proxy(_Alloc&amp;&amp; _Al) {
        _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _Myproxy            = _New_proxy;
        _New_proxy-&gt;_Mycont = this;
    }</span>

    template &lt;class _Alloc&gt;
    _CONSTEXPR20_CONTAINER void _Reload_proxy(_Alloc&amp;&amp; _Old_alloc, _Alloc&amp;&amp; _New_alloc) {
        // pre: no iterators refer to the existing proxy
        _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
        _Construct_in_place(*_New_proxy, this);
        _New_proxy-&gt;_Mycont = this;
        _Delete_plain_internal(_Old_alloc, _STD exchange(_Myproxy, _New_proxy));
    }

<span style = "background-color:#dfd">    _Container_proxy* _Myproxy = nullptr;</span>

private:
    _CONSTEXPR20_CONTAINER void _Orphan_all_unlocked_v3() noexcept;
    _CONSTEXPR20_CONTAINER void _Swap_proxy_and_iterators_unlocked(_Container_base12&amp;) noexcept;

<span style = "background-color:#dfd">    void _Orphan_all_locked_v3() noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_all_unlocked_v3();
    }</span>

<span style = "background-color:#dfd">    void _Swap_proxy_and_iterators_locked(_Container_base12&amp; _Right) noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Swap_proxy_and_iterators_unlocked(_Right);
    }</span>
};

struct _Iterator_base12 { // store links to container proxy, next iterator
public:
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Iterator_base12() noexcept = default; // construct orphaned iterator</span>

    _CONSTEXPR20_CONTAINER _Iterator_base12(const _Iterator_base12&amp; _Right) noexcept {
        *this = _Right;
    }

    _CONSTEXPR20_CONTAINER _Iterator_base12&amp; operator=(const _Iterator_base12&amp; _Right) noexcept {
#if _ITERATOR_DEBUG_LEVEL == 2
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            _Assign_unlocked(_Right);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            _Assign_locked(_Right);
        }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
        _Myproxy = _Right._Myproxy;
#endif // _ITERATOR_DEBUG_LEVEL != 2
        return *this;
    }

#if _ITERATOR_DEBUG_LEVEL == 2
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER ~_Iterator_base12() noexcept {</span>
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            _Orphan_me_unlocked_v3();
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
<span style = "background-color:#dfd">            _Orphan_me_locked_v3();</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {</span>
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            _Adopt_unlocked(_Parent);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
<span style = "background-color:#dfd">            _Adopt_locked(_Parent);</span>
        }
<span style = "background-color:#dfd">    }</span>
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
    _CONSTEXPR20_CONTAINER void _Adopt(const _Container_base12* _Parent) noexcept {
        if (_Parent) { // have a parent, do adoption
            _Myproxy = _Parent-&gt;_Myproxy;
        } else { // no future parent, just disown current parent
            _Myproxy = nullptr;
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL != 2

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER const _Container_base12* _Getcont() const noexcept {
        return _Myproxy ? _Myproxy-&gt;_Mycont : nullptr;
    }</span>

    static constexpr bool _Unwrap_when_unverified = _ITERATOR_DEBUG_LEVEL == 0;

<span style = "background-color:#dfd">    mutable _Container_proxy* _Myproxy    = nullptr;
    mutable _Iterator_base12* _Mynextiter = nullptr;</span>

#if _ITERATOR_DEBUG_LEVEL == 2
private:
    _CONSTEXPR20_CONTAINER void _Assign_unlocked(const _Iterator_base12&amp; _Right) noexcept {
        if (_Myproxy == _Right._Myproxy) {
            return;
        }

        if (_Right._Myproxy) {
            _Adopt_unlocked(_Right._Myproxy-&gt;_Mycont);
        } else { // becoming invalid, disown current parent
            _Orphan_me_unlocked_v3();
        }
    }

    void _Assign_locked(const _Iterator_base12&amp; _Right) noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Assign_unlocked(_Right);
    }

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Adopt_unlocked(const _Container_base12* _Parent) noexcept {
        if (!_Parent) {</span>
<span style = "background-color:#fdd">            _Orphan_me_unlocked_v3();
            return;</span>
        }

<span style = "background-color:#dfd">        _Container_proxy* _Parent_proxy = _Parent-&gt;_Myproxy;
        if (_Myproxy != _Parent_proxy) { // change parentage
            if (_Myproxy) { // adopted, remove self from list</span>
<span style = "background-color:#fdd">                _Orphan_me_unlocked_v3();</span>
            }
<span style = "background-color:#dfd">            _Mynextiter                 = _Parent_proxy-&gt;_Myfirstiter;
            _Parent_proxy-&gt;_Myfirstiter = this;
            _Myproxy                    = _Parent_proxy;</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void _Adopt_locked(const _Container_base12* _Parent) noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Adopt_unlocked(_Parent);
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Orphan_me_unlocked_v3() noexcept {
        if (!_Myproxy) { // already orphaned</span>
<span style = "background-color:#fdd">            return;</span>
        }

        // adopted, remove self from list
<span style = "background-color:#dfd">        _Iterator_base12** _Pnext = &amp;_Myproxy-&gt;_Myfirstiter;
        while (*_Pnext &amp;&amp; *_Pnext != this) {</span>
<span style = "background-color:#fdd">            const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037
            _Pnext           = &amp;_Temp-&gt;_Mynextiter;
        }</span>

<span style = "background-color:#dfd">        _STL_VERIFY(*_Pnext, "ITERATOR LIST CORRUPTED!");
        *_Pnext  = _Mynextiter;
        _Myproxy = nullptr;
    }</span>

<span style = "background-color:#dfd">    void _Orphan_me_locked_v3() noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_me_unlocked_v3();
    }</span>
#endif // _ITERATOR_DEBUG_LEVEL == 2
};

// MEMBER FUNCTIONS FOR _Container_base12
<span style = "background-color:#dfd">_CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all_unlocked_v3() noexcept {
    if (!_Myproxy) { // no proxy, already done</span>
<span style = "background-color:#fdd">        return;</span>
    }

    // proxy allocated, drain it
<span style = "background-color:#dfd">    for (auto&amp; _Pnext = _Myproxy-&gt;_Myfirstiter; _Pnext; _Pnext = _Pnext-&gt;_Mynextiter) { // TRANSITION, VSO-1269037</span>
<span style = "background-color:#fdd">        _Pnext-&gt;_Myproxy = nullptr;
    }</span>
<span style = "background-color:#dfd">    _Myproxy-&gt;_Myfirstiter = nullptr;
}</span>

<span style = "background-color:#dfd">_CONSTEXPR20_CONTAINER void _Container_base12::_Orphan_all() noexcept {</span>
#if _ITERATOR_DEBUG_LEVEL == 2
#ifdef __cpp_lib_constexpr_dynamic_alloc
    if (_STD is_constant_evaluated()) {
        _Orphan_all_unlocked_v3();
    } else
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
<span style = "background-color:#dfd">        _Orphan_all_locked_v3();</span>
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">_CONSTEXPR20_CONTAINER void _Container_base12::_Swap_proxy_and_iterators_unlocked(_Container_base12&amp; _Right) noexcept {
    _Container_proxy* _Temp = _Myproxy;
    _Myproxy                = _Right._Myproxy;
    _Right._Myproxy         = _Temp;</span>

<span style = "background-color:#dfd">    if (_Myproxy) {
        _Myproxy-&gt;_Mycont = this;</span>
    }

<span style = "background-color:#dfd">    if (_Right._Myproxy) {
        _Right._Myproxy-&gt;_Mycont = &amp;_Right;</span>
    }
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">_CONSTEXPR20_CONTAINER void _Container_base12::_Swap_proxy_and_iterators(_Container_base12&amp; _Right) noexcept {</span>
#if _ITERATOR_DEBUG_LEVEL == 2
#ifdef __cpp_lib_constexpr_dynamic_alloc
    if (_STD is_constant_evaluated()) {
        _Swap_proxy_and_iterators_unlocked(_Right);
    } else
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
<span style = "background-color:#dfd">        _Swap_proxy_and_iterators_locked(_Right);</span>
    }
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ / vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
    _Swap_proxy_and_iterators_unlocked(_Right);
#endif // _ITERATOR_DEBUG_LEVEL != 2
<span style = "background-color:#dfd">}</span>

#if _ITERATOR_DEBUG_LEVEL == 0
using _Container_base = _Container_base0;
using _Iterator_base  = _Iterator_base0;
#else // _ITERATOR_DEBUG_LEVEL == 0
using _Container_base = _Container_base12;
using _Iterator_base = _Iterator_base12;
#endif // _ITERATOR_DEBUG_LEVEL == 0

// ALIAS TEMPLATE _Container_proxy_ptr AND SUPPORTING MACHINERY
struct _Leave_proxy_unbound {
    explicit _Leave_proxy_unbound() = default;
}; // tag to indicate that a proxy is being allocated before it is safe to bind to a _Container_base12

struct _Fake_proxy_ptr_impl { // fake replacement for a container proxy smart pointer when no container proxy is in use
    _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&amp;) = delete;
    _Fake_proxy_ptr_impl&amp; operator=(const _Fake_proxy_ptr_impl&amp;) = delete;
    _CONSTEXPR20_CONTAINER _Fake_proxy_ptr_impl(const _Fake_allocator&amp;, _Leave_proxy_unbound) noexcept {}
    _CONSTEXPR20_CONTAINER _Fake_proxy_ptr_impl(const _Fake_allocator&amp;, const _Container_base0&amp;) noexcept {}

    _CONSTEXPR20_CONTAINER void _Bind(const _Fake_allocator&amp;, _Container_base0*) noexcept {}
    _CONSTEXPR20_CONTAINER void _Release() noexcept {}
};

struct _Basic_container_proxy_ptr12 {
    // smart pointer components for a _Container_proxy * that don't depend on the allocator
<span style = "background-color:#dfd">    _Container_proxy* _Ptr = nullptr;</span>

<span style = "background-color:#dfd">    constexpr void _Release() noexcept { // disengage this _Basic_container_proxy_ptr12
        _Ptr = nullptr;
    }</span>

protected:
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Basic_container_proxy_ptr12()             = default;</span>
    _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&amp;) = delete;
    _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&amp;&amp;)      = delete;
};

template &lt;class _Alloc&gt;
struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12 {
    // smart pointer components for a _Container_proxy * for an allocator family
    _Alloc&amp; _Al;

    _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc&amp; _Al_, _Leave_proxy_unbound) : _Al(_Al_) {
        // create a new unbound _Container_proxy
        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr);
    }

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Container_proxy_ptr12(_Alloc&amp; _Al_, _Container_base12&amp; _Mycont) : _Al(_Al_) {</span>
        // create a new _Container_proxy pointing at _Mycont
<span style = "background-color:#dfd">        _Ptr = _Unfancy(_Al_.allocate(1));
        _Construct_in_place(*_Ptr, _STD addressof(_Mycont));
        _Mycont._Myproxy = _Ptr;
    }</span>

    _CONSTEXPR20_CONTAINER void _Bind(_Alloc&amp; _Old_alloc, _Container_base12* _Mycont) noexcept {
        // Attach the proxy stored in *this to _Mycont, and destroy _Mycont's existing proxy
        // with _Old_alloc. Requires that no iterators are alive referring to _Mycont.
        _Ptr-&gt;_Mycont = _Mycont;
        _Delete_plain_internal(_Old_alloc, _STD exchange(_Mycont-&gt;_Myproxy, _STD exchange(_Ptr, nullptr)));
    }

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER ~_Container_proxy_ptr12() {
        if (_Ptr) {</span>
<span style = "background-color:#fdd">            _Delete_plain_internal(_Al, _Ptr);</span>
        }
<span style = "background-color:#dfd">    }</span>
};

#if _ITERATOR_DEBUG_LEVEL == 0
_INLINE_VAR constexpr _Fake_allocator _Fake_alloc{};
#define _GET_PROXY_ALLOCATOR(_Alty, _Al) _Fake_alloc // TRANSITION, VSO-1284799, should be _Fake_allocator{}
template &lt;class _Alloc&gt;
using _Container_proxy_ptr = _Fake_proxy_ptr_impl;
#else // _ITERATOR_DEBUG_LEVEL == 0
#define _GET_PROXY_ALLOCATOR(_Alty, _Al) static_cast&lt;_Rebind_alloc_t&lt;_Alty, _Container_proxy&gt;&gt;(_Al)
template &lt;class _Alloc&gt;
using _Container_proxy_ptr = _Container_proxy_ptr12&lt;_Rebind_alloc_t&lt;_Alloc, _Container_proxy&gt;&gt;;
#endif // _ITERATOR_DEBUG_LEVEL == 0

// CLASS TEMPLATE _Compressed_pair
struct _Zero_then_variadic_args_t {
    explicit _Zero_then_variadic_args_t() = default;
}; // tag type for value-initializing first, constructing second from remaining args

struct _One_then_variadic_args_t {
    explicit _One_then_variadic_args_t() = default;
}; // tag type for constructing first from one arg, constructing second from remaining args

template &lt;class _Ty1, class _Ty2, bool = is_empty_v&lt;_Ty1&gt; &amp;&amp; !is_final_v&lt;_Ty1&gt;&gt;
class _Compressed_pair final : private _Ty1 { // store a pair of values, deriving from empty first
public:
    _Ty2 _Myval2;

    using _Mybase = _Ty1; // for visualization

    template &lt;class... _Other2&gt;
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&amp;&amp;... _Val2) noexcept(
        conjunction_v&lt;is_nothrow_default_constructible&lt;_Ty1&gt;, is_nothrow_constructible&lt;_Ty2, _Other2...&gt;&gt;)
<span style = "background-color:#dfd">        : _Ty1(), _Myval2(_STD forward&lt;_Other2&gt;(_Val2)...) {}</span>

    template &lt;class _Other1, class... _Other2&gt;
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&amp;&amp; _Val1, _Other2&amp;&amp;... _Val2) noexcept(
        conjunction_v&lt;is_nothrow_constructible&lt;_Ty1, _Other1&gt;, is_nothrow_constructible&lt;_Ty2, _Other2...&gt;&gt;)
<span style = "background-color:#dfd">        : _Ty1(_STD forward&lt;_Other1&gt;(_Val1)), _Myval2(_STD forward&lt;_Other2&gt;(_Val2)...) {}</span>

<span style = "background-color:#dfd">    constexpr _Ty1&amp; _Get_first() noexcept {
        return *this;
    }</span>

<span style = "background-color:#dfd">    constexpr const _Ty1&amp; _Get_first() const noexcept {
        return *this;
    }</span>
};

template &lt;class _Ty1, class _Ty2&gt;
class _Compressed_pair&lt;_Ty1, _Ty2, false&gt; final { // store a pair of values, not deriving from first
public:
    _Ty1 _Myval1;
    _Ty2 _Myval2;

    template &lt;class... _Other2&gt;
    constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&amp;&amp;... _Val2) noexcept(
        conjunction_v&lt;is_nothrow_default_constructible&lt;_Ty1&gt;, is_nothrow_constructible&lt;_Ty2, _Other2...&gt;&gt;)
        : _Myval1(), _Myval2(_STD forward&lt;_Other2&gt;(_Val2)...) {}

    template &lt;class _Other1, class... _Other2&gt;
    constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&amp;&amp; _Val1, _Other2&amp;&amp;... _Val2) noexcept(
        conjunction_v&lt;is_nothrow_constructible&lt;_Ty1, _Other1&gt;, is_nothrow_constructible&lt;_Ty2, _Other2...&gt;&gt;)
        : _Myval1(_STD forward&lt;_Other1&gt;(_Val1)), _Myval2(_STD forward&lt;_Other2&gt;(_Val2)...) {}

    constexpr _Ty1&amp; _Get_first() noexcept {
        return _Myval1;
    }

    constexpr const _Ty1&amp; _Get_first() const noexcept {
        return _Myval1;
    }
};

struct _Move_allocator_tag {
    explicit _Move_allocator_tag() = default;
};

// FUNCTION TEMPLATE _Get_temporary_buffer
template &lt;class _Ty&gt;
pair&lt;_Ty*, ptrdiff_t&gt; _Get_temporary_buffer(ptrdiff_t _Count) noexcept {
    if (static_cast&lt;size_t&gt;(_Count) &lt;= static_cast&lt;size_t&gt;(-1) / sizeof(_Ty)) {
        for (; 0 &lt; _Count; _Count /= 2) {
            const auto _Size = static_cast&lt;size_t&gt;(_Count) * sizeof(_Ty);
            void* _Pbuf;
#ifdef __cpp_aligned_new
            if constexpr (alignof(_Ty) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
                _Pbuf = ::operator new (_Size, align_val_t{alignof(_Ty)}, nothrow);
            } else
#endif // __cpp_aligned_new
            {
                _Pbuf = ::operator new(_Size, nothrow);
            }

            if (_Pbuf) {
                return {static_cast&lt;_Ty*&gt;(_Pbuf), _Count};
            }
        }
    }

    return {nullptr, 0};
}

// FUNCTION TEMPLATE _Return_temporary_buffer
template &lt;class _Ty&gt;
void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept {
#ifdef __cpp_aligned_new
    if constexpr (alignof(_Ty) &gt; __STDCPP_DEFAULT_NEW_ALIGNMENT__) {
        ::operator delete (_Pbuf, align_val_t{alignof(_Ty)});
    } else
#endif // __cpp_aligned_new
    {
        ::operator delete(_Pbuf);
    }
}

// STRUCT TEMPLATE _Uninitialized_backout
template &lt;class _NoThrowFwdIt&gt;
struct _NODISCARD _Uninitialized_backout {
    // struct to undo partially constructed ranges in _Uninitialized_xxx algorithms
    _NoThrowFwdIt _First;
    _NoThrowFwdIt _Last;

    constexpr explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest) {}

    constexpr _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_) {}

    _Uninitialized_backout(const _Uninitialized_backout&amp;) = delete;
    _Uninitialized_backout&amp; operator=(const _Uninitialized_backout&amp;) = delete;

    _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout() {
        _Destroy_range(_First, _Last);
    }

    template &lt;class... _Types&gt;
    _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&amp;&amp;... _Vals) {
        // construct a new element at *_Last and increment
        _Construct_in_place(*_Last, _STD forward&lt;_Types&gt;(_Vals)...);
        ++_Last;
    }

    constexpr _NoThrowFwdIt _Release() { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }
};

// FUNCTION TEMPLATE _Uninitialized_move_unchecked
template &lt;class _InIt, class _NoThrowFwdIt&gt;
_CONSTEXPR20_DYNALLOC _NoThrowFwdIt _Uninitialized_move_unchecked(
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // move [_First, _Last) to raw [_Dest, ...)
    if constexpr (_Ptr_move_cat&lt;_InIt, _NoThrowFwdIt&gt;::_Really_trivial) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }
    _Uninitialized_backout&lt;_NoThrowFwdIt&gt; _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(_STD move(*_First));
    }

    return _Backout._Release();
}

#ifdef __cpp_lib_concepts
namespace ranges {
    // clang-format off
    // CONCEPT _No_throw_input_iterator
    template &lt;class _It&gt;
    concept _No_throw_input_iterator = input_iterator&lt;_It&gt;
        &amp;&amp; is_lvalue_reference_v&lt;iter_reference_t&lt;_It&gt;&gt;
        &amp;&amp; same_as&lt;remove_cvref_t&lt;iter_reference_t&lt;_It&gt;&gt;, iter_value_t&lt;_It&gt;&gt;;

    // CONCEPT _No_throw_sentinel_for
    template &lt;class _Se, class _It&gt;
    concept _No_throw_sentinel_for = sentinel_for&lt;_Se, _It&gt;;

    // CONCEPT _No_throw_forward_iterator
    template &lt;class _It&gt;
    concept _No_throw_forward_iterator = _No_throw_input_iterator&lt;_It&gt;
        &amp;&amp; forward_iterator&lt;_It&gt;
        &amp;&amp; _No_throw_sentinel_for&lt;_It, _It&gt;;

    // CONCEPT _No_throw_input_range
    template &lt;class _Rng&gt;
    concept _No_throw_input_range = range&lt;_Rng&gt;
        &amp;&amp; _No_throw_input_iterator&lt;iterator_t&lt;_Rng&gt;&gt;
        &amp;&amp; _No_throw_sentinel_for&lt;sentinel_t&lt;_Rng&gt;, iterator_t&lt;_Rng&gt;&gt;;

    // CONCEPT _No_throw_forward_range
    template &lt;class _Rng&gt;
    concept _No_throw_forward_range = _No_throw_input_range&lt;_Rng&gt;
        &amp;&amp; _No_throw_forward_iterator&lt;iterator_t&lt;_Rng&gt;&gt;;
    // clang-format on

    template &lt;class _InIt, class _OutIt&gt;
    in_out_result&lt;_InIt, _OutIt&gt; _Copy_memcpy_common(
        _InIt _IFirst, _InIt _ILast, _OutIt _OFirst, _OutIt _OLast) noexcept {
        const auto _IFirstPtr = _To_address(_IFirst);
        const auto _ILastPtr  = _To_address(_ILast);
        const auto _OFirstPtr = _To_address(_OFirst);
        const auto _OLastPtr  = _To_address(_OLast);
        const auto _IFirst_ch = const_cast&lt;char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_IFirstPtr));
        const auto _ILast_ch  = const_cast&lt;const char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_ILastPtr));
        const auto _OFirst_ch = const_cast&lt;char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_OFirstPtr));
        const auto _OLast_ch  = const_cast&lt;const char*&gt;(reinterpret_cast&lt;const volatile char*&gt;(_OLastPtr));
        const auto _Count     = static_cast&lt;size_t&gt;((_STD min)(_ILast_ch - _IFirst_ch, _OLast_ch - _OFirst_ch));
        _CSTD memcpy(_OFirst_ch, _IFirst_ch, _Count);
        if constexpr (is_pointer_v&lt;_InIt&gt;) {
            _IFirst = reinterpret_cast&lt;_InIt&gt;(_IFirst_ch + _Count);
        } else {
            _IFirst += _Count / sizeof(iter_value_t&lt;_InIt&gt;);
        }

        if constexpr (is_pointer_v&lt;_OutIt&gt;) {
            _OFirst = reinterpret_cast&lt;_OutIt&gt;(_OFirst_ch + _Count);
        } else {
            _OFirst += _Count / sizeof(iter_value_t&lt;_OutIt&gt;);
        }
        return {_STD move(_IFirst), _STD move(_OFirst)};
    }

    // ALIAS TEMPLATE uninitialized_move_result
    template &lt;class _In, class _Out&gt;
    using uninitialized_move_result = in_out_result&lt;_In, _Out&gt;;

    // FUNCTION TEMPLATE _Uninitialized_move_unchecked
    // clang-format off
    template &lt;input_iterator _It, sentinel_for&lt;_It&gt; _Se, _No_throw_forward_iterator _Out,
        _No_throw_sentinel_for&lt;_Out&gt; _OSe&gt;
        requires constructible_from&lt;iter_value_t&lt;_Out&gt;, iter_rvalue_reference_t&lt;_It&gt;&gt;
    uninitialized_move_result&lt;_It, _Out&gt; _Uninitialized_move_unchecked(
            _It _IFirst, _Se _ILast, _Out _OFirst, _OSe _OLast) {
        // clang-format on
        if constexpr (_Ptr_move_cat&lt;_It, _Out&gt;::_Really_trivial
                      &amp;&amp; sized_sentinel_for&lt;_Se, _It&gt; &amp;&amp; sized_sentinel_for&lt;_OSe, _Out&gt;) {
            return _Copy_memcpy_common(
                _IFirst, _RANGES next(_IFirst, _STD move(_ILast)), _OFirst, _RANGES next(_OFirst, _STD move(_OLast)));
        } else {
            _Uninitialized_backout _Backout{_STD move(_OFirst)};

            for (; _IFirst != _ILast &amp;&amp; _Backout._Last != _OLast; ++_IFirst) {
                _Backout._Emplace_back(_RANGES iter_move(_IFirst));
            }

            return {_STD move(_IFirst), _Backout._Release()};
        }
    }
} // namespace ranges
#endif // __cpp_lib_concepts

// STRUCT TEMPLATE _Uninitialized_backout_al
template &lt;class _Alloc&gt;
class _NODISCARD _Uninitialized_backout_al {
    // struct to undo partially constructed ranges in _Uninitialized_xxx_al algorithms
    using pointer = _Alloc_ptr_t&lt;_Alloc&gt;;

public:
    _CONSTEXPR20_DYNALLOC _Uninitialized_backout_al(pointer _Dest, _Alloc&amp; _Al_)
<span style = "background-color:#dfd">        : _First(_Dest), _Last(_Dest), _Al(_Al_) {}</span>

    _Uninitialized_backout_al(const _Uninitialized_backout_al&amp;) = delete;
    _Uninitialized_backout_al&amp; operator=(const _Uninitialized_backout_al&amp;) = delete;

<span style = "background-color:#dfd">    _CONSTEXPR20_DYNALLOC ~_Uninitialized_backout_al() {
        _Destroy_range(_First, _Last, _Al);
    }</span>

    template &lt;class... _Types&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_DYNALLOC void _Emplace_back(_Types&amp;&amp;... _Vals) { // construct a new element at *_Last and increment
        allocator_traits&lt;_Alloc&gt;::construct(_Al, _Unfancy(_Last), _STD forward&lt;_Types&gt;(_Vals)...);
        ++_Last;
    }</span>

<span style = "background-color:#dfd">    constexpr pointer _Release() { // suppress any exception handling backout and return _Last
        _First = _Last;
        return _Last;
    }</span>

private:
    pointer _First;
    pointer _Last;
    _Alloc&amp; _Al;
};

// FUNCTION TEMPLATE _Uninitialized_copy WITH ALLOCATOR
template &lt;class _InIt, class _Alloc&gt;
_CONSTEXPR20_DYNALLOC _Alloc_ptr_t&lt;_Alloc&gt; _Uninitialized_copy(
<span style = "background-color:#dfd">    const _InIt _First, const _InIt _Last, _Alloc_ptr_t&lt;_Alloc&gt; _Dest, _Alloc&amp; _Al) {</span>
    // copy [_First, _Last) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval = typename _Alloc::value_type*;

<span style = "background-color:#dfd">    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);</span>

    if constexpr (conjunction_v&lt;bool_constant&lt;_Ptr_copy_cat&lt;decltype(_UFirst), _Ptrval&gt;::_Really_trivial&gt;,
                      _Uses_default_construct&lt;_Alloc, _Ptrval, decltype(*_UFirst)&gt;&gt;) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
<span style = "background-color:#dfd">            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            _Dest += _ULast - _UFirst;
            return _Dest;</span>
        }
    }

<span style = "background-color:#dfd">    _Uninitialized_backout_al&lt;_Alloc&gt; _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(*_UFirst);
    }</span>

<span style = "background-color:#dfd">    return _Backout._Release();
}</span>

// FUNCTION TEMPLATE uninitialized_copy
template &lt;class _InIt, class _NoThrowFwdIt&gt;
_CONSTEXPR20_DYNALLOC _NoThrowFwdIt _Uninitialized_copy_unchecked(
    _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // copy [_First, _Last) to raw [_Dest, ...)
    if constexpr (_Ptr_copy_cat&lt;_InIt, _NoThrowFwdIt&gt;::_Really_trivial) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
    }

    _Uninitialized_backout&lt;_NoThrowFwdIt&gt; _Backout{_Dest};
    for (; _First != _Last; ++_First) {
        _Backout._Emplace_back(*_First);
    }

    return _Backout._Release();
}

template &lt;class _InIt, class _NoThrowFwdIt&gt;
_NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest) {
    // copy [_First, _Last) to raw [_Dest, ...)
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    auto _UDest       = _Get_unwrapped_n(_Dest, _Idl_distance&lt;_InIt&gt;(_UFirst, _ULast));
    _Seek_wrapped(_Dest, _Uninitialized_copy_unchecked(_UFirst, _ULast, _UDest));
    return _Dest;
}

// FUNCTION TEMPLATE _Uninitialized_move WITH ALLOCATOR
template &lt;class _InIt, class _Alloc&gt;
_CONSTEXPR20_DYNALLOC _Alloc_ptr_t&lt;_Alloc&gt; _Uninitialized_move(
<span style = "background-color:#dfd">    const _InIt _First, const _InIt _Last, _Alloc_ptr_t&lt;_Alloc&gt; _Dest, _Alloc&amp; _Al) {</span>
    // move [_First, _Last) to raw _Dest, using _Al
    // note: only called internally from elsewhere in the STL
    using _Ptrval     = typename _Alloc::value_type*;
<span style = "background-color:#dfd">    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);</span>
    if constexpr (conjunction_v&lt;bool_constant&lt;_Ptr_move_cat&lt;decltype(_UFirst), _Ptrval&gt;::_Really_trivial&gt;,
                      _Uses_default_construct&lt;_Alloc, _Ptrval, decltype(_STD move(*_UFirst))&gt;&gt;) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
<span style = "background-color:#dfd">            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);</span>
        }
    }

<span style = "background-color:#dfd">    _Uninitialized_backout_al&lt;_Alloc&gt; _Backout{_Dest, _Al};
    for (; _UFirst != _ULast; ++_UFirst) {
        _Backout._Emplace_back(_STD move(*_UFirst));
    }</span>

<span style = "background-color:#dfd">    return _Backout._Release();
}</span>

// FUNCTION TEMPLATE _Uninitialized_fill_n WITH ALLOCATOR
template &lt;class _Alloc&gt;
_CONSTEXPR20_DYNALLOC _Alloc_ptr_t&lt;_Alloc&gt; _Uninitialized_fill_n(
    _Alloc_ptr_t&lt;_Alloc&gt; _First, _Alloc_size_t&lt;_Alloc&gt; _Count, const typename _Alloc::value_type&amp; _Val, _Alloc&amp; _Al) {
    // copy _Count copies of _Val to raw _First, using _Al
    using _Ty = typename _Alloc::value_type;
    if constexpr (_Fill_memset_is_safe&lt;_Ty*, _Ty&gt; &amp;&amp; _Uses_default_construct&lt;_Alloc, _Ty*, _Ty&gt;::value) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            _Fill_memset(_Unfancy(_First), _Val, static_cast&lt;size_t&gt;(_Count));
            return _First + _Count;
        }
    } else if constexpr (_Fill_zero_memset_is_safe&lt;_Ty*, _Ty&gt; &amp;&amp; _Uses_default_construct&lt;_Alloc, _Ty*, _Ty&gt;::value) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_Unfancy(_First), static_cast&lt;size_t&gt;(_Count));
                return _First + _Count;
            }
        }
    }

    _Uninitialized_backout_al&lt;_Alloc&gt; _Backout{_First, _Al};
    for (; 0 &lt; _Count; --_Count) {
        _Backout._Emplace_back(_Val);
    }

    return _Backout._Release();
}

// FUNCTION TEMPLATE uninitialized_fill
template &lt;class _NoThrowFwdIt, class _Tval&gt;
void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval&amp; _Val) {
    // copy _Val throughout raw [_First, _Last)
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    if constexpr (_Fill_memset_is_safe&lt;_Unwrapped_t&lt;const _NoThrowFwdIt&amp;&gt;, _Tval&gt;) {
        _Fill_memset(_UFirst, _Val, static_cast&lt;size_t&gt;(_ULast - _UFirst));
    } else {
        if constexpr (_Fill_zero_memset_is_safe&lt;_Unwrapped_t&lt;const _NoThrowFwdIt&amp;&gt;, _Tval&gt;) {
            if (_Is_all_bits_zero(_Val)) {
                _Fill_zero_memset(_UFirst, static_cast&lt;size_t&gt;(_ULast - _UFirst));
                return;
            }
        }

        _Uninitialized_backout&lt;_Unwrapped_t&lt;const _NoThrowFwdIt&amp;&gt;&gt; _Backout{_UFirst};
        while (_Backout._Last != _ULast) {
            _Backout._Emplace_back(_Val);
        }

        _Backout._Release();
    }
}

// FUNCTION TEMPLATE _Uninitialized_value_construct_n WITH ALLOCATOR
template &lt;class _NoThrowFwdIt&gt;
_INLINE_VAR constexpr bool _Use_memset_value_construct_v =
    conjunction_v&lt;bool_constant&lt;_Iterator_is_contiguous&lt;_NoThrowFwdIt&gt;&gt;, is_scalar&lt;_Iter_value_t&lt;_NoThrowFwdIt&gt;&gt;,
        negation&lt;is_volatile&lt;remove_reference_t&lt;_Iter_ref_t&lt;_NoThrowFwdIt&gt;&gt;&gt;&gt;,
        negation&lt;is_member_pointer&lt;_Iter_value_t&lt;_NoThrowFwdIt&gt;&gt;&gt;&gt;;

template &lt;class _Ptr&gt;
_Ptr _Zero_range(const _Ptr _First, const _Ptr _Last) { // fill [_First, _Last) with zeroes
    char* const _First_ch = reinterpret_cast&lt;char*&gt;(_To_address(_First));
    char* const _Last_ch  = reinterpret_cast&lt;char*&gt;(_To_address(_Last));
    _CSTD memset(_First_ch, 0, static_cast&lt;size_t&gt;(_Last_ch - _First_ch));
    return _Last;
}

template &lt;class _Alloc&gt;
_CONSTEXPR20_DYNALLOC _Alloc_ptr_t&lt;_Alloc&gt; _Uninitialized_value_construct_n(
    _Alloc_ptr_t&lt;_Alloc&gt; _First, _Alloc_size_t&lt;_Alloc&gt; _Count, _Alloc&amp; _Al) {
    // value-initialize _Count objects to raw _First, using _Al
    using _Ptrty = typename _Alloc::value_type*;
    if constexpr (_Use_memset_value_construct_v&lt;_Ptrty&gt; &amp;&amp; _Uses_default_construct&lt;_Alloc, _Ptrty&gt;::value) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
    }

    _Uninitialized_backout_al&lt;_Alloc&gt; _Backout{_First, _Al};
    for (; 0 &lt; _Count; --_Count) {
        _Backout._Emplace_back();
    }

    return _Backout._Release();
}

template &lt;class _NoThrowFwdIt, class _Diff&gt;
_NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count) {
    // value-initialize all elements in [_UFirst, _UFirst + _Count_raw)
    _STL_INTERNAL_CHECK(_Count &gt;= 0);
    if constexpr (_Use_memset_value_construct_v&lt;_NoThrowFwdIt&gt;) {
        return _Zero_range(_UFirst, _UFirst + _Count);
    } else {
        _Uninitialized_backout&lt;_NoThrowFwdIt&gt; _Backout{_UFirst};
        for (; 0 &lt; _Count; --_Count) {
            _Backout._Emplace_back();
        }

        return _Backout._Release();
    }
}

#if _HAS_DEPRECATED_TEMPORARY_BUFFER
// FUNCTION TEMPLATE get_temporary_buffer
template &lt;class _Ty&gt;
_CXX17_DEPRECATE_TEMPORARY_BUFFER _NODISCARD pair&lt;_Ty*, ptrdiff_t&gt; get_temporary_buffer(ptrdiff_t _Count) noexcept {
    return _Get_temporary_buffer&lt;_Ty&gt;(_Count);
}

// FUNCTION TEMPLATE return_temporary_buffer
template &lt;class _Ty&gt;
_CXX17_DEPRECATE_TEMPORARY_BUFFER void return_temporary_buffer(_Ty* _Pbuf) {
    _Return_temporary_buffer(_Pbuf);
}
#endif // _HAS_DEPRECATED_TEMPORARY_BUFFER

// STRUCT TEMPLATE _In_place_key_extract_set
// assumes _Args have already been _Remove_cvref_t'd
template &lt;class _Key, class... _Args&gt;
struct _In_place_key_extract_set {
    // by default we can't extract the key in the emplace family and must construct a node we might not use
    static constexpr bool _Extractable = false;
};

template &lt;class _Key&gt;
struct _In_place_key_extract_set&lt;_Key, _Key&gt; {
    // we can extract the key in emplace if the emplaced type is identical to the key type
    static constexpr bool _Extractable = true;
    static const _Key&amp; _Extract(const _Key&amp; _Val) noexcept {
        return _Val;
    }
};

// STRUCT TEMPLATE _In_place_key_extract_map
// assumes _Args have already been _Remove_cvref_t'd
template &lt;class _Key, class... _Args&gt;
struct _In_place_key_extract_map {
    // by default we can't extract the key in the emplace family and must construct a node we might not use
    static constexpr bool _Extractable = false;
};

template &lt;class _Key, class _Second&gt;
struct _In_place_key_extract_map&lt;_Key, _Key, _Second&gt; {
    // if we would call the pair(key, value) constructor family, we can use the first parameter as the key
    static constexpr bool _Extractable = true;
    static const _Key&amp; _Extract(const _Key&amp; _Val, const _Second&amp;) noexcept {
        return _Val;
    }
};

template &lt;class _Key, class _First, class _Second&gt;
struct _In_place_key_extract_map&lt;_Key, pair&lt;_First, _Second&gt;&gt; {
    // if we would call the pair(pair&lt;other, other&gt;) constructor family, we can use the pair.first member as the key
    static constexpr bool _Extractable = is_same_v&lt;_Key, _Remove_cvref_t&lt;_First&gt;&gt;;
    static const _Key&amp; _Extract(const pair&lt;_First, _Second&gt;&amp; _Val) {
        return _Val.first;
    }
};

// STRUCT TEMPLATE _Wrap
#pragma warning(push)
#pragma warning(disable : 4624) // '%s': destructor was implicitly defined as deleted
template &lt;class _Ty&gt;
struct _Wrap {
    _Ty _Value; // workaround for "T^ is not allowed in a union"
};
#pragma warning(pop)

// STRUCT TEMPLATE _Alloc_temporary
template &lt;class _Alloc&gt;
struct _Alloc_temporary {
    using value_type = typename _Alloc::value_type;
    using _Traits    = allocator_traits&lt;_Alloc&gt;;

    _Alloc&amp; _Al;
    union {
        _Wrap&lt;value_type&gt; _Storage;
    };

    template &lt;class... _Args&gt;
    explicit _Alloc_temporary(_Alloc&amp; _Al_, _Args&amp;&amp;... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, _STD addressof(_Storage._Value), _STD forward&lt;_Args&gt;(_Vals)...)))
        : _Al(_Al_) {
        _Traits::construct(_Al, _STD addressof(_Storage._Value), _STD forward&lt;_Args&gt;(_Vals)...);
    }

    _Alloc_temporary(const _Alloc_temporary&amp;) = delete;
    _Alloc_temporary&amp; operator=(const _Alloc_temporary&amp;) = delete;

    ~_Alloc_temporary() {
        _Traits::destroy(_Al, _STD addressof(_Storage._Value));
    }
};

template &lt;class _Alloc&gt;
_NODISCARD constexpr bool _Allocators_equal(const _Alloc&amp; _Lhs, const _Alloc&amp; _Rhs) noexcept {
    if constexpr (allocator_traits&lt;_Alloc&gt;::is_always_equal::value) {
        return true;
    } else {
        return _Lhs == _Rhs;
    }
}

// FUNCTION TEMPLATE remove
template &lt;class _FwdIt, class _Ty&gt;
_NODISCARD _CONSTEXPR20 _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty&amp; _Val) {
    // remove each matching _Val
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = _Find_unchecked(_UFirst, _ULast, _Val);
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!(*_UFirst == _Val)) {
                *_UNext = _STD move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

// FUNCTION TEMPLATE remove_if
template &lt;class _FwdIt, class _Pr&gt;
_NODISCARD _CONSTEXPR20 _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred) {
    // remove each satisfying _Pred
    _Adl_verify_range(_First, _Last);
    auto _UFirst      = _Get_unwrapped(_First);
    const auto _ULast = _Get_unwrapped(_Last);
    _UFirst           = _STD find_if(_UFirst, _ULast, _Pass_fn(_Pred));
    auto _UNext       = _UFirst;
    if (_UFirst != _ULast) {
        while (++_UFirst != _ULast) {
            if (!_Pred(*_UFirst)) {
                *_UNext = _STD move(*_UFirst);
                ++_UNext;
            }
        }
    }

    _Seek_wrapped(_First, _UNext);
    return _First;
}

// FUNCTION TEMPLATE _Erase_remove
template &lt;class _Container, class _Uty&gt;
_CONSTEXPR20_DYNALLOC typename _Container::size_type _Erase_remove(_Container&amp; _Cont, const _Uty&amp; _Val) {
    // erase each element matching _Val
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, _STD remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

// FUNCTION TEMPLATE _Erase_remove_if
template &lt;class _Container, class _Pr&gt;
_CONSTEXPR20_DYNALLOC typename _Container::size_type _Erase_remove_if(_Container&amp; _Cont, _Pr _Pred) {
    // erase each element satisfying _Pred
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    _Seek_wrapped(_First, _STD remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
    _Cont.erase(_First, _Last);
    return _Old_size - _Cont.size();
}

// FUNCTION TEMPLATE _Erase_nodes_if
template &lt;class _Container, class _Pr&gt;
typename _Container::size_type _Erase_nodes_if(_Container&amp; _Cont, _Pr _Pred) {
    // erase each element satisfying _Pred
    auto _First          = _Cont.begin();
    const auto _Last     = _Cont.end();
    const auto _Old_size = _Cont.size();
    while (_First != _Last) {
        if (_Pred(*_First)) {
            _First = _Cont.erase(_First);
        } else {
            ++_First;
        }
    }
    return _Old_size - _Cont.size();
}

#if _HAS_CXX20
template &lt;class _Ty, class _Alloc, class... _Types, enable_if_t&lt;!_Is_specialization_v&lt;_Ty, pair&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc&amp; _Al, _Types&amp;&amp;... _Args) noexcept {
    if constexpr (!uses_allocator_v&lt;_Ty, _Alloc&gt;) {
        static_assert(is_constructible_v&lt;_Ty, _Types...&gt;,
            "If uses_allocator_v&lt;T, Alloc&gt; does not hold, T must be constructible from Types...");
        (void) _Al;
        return _STD forward_as_tuple(_STD forward&lt;_Types&gt;(_Args)...);
    } else if constexpr (is_constructible_v&lt;_Ty, allocator_arg_t, const _Alloc&amp;, _Types...&gt;) {
        using _ReturnType = tuple&lt;allocator_arg_t, const _Alloc&amp;, _Types&amp;&amp;...&gt;;
        return _ReturnType{allocator_arg, _Al, _STD forward&lt;_Types&gt;(_Args)...};
    } else if constexpr (is_constructible_v&lt;_Ty, _Types..., const _Alloc&amp;&gt;) {
        return _STD forward_as_tuple(_STD forward&lt;_Types&gt;(_Args)..., _Al);
    } else {
        static_assert(_Always_false&lt;_Ty&gt;,
            "T must be constructible from either (allocator_arg_t, const Alloc&amp;, Types...) "
            "or (Types..., const Alloc&amp;) if uses_allocator_v&lt;T, Alloc&gt; is true");
    }
}

template &lt;class _Ty, class _Alloc, class _Tuple1, class _Tuple2, enable_if_t&lt;_Is_specialization_v&lt;_Ty, pair&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto uses_allocator_construction_args(
    const _Alloc&amp; _Al, piecewise_construct_t, _Tuple1&amp;&amp; _Tup1, _Tuple2&amp;&amp; _Tup2) noexcept {
    return _STD make_tuple(piecewise_construct,
        _STD apply(
            [&amp;_Al](auto&amp;&amp;... _Tuple_args) {
                return _STD uses_allocator_construction_args&lt;typename _Ty::first_type&gt;(
                    _Al, _STD forward&lt;decltype(_Tuple_args)&gt;(_Tuple_args)...);
            },
            _STD forward&lt;_Tuple1&gt;(_Tup1)),
        _STD apply(
            [&amp;_Al](auto&amp;&amp;... _Tuple_args) {
                return _STD uses_allocator_construction_args&lt;typename _Ty::second_type&gt;(
                    _Al, _STD forward&lt;decltype(_Tuple_args)&gt;(_Tuple_args)...);
            },
            _STD forward&lt;_Tuple2&gt;(_Tup2)));
}

template &lt;class _Ty, class _Alloc, enable_if_t&lt;_Is_specialization_v&lt;_Ty, pair&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc&amp; _Al) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args&lt;_Ty&gt;(_Al, piecewise_construct, tuple&lt;&gt;{}, tuple&lt;&gt;{});
    return _STD make_tuple(piecewise_construct, _STD uses_allocator_construction_args&lt;typename _Ty::first_type&gt;(_Al),
        _STD uses_allocator_construction_args&lt;typename _Ty::second_type&gt;(_Al));
}

template &lt;class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t&lt;_Is_specialization_v&lt;_Ty, pair&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc&amp; _Al, _Uty1&amp;&amp; _Val1, _Uty2&amp;&amp; _Val2) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args&lt;_Ty&gt;(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_STD forward&lt;_Uty1&gt;(_Val1)), _STD forward_as_tuple(_STD forward&lt;_Uty2&gt;(_Val2)));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args&lt;typename _Ty::first_type&gt;(_Al, _STD forward&lt;_Uty1&gt;(_Val1)),
        _STD uses_allocator_construction_args&lt;typename _Ty::second_type&gt;(_Al, _STD forward&lt;_Uty2&gt;(_Val2)));
}

template &lt;class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t&lt;_Is_specialization_v&lt;_Ty, pair&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto uses_allocator_construction_args(
    const _Alloc&amp; _Al, const pair&lt;_Uty1, _Uty2&gt;&amp; _Pair) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args&lt;_Ty&gt;(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_Pair.first), _STD forward_as_tuple(_Pair.second));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args&lt;typename _Ty::first_type&gt;(_Al, _Pair.first),
        _STD uses_allocator_construction_args&lt;typename _Ty::second_type&gt;(_Al, _Pair.second));
}

template &lt;class _Ty, class _Alloc, class _Uty1, class _Uty2, enable_if_t&lt;_Is_specialization_v&lt;_Ty, pair&gt;, int&gt; = 0&gt;
_NODISCARD constexpr auto uses_allocator_construction_args(const _Alloc&amp; _Al, pair&lt;_Uty1, _Uty2&gt;&amp;&amp; _Pair) noexcept {
    // equivalent to
    // return _STD uses_allocator_construction_args&lt;_Ty&gt;(_Al, piecewise_construct,
    //     _STD forward_as_tuple(_STD move(_Pair).first), _STD forward_as_tuple(_STD move(_Pair).second));
    return _STD make_tuple(piecewise_construct,
        _STD uses_allocator_construction_args&lt;typename _Ty::first_type&gt;(_Al, _STD move(_Pair).first),
        _STD uses_allocator_construction_args&lt;typename _Ty::second_type&gt;(_Al, _STD move(_Pair).second));
}

template &lt;class _Ty, class _Alloc, class... _Types&gt;
_NODISCARD constexpr _Ty make_obj_using_allocator(const _Alloc&amp; _Al, _Types&amp;&amp;... _Args) {
    return _STD make_from_tuple&lt;_Ty&gt;(_STD uses_allocator_construction_args&lt;_Ty&gt;(_Al, _STD forward&lt;_Types&gt;(_Args)...));
}

template &lt;class _Ty, class _Alloc, class... _Types&gt;
constexpr _Ty* uninitialized_construct_using_allocator(_Ty* _Ptr, const _Alloc&amp; _Al, _Types&amp;&amp;... _Args) {
    return _STD apply(
        [&amp;](auto&amp;&amp;... _Construct_args) {
            return _STD construct_at(_Ptr, _STD forward&lt;decltype(_Construct_args)&gt;(_Construct_args)...);
        },
        _STD uses_allocator_construction_args&lt;_Ty&gt;(_Al, _STD forward&lt;_Types&gt;(_Args)...));
}
#endif // _HAS_CXX20
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _XMEMORY_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>
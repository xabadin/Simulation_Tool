<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>vector</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// vector standard header

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _VECTOR_
#define _VECTOR_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;xmemory&gt;

#if _HAS_CXX17
#include &lt;xpolymorphic_allocator.h&gt;
#endif // _HAS_CXX17

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// CLASS TEMPLATE _Vector_const_iterator
template &lt;class _Myvec&gt;
class _Vector_const_iterator : public _Iterator_base {
public:
#ifdef __cpp_lib_concepts
    using iterator_concept = contiguous_iterator_tag;
#endif // __cpp_lib_concepts
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::const_pointer;
    using reference         = const value_type&amp;;

    using _Tptr = typename _Myvec::pointer;

    _CONSTEXPR20_CONTAINER _Vector_const_iterator() noexcept : _Ptr() {}

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg) {
        this-&gt;_Adopt(_Pvector);
    }</span>

    // TRANSITION, DevCom-1331017
    _CONSTEXPR20_CONTAINER _Vector_const_iterator&amp; operator=(const _Vector_const_iterator&amp;) noexcept = default;

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(
            _Mycont-&gt;_Myfirst &lt;= _Ptr &amp;&amp; _Ptr &lt; _Mycont-&gt;_Mylast, "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return *_Ptr;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER pointer operator-&gt;() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(
            _Mycont-&gt;_Myfirst &lt;= _Ptr &amp;&amp; _Ptr &lt; _Mycont-&gt;_Mylast, "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Ptr;
    }

    _CONSTEXPR20_CONTAINER _Vector_const_iterator&amp; operator++() noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't increment value-initialized vector iterator");
        _STL_VERIFY(_Ptr &lt; _Mycont-&gt;_Mylast, "can't increment vector iterator past end");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        ++_Ptr;
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vector_const_iterator operator++(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        ++*this;
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vector_const_iterator&amp; operator--() noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Ptr, "can't decrement value-initialized vector iterator");
        _STL_VERIFY(_Mycont-&gt;_Myfirst &lt; _Ptr, "can't decrement vector iterator before begin");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        --_Ptr;
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vector_const_iterator operator--(int) noexcept {
        _Vector_const_iterator _Tmp = *this;
        --*this;
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER void _Verify_offset(const difference_type _Off) const noexcept {
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Off;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Off == 0 || _Ptr, "cannot seek value-initialized vector iterator");
        if (_Off &lt; 0) {
            _STL_VERIFY(_Off &gt;= _Mycont-&gt;_Myfirst - _Ptr, "cannot seek vector iterator before begin");
        }

        if (_Off &gt; 0) {
            _STL_VERIFY(_Off &lt;= _Mycont-&gt;_Mylast - _Ptr, "cannot seek vector iterator after end");
        }
#endif // _ITERATOR_DEBUG_LEVEL == 0
    }

    _CONSTEXPR20_CONTAINER _Vector_const_iterator&amp; operator+=(const difference_type _Off) noexcept {
        _Verify_offset(_Off);
        _Ptr += _Off;
        return *this;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Vector_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp += _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vector_const_iterator&amp; operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Vector_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_const_iterator _Tmp = *this;
        _Tmp -= _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER difference_type operator-(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _Ptr - _Right._Ptr;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER bool operator==(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _Ptr == _Right._Ptr;
    }

#if _HAS_CXX20
    _NODISCARD _CONSTEXPR20_CONTAINER strong_ordering operator&lt;=&gt;(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _Unfancy(_Ptr) &lt;=&gt; _Unfancy(_Right._Ptr);
    }
#else // ^^^ _HAS_CXX20 ^^^ / vvv !_HAS_CXX20 vvv
    _NODISCARD bool operator!=(const _Vector_const_iterator&amp; _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD bool operator&lt;(const _Vector_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return _Ptr &lt; _Right._Ptr;
    }

    _NODISCARD bool operator&gt;(const _Vector_const_iterator&amp; _Right) const noexcept {
        return _Right &lt; *this;
    }

    _NODISCARD bool operator&lt;=(const _Vector_const_iterator&amp; _Right) const noexcept {
        return !(_Right &lt; *this);
    }

    _NODISCARD bool operator&gt;=(const _Vector_const_iterator&amp; _Right) const noexcept {
        return !(*this &lt; _Right);
    }
#endif // !_HAS_CXX20

    _CONSTEXPR20_CONTAINER void _Compat(const _Vector_const_iterator&amp; _Right) const noexcept {
        // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Right;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
        _STL_VERIFY(this-&gt;_Getcont() == _Right._Getcont(), "vector iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL == 0
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    friend _CONSTEXPR20_CONTAINER void _Verify_range(
<span style = "background-color:#dfd">        const _Vector_const_iterator&amp; _First, const _Vector_const_iterator&amp; _Last) noexcept {
        _STL_VERIFY(_First._Getcont() == _Last._Getcont(), "vector iterators in range are from different containers");
        _STL_VERIFY(_First._Ptr &lt;= _Last._Ptr, "vector iterator range transposed");
    }</span>
#endif // _ITERATOR_DEBUG_LEVEL != 0

    using _Prevent_inheriting_unwrap = _Vector_const_iterator;

    _NODISCARD _CONSTEXPR20_CONTAINER const value_type* _Unwrapped() const noexcept {
        return _Unfancy(_Ptr);
    }

    _CONSTEXPR20_CONTAINER void _Seek_to(const value_type* _It) noexcept {
        _Ptr = _Refancy&lt;_Tptr&gt;(const_cast&lt;value_type*&gt;(_It));
    }

    _Tptr _Ptr; // pointer to element in vector
};

template &lt;class _Myvec&gt;
_NODISCARD _CONSTEXPR20_CONTAINER _Vector_const_iterator&lt;_Myvec&gt; operator+(
    typename _Vector_const_iterator&lt;_Myvec&gt;::difference_type _Off, _Vector_const_iterator&lt;_Myvec&gt; _Next) noexcept {
    return _Next += _Off;
}

#if _HAS_CXX20
template &lt;class _Myvec&gt;
struct pointer_traits&lt;_Vector_const_iterator&lt;_Myvec&gt;&gt; {
    using pointer         = _Vector_const_iterator&lt;_Myvec&gt;;
    using element_type    = const typename pointer::value_type;
    using difference_type = typename pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        // A value-initialized iterator is in the domain of to_address. An invalidated end iterator for a vector with
        // capacity() of 0 is not. This function cannot distinguish those two cases, so it incorrectly does not diagnose
        // the latter. In practice, this isn't a significant problem since to_address returns nullptr for such an
        // iterator.
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(_Iter._Getcont());
        if (_Mycont) {
            _STL_VERIFY(_Mycont-&gt;_Myfirst &lt;= _Iter._Ptr &amp;&amp; _Iter._Ptr &lt;= _Mycont-&gt;_Mylast,
                "can't convert out-of-range vector iterator to pointer");
        } else {
            _STL_VERIFY(!_Iter._Ptr, "can't convert invalid vector iterator to pointer");
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _STD to_address(_Iter._Ptr);
    }
};
#endif // _HAS_CXX20

// CLASS TEMPLATE _Vector_iterator
template &lt;class _Myvec&gt;
class _Vector_iterator : public _Vector_const_iterator&lt;_Myvec&gt; {
public:
    using _Mybase = _Vector_const_iterator&lt;_Myvec&gt;;

#ifdef __cpp_lib_concepts
    using iterator_concept = contiguous_iterator_tag;
#endif // __cpp_lib_concepts
    using iterator_category = random_access_iterator_tag;
    using value_type        = typename _Myvec::value_type;
    using difference_type   = typename _Myvec::difference_type;
    using pointer           = typename _Myvec::pointer;
    using reference         = value_type&amp;;

    using _Mybase::_Mybase;

    // TRANSITION, DevCom-1331017
    _CONSTEXPR20_CONTAINER _Vector_iterator&amp; operator=(const _Vector_iterator&amp;) noexcept = default;

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator*() const noexcept {
        return const_cast&lt;reference&gt;(_Mybase::operator*());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER pointer operator-&gt;() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(this-&gt;_Ptr, "can't dereference value-initialized vector iterator");
        _STL_VERIFY(_Mycont-&gt;_Myfirst &lt;= this-&gt;_Ptr &amp;&amp; this-&gt;_Ptr &lt; _Mycont-&gt;_Mylast,
            "can't dereference out of range vector iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return this-&gt;_Ptr;
    }

    _CONSTEXPR20_CONTAINER _Vector_iterator&amp; operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vector_iterator operator++(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vector_iterator&amp; operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vector_iterator operator--(int) noexcept {
        _Vector_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vector_iterator&amp; operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Vector_iterator operator+(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp += _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vector_iterator&amp; operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    _NODISCARD _CONSTEXPR20_CONTAINER _Vector_iterator operator-(const difference_type _Off) const noexcept {
        _Vector_iterator _Tmp = *this;
        _Tmp -= _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](const difference_type _Off) const noexcept {
        return const_cast&lt;reference&gt;(_Mybase::operator[](_Off));
    }

    using _Prevent_inheriting_unwrap = _Vector_iterator;

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER value_type* _Unwrapped() const noexcept {
        return _Unfancy(this-&gt;_Ptr);
    }</span>
};

template &lt;class _Myvec&gt;
_NODISCARD _CONSTEXPR20_CONTAINER _Vector_iterator&lt;_Myvec&gt; operator+(
    typename _Vector_iterator&lt;_Myvec&gt;::difference_type _Off, _Vector_iterator&lt;_Myvec&gt; _Next) noexcept {
    return _Next += _Off;
}

#if _HAS_CXX20
template &lt;class _Myvec&gt;
struct pointer_traits&lt;_Vector_iterator&lt;_Myvec&gt;&gt; {
    using pointer         = _Vector_iterator&lt;_Myvec&gt;;
    using element_type    = typename pointer::value_type;
    using difference_type = typename pointer::difference_type;

    _NODISCARD static constexpr element_type* to_address(const pointer _Iter) noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        // A value-initialized iterator is in the domain of to_address. An invalidated end iterator for a vector with
        // capacity() of 0 is not. This function cannot distinguish those two cases, so it incorrectly does not diagnose
        // the latter. In practice, this isn't a significant problem since to_address returns nullptr for such an
        // iterator.
        const auto _Mycont = static_cast&lt;const _Myvec*&gt;(_Iter._Getcont());
        if (_Mycont) {
            _STL_VERIFY(_Mycont-&gt;_Myfirst &lt;= _Iter._Ptr &amp;&amp; _Iter._Ptr &lt;= _Mycont-&gt;_Mylast,
                "can't convert out-of-range vector iterator to pointer");
        } else {
            _STL_VERIFY(!_Iter._Ptr, "can't convert invalid vector iterator to pointer");
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _STD to_address(_Iter._Ptr);
    }
};
#endif // _HAS_CXX20

// vector TYPE WRAPPERS
template &lt;class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer,
    class _Reference, class _Const_reference&gt;
struct _Vec_iter_types {
    using value_type      = _Value_type;
    using size_type       = _Size_type;
    using difference_type = _Difference_type;
    using pointer         = _Pointer;
    using const_pointer   = _Const_pointer;
};

// STRUCT _Value_init_tag
struct _Value_init_tag { // tag to request value-initialization
    explicit _Value_init_tag() = default;
};

// CLASS TEMPLATE _Vector_val
template &lt;class _Val_types&gt;
class _Vector_val : public _Container_base {
public:
    using value_type      = typename _Val_types::value_type;
    using size_type       = typename _Val_types::size_type;
    using difference_type = typename _Val_types::difference_type;
    using pointer         = typename _Val_types::pointer;
    using const_pointer   = typename _Val_types::const_pointer;
    using reference       = value_type&amp;;
    using const_reference = const value_type&amp;;

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend() {}</span>

    _CONSTEXPR20_CONTAINER _Vector_val(pointer _First, pointer _Last, pointer _End) noexcept
<span style = "background-color:#dfd">        : _Myfirst(_First), _Mylast(_Last), _Myend(_End) {}</span>

    _CONSTEXPR20_CONTAINER void _Swap_val(_Vector_val&amp; _Right) noexcept {
        this-&gt;_Swap_proxy_and_iterators(_Right);
        _Swap_adl(_Myfirst, _Right._Myfirst);
        _Swap_adl(_Mylast, _Right._Mylast);
        _Swap_adl(_Myend, _Right._Myend);
    }

    _CONSTEXPR20_CONTAINER void _Take_contents(_Vector_val&amp; _Right) noexcept {
        this-&gt;_Swap_proxy_and_iterators(_Right);
        _Myfirst = _Right._Myfirst;
        _Mylast  = _Right._Mylast;
        _Myend   = _Right._Myend;

        _Right._Myfirst = nullptr;
        _Right._Mylast  = nullptr;
        _Right._Myend   = nullptr;
    }

    pointer _Myfirst; // pointer to beginning of array
    pointer _Mylast; // pointer to current end of sequence
    pointer _Myend; // pointer to end of array
};

// FUNCTION TEMPLATE _Unfancy_maybe_null
template &lt;class _Ptrty&gt;
constexpr auto _Unfancy_maybe_null(_Ptrty _Ptr) noexcept {
    // converts from a (potentially null) fancy pointer to a plain pointer
    return _Ptr ? _STD addressof(*_Ptr) : nullptr;
}

template &lt;class _Ty&gt;
constexpr _Ty* _Unfancy_maybe_null(_Ty* _Ptr) noexcept { // do nothing for plain pointers
    return _Ptr;
}

// CLASS TEMPLATE vector
template &lt;class _Ty, class _Alloc = allocator&lt;_Ty&gt;&gt;
class vector { // varying size array of values
private:
    template &lt;class&gt;
    friend class _Vb_val;
    friend _Tidy_guard&lt;vector&gt;;

    using _Alty        = _Rebind_alloc_t&lt;_Alloc, _Ty&gt;;
    using _Alty_traits = allocator_traits&lt;_Alty&gt;;

public:
    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v&lt;_Ty, typename _Alloc::value_type&gt;,
        _MISMATCHED_ALLOCATOR_MESSAGE("vector&lt;T, Allocator&gt;", "T"));

    using value_type      = _Ty;
    using allocator_type  = _Alloc;
    using pointer         = typename _Alty_traits::pointer;
    using const_pointer   = typename _Alty_traits::const_pointer;
    using reference       = _Ty&amp;;
    using const_reference = const _Ty&amp;;
    using size_type       = typename _Alty_traits::size_type;
    using difference_type = typename _Alty_traits::difference_type;

private:
    using _Scary_val = _Vector_val&lt;conditional_t&lt;_Is_simple_alloc_v&lt;_Alty&gt;, _Simple_types&lt;_Ty&gt;,
        _Vec_iter_types&lt;_Ty, size_type, difference_type, pointer, const_pointer, _Ty&amp;, const _Ty&amp;&gt;&gt;&gt;;

public:
    using iterator               = _Vector_iterator&lt;_Scary_val&gt;;
    using const_iterator         = _Vector_const_iterator&lt;_Scary_val&gt;;
    using reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;

    _CONSTEXPR20_CONTAINER vector() noexcept(is_nothrow_default_constructible_v&lt;_Alty&gt;)
<span style = "background-color:#dfd">        : _Mypair(_Zero_then_variadic_args_t{}) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    }</span>

    _CONSTEXPR20_CONTAINER explicit vector(const _Alloc&amp; _Al) noexcept : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
    }

private:
    template &lt;class _Ty2&gt;
    _CONSTEXPR20_CONTAINER void _Construct_n_copies_of_ty(_CRT_GUARDOVERFLOW const size_type _Count, const _Ty2&amp; _Val) {
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        auto&amp; _My_data  = _Mypair._Myval2;
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _My_data);
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard&lt;vector&gt; _Guard{this};
            _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);
            _Guard._Target   = nullptr;
        }

        _Proxy._Release();
    }

public:
    _CONSTEXPR20_CONTAINER explicit vector(_CRT_GUARDOVERFLOW const size_type _Count, const _Alloc&amp; _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
    }

    _CONSTEXPR20_CONTAINER vector(
        _CRT_GUARDOVERFLOW const size_type _Count, const _Ty&amp; _Val, const _Alloc&amp; _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        _Construct_n_copies_of_ty(_Count, _Val);
    }

private:
    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, input_iterator_tag) {
        _Tidy_guard&lt;vector&gt; _Guard{this};
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
        }

        _Guard._Target = nullptr;
    }

    template &lt;class _Iter&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag) {
        const auto _Count = _Convert_size&lt;size_type&gt;(static_cast&lt;size_t&gt;(_STD distance(_First, _Last)));
        if (_Count != 0) {
            _Buy_nonzero(_Count);
            _Tidy_guard&lt;vector&gt; _Guard{this};
            auto&amp; _My_data   = _Mypair._Myval2;
            _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);
            _Guard._Target   = nullptr;
        }
    }</span>

public:
    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20_CONTAINER vector(_Iter _First, _Iter _Last, const _Alloc&amp; _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _Mypair._Myval2);
        _Adl_verify_range(_First, _Last);
        _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t&lt;_Iter&gt;{});
        _Proxy._Release();
    }

    _CONSTEXPR20_CONTAINER vector(initializer_list&lt;_Ty&gt; _Ilist, const _Alloc&amp; _Al = _Alloc())
<span style = "background-color:#dfd">        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _Mypair._Myval2);
        _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        _Proxy._Release();
    }</span>

    _CONSTEXPR20_CONTAINER vector(const vector&amp; _Right)
<span style = "background-color:#dfd">        : _Mypair(_One_then_variadic_args_t{}, _Alty_traits::select_on_container_copy_construction(_Right._Getal())) {
        auto&amp;&amp; _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        auto&amp; _My_data            = _Mypair._Myval2;
        const auto&amp; _Right_data   = _Right._Mypair._Myval2;
        const pointer _Rightfirst = _Right_data._Myfirst;
        const pointer _Rightlast  = _Right_data._Mylast;
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _My_data);
        if (_Rightfirst != _Rightlast) {
            _Buy_raw(static_cast&lt;size_type&gt;(_Rightlast - _Rightfirst));
            _Tidy_guard&lt;vector&gt; _Guard{this};
            _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);
            _Guard._Target   = nullptr;
        }</span>

<span style = "background-color:#dfd">        _Proxy._Release();
    }</span>

    _CONSTEXPR20_CONTAINER vector(const vector&amp; _Right, const _Alloc&amp; _Al) : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&amp;&amp; _Alproxy           = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        auto&amp; _My_data            = _Mypair._Myval2;
        const auto&amp; _Right_data   = _Right._Mypair._Myval2;
        const pointer _Rightfirst = _Right_data._Myfirst;
        const pointer _Rightlast  = _Right_data._Mylast;
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _My_data);
        if (_Rightfirst != _Rightlast) {
            _Buy_raw(static_cast&lt;size_type&gt;(_Rightlast - _Rightfirst));
            _Tidy_guard&lt;vector&gt; _Guard{this};
            _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);
            _Guard._Target   = nullptr;
        }

        _Proxy._Release();
    }

private:
    _CONSTEXPR20_CONTAINER void _Move_construct(vector&amp; _Right, true_type) noexcept {
        // move from _Right, stealing its contents
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
    }

    _CONSTEXPR20_CONTAINER void _Move_construct(vector&amp; _Right, false_type) {
        // move from _Right, possibly moving its contents
        if constexpr (!_Alty_traits::is_always_equal::value) {
            if (_Getal() != _Right._Getal()) {
                const auto&amp; _Right_data   = _Right._Mypair._Myval2;
                const pointer _Rightfirst = _Right_data._Myfirst;
                const pointer _Rightlast  = _Right_data._Mylast;
                if (_Rightfirst != _Rightlast) {
                    _Buy_raw(static_cast&lt;size_type&gt;(_Rightlast - _Rightfirst));
                    _Tidy_guard&lt;vector&gt; _Guard{this};
                    auto&amp; _My_data   = _Mypair._Myval2;
                    _My_data._Mylast = _Umove(_Rightfirst, _Rightlast, _My_data._Myfirst);
                    _Guard._Target   = nullptr;
                }
                return;
            }
        }

        _Move_construct(_Right, true_type{});
    }

public:
    _CONSTEXPR20_CONTAINER vector(vector&amp;&amp; _Right) noexcept
<span style = "background-color:#dfd">        : _Mypair(_One_then_variadic_args_t{}, _STD move(_Right._Getal()),</span>
            _STD exchange(_Right._Mypair._Myval2._Myfirst, nullptr),
            _STD exchange(_Right._Mypair._Myval2._Mylast, nullptr),
<span style = "background-color:#dfd">            _STD exchange(_Right._Mypair._Myval2._Myend, nullptr)) {
        _Mypair._Myval2._Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alty, _Getal()));
        _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
    }</span>

    _CONSTEXPR20_CONTAINER vector(vector&amp;&amp; _Right, const _Alloc&amp; _Al) noexcept(
        _Alty_traits::is_always_equal::value) // strengthened
        : _Mypair(_One_then_variadic_args_t{}, _Al) {
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Container_proxy_ptr&lt;_Alty&gt; _Proxy(_Alproxy, _Mypair._Myval2);
        _Move_construct(_Right, typename _Alty_traits::is_always_equal::type{});
        _Proxy._Release();
    }

private:
    _CONSTEXPR20_CONTAINER void _Move_assign(vector&amp; _Right, _Equal_allocators) noexcept {
        _Tidy();
        _Pocma(_Getal(), _Right._Getal());
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
    }

    _CONSTEXPR20_CONTAINER void _Move_assign(vector&amp; _Right, _Propagate_allocators) noexcept /* terminates */ {
        _Tidy();
#if _ITERATOR_DEBUG_LEVEL != 0
        if (_Getal() != _Right._Getal()) {
            // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
            _Mypair._Myval2._Reload_proxy(
                _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
        }
#endif

        _Pocma(_Getal(), _Right._Getal());
        _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
    }

    _CONSTEXPR20_CONTAINER void _Move_assign(vector&amp; _Right, _No_propagate_allocators) {
        if (_Getal() == _Right._Getal()) {
            _Move_assign(_Right, _Equal_allocators{});
        } else {
            auto&amp; _Right_data    = _Right._Mypair._Myval2;
            const pointer _First = _Right_data._Myfirst;
            const pointer _Last  = _Right_data._Mylast;
            const auto _Newsize  = static_cast&lt;size_type&gt;(_Last - _First);

            auto&amp; _My_data    = _Mypair._Myval2;
            pointer&amp; _Myfirst = _My_data._Myfirst;
            pointer&amp; _Mylast  = _My_data._Mylast;

            _My_data._Orphan_all();

            const auto _Oldcapacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Myfirst);
            if constexpr (conjunction_v&lt;bool_constant&lt;_Ptr_copy_cat&lt;_Ty*, _Ty*&gt;::_Trivially_copyable&gt;,
                              _Uses_default_construct&lt;_Alty, _Ty*, _Ty&gt;, _Uses_default_destroy&lt;_Alty, _Ty*&gt;&gt;) {
                if (_Newsize &gt; _Oldcapacity) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy&lt;pointer&gt;(_Copy_memmove(_Unfancy(_First), _Unfancy(_Last), _Unfancy(_Myfirst)));
            } else {
                auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);

                if (_Newsize &gt; _Oldsize) {
                    if (_Newsize &gt; _Oldcapacity) { // reallocate
                        _Clear_and_reserve_geometric(_Newsize);
                        _Oldsize = 0;
                    }

                    const pointer _Mid = _First + _Oldsize;
                    _Move_unchecked(_First, _Mid, _Myfirst);
                    _Mylast = _Umove(_Mid, _Last, _Mylast);
                } else {
                    const pointer _Newlast = _Myfirst + _Newsize;
                    _Move_unchecked(_First, _Last, _Myfirst);
                    _Destroy(_Newlast, _Mylast);
                    _Mylast = _Newlast;
                }
            }
        }
    }

public:
    _CONSTEXPR20_CONTAINER vector&amp; operator=(vector&amp;&amp; _Right) noexcept(
        noexcept(_Move_assign(_Right, _Choose_pocma&lt;_Alty&gt;{}))) {
        if (this != _STD addressof(_Right)) {
            _Move_assign(_Right, _Choose_pocma&lt;_Alty&gt;{});
        }

        return *this;
    }

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER ~vector() noexcept {
        _Tidy();</span>
#if _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#dfd">        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alty, _Getal());
        _Delete_plain_internal(_Alproxy, _STD exchange(_Mypair._Myval2._Myproxy, nullptr));</span>
#endif // _ITERATOR_DEBUG_LEVEL != 0
<span style = "background-color:#dfd">    }</span>

private:
    template &lt;class... _Valty&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER decltype(auto) _Emplace_back_with_unused_capacity(_Valty&amp;&amp;... _Val) {</span>
        // insert by perfectly forwarding into element at end, provide strong guarantee
<span style = "background-color:#dfd">        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;</span>
        _STL_INTERNAL_CHECK(_Mylast != _My_data._Myend); // check that we have unused capacity
<span style = "background-color:#dfd">        _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), _STD forward&lt;_Valty&gt;(_Val)...);
        _Orphan_range(_Mylast, _Mylast);
        _Ty&amp; _Result = *_Mylast;
        ++_Mylast;</span>
#if _HAS_CXX17
        return _Result;
#else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
        (void) _Result;
#endif // _HAS_CXX17
<span style = "background-color:#dfd">    }</span>

public:
    template &lt;class... _Valty&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&amp;&amp;... _Val) {</span>
        // insert by perfectly forwarding into element at end, provide strong guarantee
<span style = "background-color:#dfd">        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;
        if (_Mylast != _My_data._Myend) {
            return _Emplace_back_with_unused_capacity(_STD forward&lt;_Valty&gt;(_Val)...);</span>
        }

<span style = "background-color:#dfd">        _Ty&amp; _Result = *_Emplace_reallocate(_Mylast, _STD forward&lt;_Valty&gt;(_Val)...);</span>
#if _HAS_CXX17
        return _Result;
#else // ^^^ _HAS_CXX17 ^^^ // vvv !_HAS_CXX17 vvv
        (void) _Result;
#endif // _HAS_CXX17
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void push_back(const _Ty&amp; _Val) { // insert element at end, provide strong guarantee
        emplace_back(_Val);
    }</span>

    _CONSTEXPR20_CONTAINER void push_back(_Ty&amp;&amp; _Val) {
        // insert by moving into element at end, provide strong guarantee
        emplace_back(_STD move(_Val));
    }

    template &lt;class... _Valty&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&amp;&amp;... _Val) {</span>
        // reallocate and insert by perfectly forwarding _Val at _Whereptr
<span style = "background-color:#dfd">        _Alty&amp; _Al        = _Getal();
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;</span>

        _STL_INTERNAL_CHECK(_Mylast == _My_data._Myend); // check that we have no unused capacity

<span style = "background-color:#dfd">        const auto _Whereoff = static_cast&lt;size_type&gt;(_Whereptr - _Myfirst);
        const auto _Oldsize  = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);</span>

<span style = "background-color:#dfd">        if (_Oldsize == max_size()) {</span>
<span style = "background-color:#fdd">            _Xlength();</span>
        }

<span style = "background-color:#dfd">        const size_type _Newsize     = _Oldsize + 1;
        const size_type _Newcapacity = _Calculate_growth(_Newsize);</span>

<span style = "background-color:#dfd">        const pointer _Newvec           = _Al.allocate(_Newcapacity);
        const pointer _Constructed_last = _Newvec + _Whereoff + 1;
        pointer _Constructed_first      = _Constructed_last;</span>

<span style = "background-color:#dfd">        _TRY_BEGIN
        _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), _STD forward&lt;_Valty&gt;(_Val)...);
        _Constructed_first = _Newvec + _Whereoff;</span>

<span style = "background-color:#dfd">        if (_Whereptr == _Mylast) { // at back, provide strong guarantee
            _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
        } else { // provide basic guarantee</span>
<span style = "background-color:#fdd">            _Umove(_Myfirst, _Whereptr, _Newvec);
            _Constructed_first = _Newvec;
            _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);</span>
        }
        _CATCH_ALL
<span style = "background-color:#fdd">        _Destroy(_Constructed_first, _Constructed_last);
        _Al.deallocate(_Newvec, _Newcapacity);
        _RERAISE;
        _CATCH_END</span>

<span style = "background-color:#dfd">        _Change_array(_Newvec, _Newsize, _Newcapacity);
        return _Newvec + _Whereoff;
    }</span>

    template &lt;class... _Valty&gt;
    _CONSTEXPR20_CONTAINER iterator emplace(const_iterator _Where, _Valty&amp;&amp;... _Val) {
        // insert by perfectly forwarding _Val at _Where
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        const pointer _Oldlast  = _My_data._Mylast;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _My_data._Myfirst &amp;&amp; _Oldlast &gt;= _Whereptr,
            "vector emplace iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Oldlast != _My_data._Myend) {
            if (_Whereptr == _Oldlast) { // at back, provide strong guarantee
                _Emplace_back_with_unused_capacity(_STD forward&lt;_Valty&gt;(_Val)...);
            } else {
                auto&amp; _Al = _Getal();
                _Alloc_temporary&lt;_Alty&gt; _Obj(_Al, _STD forward&lt;_Valty&gt;(_Val)...); // handle aliasing
                // after constructing _Obj, provide basic guarantee
                _Orphan_range(_Whereptr, _Oldlast);
                _Alty_traits::construct(_Al, _Unfancy(_Oldlast), _STD move(_Oldlast[-1]));
                ++_My_data._Mylast;
                _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                *_Whereptr = _STD move(_Obj._Storage._Value);
            }

            return _Make_iterator(_Whereptr);
        }

        return _Make_iterator(_Emplace_reallocate(_Whereptr, _STD forward&lt;_Valty&gt;(_Val)...));
    }

    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const _Ty&amp; _Val) { // insert _Val at _Where
        return emplace(_Where, _Val);
    }

    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Ty&amp;&amp; _Val) { // insert by moving _Val at _Where
        return emplace(_Where, _STD move(_Val));
    }

    _CONSTEXPR20_CONTAINER iterator insert(
        const_iterator _Where, _CRT_GUARDOVERFLOW const size_type _Count, const _Ty&amp; _Val) {
        // insert _Count * _Val at _Where
        const pointer _Whereptr = _Where._Ptr;

        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;

        const pointer _Oldfirst = _My_data._Myfirst;
        const pointer _Oldlast  = _Mylast;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _Oldfirst &amp;&amp; _Oldlast &gt;= _Whereptr,
            "vector insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        const auto _Whereoff        = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);
        const auto _Unused_capacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Oldlast);
        const bool _One_at_back     = _Count == 1 &amp;&amp; _Whereptr == _Oldlast;
        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count &gt; _Unused_capacity) { // reallocate
            const auto _Oldsize = static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst);

            if (_Count &gt; max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            _TRY_BEGIN
            _Ufill(_Newvec + _Whereoff, _Count, _Val);
            _Constructed_first = _Newvec + _Whereoff;

            if (_One_at_back) { // provide strong guarantee
                _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
            } else { // provide basic guarantee
                _Umove(_Oldfirst, _Whereptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
            }
            _CATCH_ALL
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            _RERAISE;
            _CATCH_END

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else if (_One_at_back) { // provide strong guarantee
            _Emplace_back_with_unused_capacity(_Val);
        } else { // provide basic guarantee
            const _Alloc_temporary&lt;_Alty&gt; _Tmp_storage(_Getal(), _Val); // handle aliasing
            const auto&amp; _Tmp              = _Tmp_storage._Storage._Value;
            const auto _Affected_elements = static_cast&lt;size_type&gt;(_Oldlast - _Whereptr);
            _Orphan_range(_Whereptr, _Oldlast);

            if (_Count &gt; _Affected_elements) { // new stuff spills off end
                _Mylast = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
                _Mylast = _Umove(_Whereptr, _Oldlast, _Mylast);
                _STD fill(_Whereptr, _Oldlast, _Tmp);
            } else { // new stuff can all be assigned
                _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _STD fill(_Whereptr, _Whereptr + _Count, _Tmp);
            }
        }

        return _Make_iterator_offset(_Whereoff);
    }

private:
    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
        // insert input range [_First, _Last) at _Where
        if (_First == _Last) {
            return; // nothing to do, avoid invalidating iterators
        }

        auto&amp; _My_data       = _Mypair._Myval2;
        pointer&amp; _Myfirst    = _My_data._Myfirst;
        pointer&amp; _Mylast     = _My_data._Mylast;
        const auto _Whereoff = static_cast&lt;size_type&gt;(_Where._Ptr - _Myfirst);
        const auto _Oldsize  = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);

        // For one-at-back, provide strong guarantee.
        // Otherwise, provide basic guarantee (despite N4659 26.3.11.5 [vector.modifiers]/1).
        // Performance note: except for one-at-back, emplace_back()'s strong guarantee is unnecessary here.

        for (; _First != _Last; ++_First) {
            emplace_back(*_First);
        }

        _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

        _STD rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
        // insert forward range [_First, _Last) at _Where
        const pointer _Whereptr = _Where._Ptr;
        const auto _Count       = _Convert_size&lt;size_type&gt;(static_cast&lt;size_t&gt;(_STD distance(_First, _Last)));

        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;

        const pointer _Oldfirst     = _My_data._Myfirst;
        const pointer _Oldlast      = _Mylast;
        const auto _Unused_capacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Oldlast);

        if (_Count == 0) { // nothing to do, avoid invalidating iterators
        } else if (_Count &gt; _Unused_capacity) { // reallocate
            const auto _Oldsize = static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst);

            if (_Count &gt; max_size() - _Oldsize) {
                _Xlength();
            }

            const size_type _Newsize     = _Oldsize + _Count;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec           = _Getal().allocate(_Newcapacity);
            const auto _Whereoff            = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);
            const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
            pointer _Constructed_first      = _Constructed_last;

            _TRY_BEGIN
            _Ucopy(_First, _Last, _Newvec + _Whereoff);
            _Constructed_first = _Newvec + _Whereoff;

            if (_Count == 1 &amp;&amp; _Whereptr == _Oldlast) { // one at back, provide strong guarantee
                _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
            } else { // provide basic guarantee
                _Umove(_Oldfirst, _Whereptr, _Newvec);
                _Constructed_first = _Newvec;
                _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
            }
            _CATCH_ALL
            _Destroy(_Constructed_first, _Constructed_last);
            _Getal().deallocate(_Newvec, _Newcapacity);
            _RERAISE;
            _CATCH_END

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        } else { // Attempt to provide the strong guarantee for EmplaceConstructible failure.
                 // If we encounter copy/move construction/assignment failure, provide the basic guarantee.
                 // (For one-at-back, this provides the strong guarantee.)

            const auto _Affected_elements = static_cast&lt;size_type&gt;(_Oldlast - _Whereptr);

            if (_Count &lt; _Affected_elements) { // some affected elements must be assigned
                _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                _Destroy(_Whereptr, _Whereptr + _Count);

                _TRY_BEGIN
                _Ucopy(_First, _Last, _Whereptr);
                _CATCH_ALL
                // glue the broken pieces back together

                _TRY_BEGIN
                _Umove(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr);
                _CATCH_ALL
                // vaporize the detached piece
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy(_Whereptr + _Count, _Mylast);
                _Mylast = _Whereptr;
                _RERAISE;
                _CATCH_END

                _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                _Destroy(_Oldlast, _Mylast);
                _Mylast = _Oldlast;
                _RERAISE;
                _CATCH_END
            } else { // affected elements don't overlap before/after
                const pointer _Relocated = _Whereptr + _Count;
                _Mylast                  = _Umove(_Whereptr, _Oldlast, _Relocated);
                _Destroy(_Whereptr, _Oldlast);

                _TRY_BEGIN
                _Ucopy(_First, _Last, _Whereptr);
                _CATCH_ALL
                // glue the broken pieces back together

                _TRY_BEGIN
                _Umove(_Relocated, _Mylast, _Whereptr);
                _CATCH_ALL
                // vaporize the detached piece
                _Orphan_range(_Whereptr, _Oldlast);
                _Destroy(_Relocated, _Mylast);
                _Mylast = _Whereptr;
                _RERAISE;
                _CATCH_END

                _Destroy(_Relocated, _Mylast);
                _Mylast = _Oldlast;
                _RERAISE;
                _CATCH_END
            }

            _Orphan_range(_Whereptr, _Oldlast);
        }
    }

public:
    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        const pointer _Oldfirst = _My_data._Myfirst;
#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _Oldfirst &amp;&amp; _My_data._Mylast &gt;= _Whereptr,
            "vector insert iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Adl_verify_range(_First, _Last);
        const auto _Whereoff = static_cast&lt;size_type&gt;(_Whereptr - _Oldfirst);
        _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t&lt;_Iter&gt;{});
        return _Make_iterator_offset(_Whereoff);
    }

    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, initializer_list&lt;_Ty&gt; _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20_CONTAINER void assign(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty&amp; _Val) {
        // assign _Newsize * _Val
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        if (_Newsize &gt; _Oldsize) {
            const auto _Oldcapacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Myfirst);
            if (_Newsize &gt; _Oldcapacity) { // reallocate
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            } else {
                _STD fill(_Myfirst, _Mylast, _Val);
            }

            _Mylast = _Ufill(_Mylast, _Newsize - _Oldsize, _Val);
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _STD fill(_Myfirst, _Newlast, _Val);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
        }
    }

private:
    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag) {
        // assign input range [_First, _Last)
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();

        pointer _Next = _Myfirst;

        for (; _First != _Last &amp;&amp; _Next != _Mylast; ++_First, (void) ++_Next) {
            *_Next = *_First;
        }

        // Code size optimization: we've exhausted only the source, only the dest, or both.
        // If we've exhausted only the source: we Trim, then Append does nothing.
        // If we've exhausted only the dest: Trim does nothing, then we Append.
        // If we've exhausted both: Trim does nothing, then Append does nothing.

        // Trim.
        _Destroy(_Next, _Mylast);
        _Mylast = _Next;

        // Append.
        for (; _First != _Last; ++_First) {
            emplace_back(*_First); // performance note: emplace_back()'s strong guarantee is unnecessary here
        }
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag) {
        // assign forward range [_First, _Last)
        const auto _Newsize = _Convert_size&lt;size_type&gt;(static_cast&lt;size_t&gt;(_STD distance(_First, _Last)));
        auto&amp; _My_data      = _Mypair._Myval2;
        pointer&amp; _Myfirst   = _My_data._Myfirst;
        pointer&amp; _Mylast    = _My_data._Mylast;
        pointer&amp; _Myend     = _My_data._Myend;

        _My_data._Orphan_all();

        if constexpr (conjunction_v&lt;bool_constant&lt;_Ptr_copy_cat&lt;_Iter, _Ty*&gt;::_Trivially_copyable&gt;,
                          _Uses_default_construct&lt;_Alty, _Ty*, decltype(*_First)&gt;,
                          _Uses_default_destroy&lt;_Alty, _Ty*&gt;&gt;) {
#ifdef __cpp_lib_constexpr_dynamic_alloc
            if (!_STD is_constant_evaluated())
#endif // __cpp_lib_constexpr_dynamic_alloc
            {
                const auto _Oldcapacity = static_cast&lt;size_type&gt;(_Myend - _Myfirst);
                if (_Newsize &gt; _Oldcapacity) {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy&lt;pointer&gt;(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));
                return;
            }
        }
        auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);

        if (_Newsize &gt; _Oldsize) {
            const auto _Oldcapacity = static_cast&lt;size_type&gt;(_Myend - _Myfirst);
            if (_Newsize &gt; _Oldcapacity) { // reallocate
                _Clear_and_reserve_geometric(_Newsize);
                _Oldsize = 0;
            }

            // performance note: traversing [_First, _Mid) twice
            const _Iter _Mid = _STD next(_First, static_cast&lt;difference_type&gt;(_Oldsize));
            _Copy_unchecked(_First, _Mid, _Myfirst);
            _Mylast = _Ucopy(_Mid, _Last, _Mylast);
        } else {
            const pointer _Newlast = _Myfirst + _Newsize;
            _Copy_unchecked(_First, _Last, _Myfirst);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
        }
    }

public:
    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {
        _Adl_verify_range(_First, _Last);
        _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t&lt;_Iter&gt;{});
    }

    _CONSTEXPR20_CONTAINER void assign(initializer_list&lt;_Ty&gt; _Ilist) {
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
    }

private:
    _CONSTEXPR20_CONTAINER void _Copy_assign(const vector&amp; _Right, false_type) {
        _Pocca(_Getal(), _Right._Getal());
        auto&amp; _Right_data = _Right._Mypair._Myval2;
        assign(_Right_data._Myfirst, _Right_data._Mylast);
    }

    _CONSTEXPR20_CONTAINER void _Copy_assign(const vector&amp; _Right, true_type) {
        if (_Getal() != _Right._Getal()) {
            _Tidy();
            _Mypair._Myval2._Reload_proxy(
                _GET_PROXY_ALLOCATOR(_Alty, _Getal()), _GET_PROXY_ALLOCATOR(_Alty, _Right._Getal()));
        }

        _Copy_assign(_Right, false_type{});
    }

public:
    _CONSTEXPR20_CONTAINER vector&amp; operator=(const vector&amp; _Right) {
        if (this != _STD addressof(_Right)) {
            _Copy_assign(_Right, _Choose_pocca&lt;_Alty&gt;{});
        }

        return *this;
    }

    _CONSTEXPR20_CONTAINER vector&amp; operator=(initializer_list&lt;_Ty&gt; _Ilist) {
        _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        return *this;
    }

private:
    template &lt;class _Ty2&gt;
    _CONSTEXPR20_CONTAINER void _Resize_reallocate(const size_type _Newsize, const _Ty2&amp; _Val) {
        if (_Newsize &gt; max_size()) {
            _Xlength();
        }

        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        const auto _Oldsize          = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        const pointer _Newvec         = _Getal().allocate(_Newcapacity);
        const pointer _Appended_first = _Newvec + _Oldsize;
        pointer _Appended_last        = _Appended_first;

        _TRY_BEGIN
        _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
        _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
        _CATCH_ALL
        _Destroy(_Appended_first, _Appended_last);
        _Getal().deallocate(_Newvec, _Newcapacity);
        _RERAISE;
        _CATCH_END

        _Change_array(_Newvec, _Newsize, _Newcapacity);
    }

    template &lt;class _Ty2&gt;
    _CONSTEXPR20_CONTAINER void _Resize(const size_type _Newsize, const _Ty2&amp; _Val) {
        // trim or append elements, provide strong guarantee
        auto&amp; _My_data      = _Mypair._Myval2;
        pointer&amp; _Myfirst   = _My_data._Myfirst;
        pointer&amp; _Mylast    = _My_data._Mylast;
        const auto _Oldsize = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);
        if (_Newsize &lt; _Oldsize) { // trim
            const pointer _Newlast = _Myfirst + _Newsize;
            _Orphan_range(_Newlast, _Mylast);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
            return;
        }

        if (_Newsize &gt; _Oldsize) { // append
            const auto _Oldcapacity = static_cast&lt;size_type&gt;(_My_data._Myend - _Myfirst);
            if (_Newsize &gt; _Oldcapacity) { // reallocate
                _Resize_reallocate(_Newsize, _Val);
                return;
            }

            const pointer _Oldlast = _Mylast;
            _Mylast                = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
            _Orphan_range(_Oldlast, _Oldlast);
        }

        // if _Newsize == _Oldsize, do nothing; avoid invalidating iterators
    }

public:
    _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize) {
        // trim or append value-initialized elements, provide strong guarantee
        _Resize(_Newsize, _Value_init_tag{});
    }

    _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW const size_type _Newsize, const _Ty&amp; _Val) {
        // trim or append copies of _Val, provide strong guarantee
        _Resize(_Newsize, _Val);
    }

private:
    _CONSTEXPR20_CONTAINER void _Reallocate_exactly(const size_type _Newcapacity) {
        // set capacity to _Newcapacity (without geometric growth), provide strong guarantee
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        const auto _Size = static_cast&lt;size_type&gt;(_Mylast - _Myfirst);

        const pointer _Newvec = _Getal().allocate(_Newcapacity);

        _TRY_BEGIN
        _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
        _CATCH_ALL
        _Getal().deallocate(_Newvec, _Newcapacity);
        _RERAISE;
        _CATCH_END

        _Change_array(_Newvec, _Size, _Newcapacity);
    }

#if _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)
    void _Check_all_orphaned_locked() const noexcept {
        _Lockit _Lock(_LOCK_DEBUG);
        auto&amp; _My_data = _Mypair._Myval2;
        _STL_INTERNAL_CHECK(!_My_data._Myproxy-&gt;_Myfirstiter);
    }

    _CONSTEXPR20_CONTAINER void _Check_all_orphaned() const noexcept {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            auto&amp; _My_data = _Mypair._Myval2;
            _STL_INTERNAL_CHECK(!_My_data._Myproxy-&gt;_Myfirstiter);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            _Check_all_orphaned_locked();
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)

    _CONSTEXPR20_CONTAINER void _Clear_and_reserve_geometric(const size_type _Newsize) {
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;

#if _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)
        _STL_INTERNAL_CHECK(_Newsize != 0);
        _Check_all_orphaned();
#endif // _ITERATOR_DEBUG_LEVEL != 0 &amp;&amp; defined(_ENABLE_STL_INTERNAL_CHECK)

        if (_Newsize &gt; max_size()) {
            _Xlength();
        }

        const size_type _Newcapacity = _Calculate_growth(_Newsize);

        if (_Myfirst) { // destroy and deallocate old array
            _Destroy(_Myfirst, _Mylast);
            _Getal().deallocate(_Myfirst, static_cast&lt;size_type&gt;(_Myend - _Myfirst));

            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;
        }

        _Buy_raw(_Newcapacity);
    }

public:
    _CONSTEXPR20_CONTAINER void reserve(_CRT_GUARDOVERFLOW const size_type _Newcapacity) {
        // increase capacity to _Newcapacity (without geometric growth), provide strong guarantee
        if (_Newcapacity &gt; capacity()) { // something to do (reserve() never shrinks)
            if (_Newcapacity &gt; max_size()) {
                _Xlength();
            }

            _Reallocate_exactly(_Newcapacity);
        }
    }

    _CONSTEXPR20_CONTAINER void shrink_to_fit() { // reduce capacity to size, provide strong guarantee
        auto&amp; _My_data         = _Mypair._Myval2;
        const pointer _Oldlast = _My_data._Mylast;
        if (_Oldlast != _My_data._Myend) { // something to do
            const pointer _Oldfirst = _My_data._Myfirst;
            if (_Oldfirst == _Oldlast) {
                _Tidy();
            } else {
                _Reallocate_exactly(static_cast&lt;size_type&gt;(_Oldlast - _Oldfirst));
            }
        }
    }

    _CONSTEXPR20_CONTAINER void pop_back() noexcept /* strengthened */ {
        auto&amp; _My_data   = _Mypair._Myval2;
        pointer&amp; _Mylast = _My_data._Mylast;

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_My_data._Myfirst != _Mylast, "vector empty before pop");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Orphan_range(_Mylast - 1, _Mylast);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        --_Mylast;
    }

    _CONSTEXPR20_CONTAINER iterator erase(const_iterator _Where) noexcept(
        is_nothrow_move_assignable_v&lt;value_type&gt;) /* strengthened */ {
        const pointer _Whereptr = _Where._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        pointer&amp; _Mylast        = _My_data._Mylast;

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(
            _Where._Getcont() == _STD addressof(_My_data) &amp;&amp; _Whereptr &gt;= _My_data._Myfirst &amp;&amp; _Mylast &gt; _Whereptr,
            "vector erase iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Orphan_range(_Whereptr, _Mylast);
        _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
        _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
        --_Mylast;
        return iterator(_Whereptr, _STD addressof(_My_data));
    }

    _CONSTEXPR20_CONTAINER iterator erase(const_iterator _First, const_iterator _Last) noexcept(
        is_nothrow_move_assignable_v&lt;value_type&gt;) /* strengthened */ {
        const pointer _Firstptr = _First._Ptr;
        const pointer _Lastptr  = _Last._Ptr;
        auto&amp; _My_data          = _Mypair._Myval2;
        pointer&amp; _Mylast        = _My_data._Mylast;

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(_First._Getcont() == _STD addressof(_My_data) &amp;&amp; _Last._Getcont() == _STD addressof(_My_data)
                        &amp;&amp; _Firstptr &gt;= _My_data._Myfirst &amp;&amp; _Lastptr &gt;= _Firstptr &amp;&amp; _Mylast &gt;= _Lastptr,
            "vector erase iterator outside range");
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Firstptr != _Lastptr) { // something to do, invalidate iterators
            _Orphan_range(_Firstptr, _Mylast);

            const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
            _Destroy(_Newlast, _Mylast);
            _Mylast = _Newlast;
        }

        return iterator(_Firstptr, _STD addressof(_My_data));
    }

    _CONSTEXPR20_CONTAINER void clear() noexcept { // erase all
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;

        _My_data._Orphan_all();
        _Destroy(_Myfirst, _Mylast);
        _Mylast = _Myfirst;
    }

    _CONSTEXPR20_CONTAINER void swap(vector&amp; _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            _Pocs(_Getal(), _Right._Getal());
            _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
        }
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Ty* data() noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const _Ty* data() const noexcept {
        return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
    }

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst, _STD addressof(_My_data));
    }</span>

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator begin() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Myfirst, _STD addressof(_My_data));
    }

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER iterator end() noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return iterator(_My_data._Mylast, _STD addressof(_My_data));
    }</span>

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator end() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return const_iterator(_My_data._Mylast, _STD addressof(_My_data));
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator crend() const noexcept {
        return rend();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_begin() noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_pointer _Unchecked_begin() const noexcept {
        return _Mypair._Myval2._Myfirst;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER pointer _Unchecked_end() noexcept {
        return _Mypair._Myval2._Mylast;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_pointer _Unchecked_end() const noexcept {
        return _Mypair._Myval2._Mylast;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER bool empty() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return _My_data._Myfirst == _My_data._Mylast;
    }

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst);
    }</span>

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {
        return (_STD min)(</span>
            static_cast&lt;size_type&gt;((numeric_limits&lt;difference_type&gt;::max)()), _Alty_traits::max_size(_Getal()));
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER size_type capacity() const noexcept {
        auto&amp; _My_data = _Mypair._Myval2;
        return static_cast&lt;size_type&gt;(_My_data._Myend - _My_data._Myfirst);
    }</span>

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER _Ty&amp; operator[](const size_type _Pos) noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;</span>
#if _CONTAINER_DEBUG_LEVEL &gt; 0
<span style = "background-color:#dfd">        _STL_VERIFY(</span>
            _Pos &lt; static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

<span style = "background-color:#dfd">        return _My_data._Myfirst[_Pos];
    }</span>

    _NODISCARD _CONSTEXPR20_CONTAINER const _Ty&amp; operator[](const size_type _Pos) const noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(
            _Pos &lt; static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst), "vector subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return _My_data._Myfirst[_Pos];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Ty&amp; at(const size_type _Pos) {
        auto&amp; _My_data = _Mypair._Myval2;
        if (static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst) &lt;= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const _Ty&amp; at(const size_type _Pos) const {
        auto&amp; _My_data = _Mypair._Myval2;
        if (static_cast&lt;size_type&gt;(_My_data._Mylast - _My_data._Myfirst) &lt;= _Pos) {
            _Xrange();
        }

        return _My_data._Myfirst[_Pos];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Ty&amp; front() noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return *_My_data._Myfirst;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const _Ty&amp; front() const noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "front() called on empty vector");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return *_My_data._Myfirst;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Ty&amp; back() noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return _My_data._Mylast[-1];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const _Ty&amp; back() const noexcept /* strengthened */ {
        auto&amp; _My_data = _Mypair._Myval2;
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(_My_data._Myfirst != _My_data._Mylast, "back() called on empty vector");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return _My_data._Mylast[-1];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER allocator_type get_allocator() const noexcept {
        return static_cast&lt;allocator_type&gt;(_Getal());
    }

private:
    _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty&amp; _Val) {
        // fill raw _Dest with _Count copies of _Val, using allocator
        return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());
    }

    _CONSTEXPR20_CONTAINER pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag) {
        // fill raw _Dest with _Count value-initialized objects, using allocator
        return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());
    }

    template &lt;class _Iter&gt;
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest) {</span>
        // copy [_First, _Last) to raw _Dest, using allocator
<span style = "background-color:#dfd">        return _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }</span>

<span style = "background-color:#fdd">    _CONSTEXPR20_CONTAINER pointer _Umove(pointer _First, pointer _Last, pointer _Dest) {</span>
        // move [_First, _Last) to raw _Dest, using allocator
<span style = "background-color:#fdd">        return _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type) {</span>
        // move [_First, _Last) to raw _Dest, using allocator
<span style = "background-color:#dfd">        _Uninitialized_move(_First, _Last, _Dest, _Getal());
    }</span>

    _CONSTEXPR20_CONTAINER void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, false_type) {
        // copy [_First, _Last) to raw _Dest, using allocator
        _Uninitialized_copy(_First, _Last, _Dest, _Getal());
    }

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest) {</span>
        // move_if_noexcept [_First, _Last) to raw _Dest, using allocator
<span style = "background-color:#dfd">        _Umove_if_noexcept1(_First, _Last, _Dest,</span>
            bool_constant&lt;disjunction_v&lt;is_nothrow_move_constructible&lt;_Ty&gt;, negation&lt;is_copy_constructible&lt;_Ty&gt;&gt;&gt;&gt;{});
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Destroy(pointer _First, pointer _Last) {</span>
        // destroy [_First, _Last) using allocator
<span style = "background-color:#dfd">        _Destroy_range(_First, _Last, _Getal());
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER size_type _Calculate_growth(const size_type _Newsize) const {</span>
        // given _Oldcapacity and _Newsize, calculate geometric growth
<span style = "background-color:#dfd">        const size_type _Oldcapacity = capacity();
        const auto _Max              = max_size();</span>

<span style = "background-color:#dfd">        if (_Oldcapacity &gt; _Max - _Oldcapacity / 2) {</span>
<span style = "background-color:#fdd">            return _Max; // geometric growth would overflow</span>
        }

<span style = "background-color:#dfd">        const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;</span>

<span style = "background-color:#dfd">        if (_Geometric &lt; _Newsize) {
            return _Newsize; // geometric growth would be insufficient</span>
        }

<span style = "background-color:#dfd">        return _Geometric; // geometric growth is sufficient
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Buy_raw(const size_type _Newcapacity) {</span>
        // allocate array with _Newcapacity elements
<span style = "background-color:#dfd">        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;</span>

        _STL_INTERNAL_CHECK(!_Myfirst &amp;&amp; !_Mylast &amp;&amp; !_Myend); // check that *this is tidy
        _STL_INTERNAL_CHECK(0 &lt; _Newcapacity &amp;&amp; _Newcapacity &lt;= max_size());

<span style = "background-color:#dfd">        const auto _Newvec = _Getal().allocate(_Newcapacity);
        _Myfirst           = _Newvec;
        _Mylast            = _Newvec;
        _Myend             = _Newvec + _Newcapacity;
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Buy_nonzero(const size_type _Newcapacity) {</span>
        // allocate array with _Newcapacity elements
#ifdef _ENABLE_STL_INTERNAL_CHECK
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;
        _STL_INTERNAL_CHECK(!_Myfirst &amp;&amp; !_Mylast &amp;&amp; !_Myend); // check that *this is tidy
        _STL_INTERNAL_CHECK(0 &lt; _Newcapacity);
#endif // _ENABLE_STL_INTERNAL_CHECK

<span style = "background-color:#dfd">        if (_Newcapacity &gt; max_size()) {</span>
<span style = "background-color:#fdd">            _Xlength();</span>
        }

<span style = "background-color:#dfd">        _Buy_raw(_Newcapacity);
    }</span>

    _CONSTEXPR20_CONTAINER void _Change_array(
<span style = "background-color:#dfd">        const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity) {</span>
        // orphan all iterators, discard old array, acquire new array
<span style = "background-color:#dfd">        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;</span>

<span style = "background-color:#dfd">        _My_data._Orphan_all();</span>

<span style = "background-color:#dfd">        if (_Myfirst) { // destroy and deallocate old array
            _Destroy(_Myfirst, _Mylast);
            _Getal().deallocate(_Myfirst, static_cast&lt;size_type&gt;(_Myend - _Myfirst));</span>
        }

<span style = "background-color:#dfd">        _Myfirst = _Newvec;
        _Mylast  = _Newvec + _Newsize;
        _Myend   = _Newvec + _Newcapacity;
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Tidy() noexcept { // free all storage
        auto&amp; _My_data    = _Mypair._Myval2;
        pointer&amp; _Myfirst = _My_data._Myfirst;
        pointer&amp; _Mylast  = _My_data._Mylast;
        pointer&amp; _Myend   = _My_data._Myend;</span>

<span style = "background-color:#dfd">        _My_data._Orphan_all();</span>

<span style = "background-color:#dfd">        if (_Myfirst) { // destroy and deallocate old array
            _Destroy(_Myfirst, _Mylast);
            _Getal().deallocate(_Myfirst, static_cast&lt;size_type&gt;(_Myend - _Myfirst));</span>

<span style = "background-color:#dfd">            _Myfirst = nullptr;
            _Mylast  = nullptr;
            _Myend   = nullptr;</span>
        }
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#fdd">    [[noreturn]] static void _Xlength() {
        _Xlength_error("vector too long");
    }</span>

    [[noreturn]] static void _Xrange() {
        _Xout_of_range("invalid vector subscript");
    }

#if _ITERATOR_DEBUG_LEVEL == 2
<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Orphan_range_unlocked(pointer _First, pointer _Last) const {
        _Iterator_base12** _Pnext = &amp;_Mypair._Myval2._Myproxy-&gt;_Myfirstiter;
        while (*_Pnext) {</span>
<span style = "background-color:#fdd">            const auto _Pnextptr = static_cast&lt;const_iterator&amp;&gt;(**_Pnext)._Ptr;
            if (_Pnextptr &lt; _First || _Last &lt; _Pnextptr) { // skip the iterator
                const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037
                _Pnext           = &amp;_Temp-&gt;_Mynextiter;
            } else { // orphan the iterator
                const auto _Temp = *_Pnext; // TRANSITION, VSO-1269037
                _Temp-&gt;_Myproxy  = nullptr;
                *_Pnext          = _Temp-&gt;_Mynextiter;</span>
            }
<span style = "background-color:#fdd">        }</span>
<span style = "background-color:#dfd">    }</span>

<span style = "background-color:#dfd">    void _Orphan_range_locked(pointer _First, pointer _Last) const {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_range_unlocked(_First, _Last);
    }</span>

<span style = "background-color:#dfd">    _CONSTEXPR20_CONTAINER void _Orphan_range(pointer _First, pointer _Last) const {</span>
        // orphan iterators within specified (inclusive) range
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            _Orphan_range_unlocked(_First, _Last);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
<span style = "background-color:#dfd">            _Orphan_range_locked(_First, _Last);</span>
        }
<span style = "background-color:#dfd">    }</span>
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 2 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 2 vvv
    _CONSTEXPR20_CONTAINER void _Orphan_range(pointer, pointer) const {}
#endif // _ITERATOR_DEBUG_LEVEL != 2

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER _Alty&amp; _Getal() noexcept {
        return _Mypair._Get_first();
    }</span>

<span style = "background-color:#dfd">    _NODISCARD _CONSTEXPR20_CONTAINER const _Alty&amp; _Getal() const noexcept {
        return _Mypair._Get_first();
    }</span>

    _NODISCARD _CONSTEXPR20_CONTAINER iterator _Make_iterator(const pointer _Ptr) noexcept {
        return iterator(_Ptr, _STD addressof(_Mypair._Myval2));
    }

    _NODISCARD _CONSTEXPR20_CONTAINER iterator _Make_iterator_offset(const size_type _Offset) noexcept {
        // return the iterator begin() + _Offset without a debugging check
        auto&amp; _My_data = _Mypair._Myval2;
        return iterator(_My_data._Myfirst + _Offset, _STD addressof(_My_data));
    }

    _Compressed_pair&lt;_Alty, _Scary_val&gt; _Mypair;
};

#if _HAS_CXX17
template &lt;class _Iter, class _Alloc = allocator&lt;_Iter_value_t&lt;_Iter&gt;&gt;,
    enable_if_t&lt;conjunction_v&lt;_Is_iterator&lt;_Iter&gt;, _Is_allocator&lt;_Alloc&gt;&gt;, int&gt; = 0&gt;
vector(_Iter, _Iter, _Alloc = _Alloc()) -&gt; vector&lt;_Iter_value_t&lt;_Iter&gt;, _Alloc&gt;;
#endif // _HAS_CXX17

template &lt;class _Alloc&gt;
class vector&lt;bool, _Alloc&gt;;

using _Vbase         = unsigned int; // word type for vector&lt;bool&gt; representation
constexpr int _VBITS = 8 * sizeof(_Vbase); // at least CHAR_BITS bits per word

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20_CONTAINER bool operator==(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    if (_Left.size() != _Right.size()) {
        return false;
    }

    if constexpr (is_same_v&lt;_Ty, bool&gt;) {
        return _STD equal(
            _Left._Myvec._Unchecked_begin(), _Left._Myvec._Unchecked_end(), _Right._Myvec._Unchecked_begin());
    } else {
        return _STD equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }
}

#if !_HAS_CXX20
template &lt;class _Ty, class _Alloc&gt;
_NODISCARD bool operator!=(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return !(_Left == _Right);
}
#endif // !_HAS_CXX20

// Optimize vector&lt;bool&gt; lexicographical comparisons.

// There are several endianness/ordering issues to consider here.
// * Machine endianness is irrelevant. (That affects how an unsigned int is stored
//   as a sequence of bytes. While all of our supported architectures are little-endian,
//   that's irrelevant as long as we avoid reinterpreting unsigned int as a sequence of bytes.)
// * Appending bits to vector&lt;bool&gt; eventually appends words to its underlying storage.
//   For example, vb[10] is stored within vb._Myvec[0], while vb[100] is stored within vb._Myvec[3].
//   This allows us to translate lexicographical comparisons from theoretical bits to physical words.
// * Unsigned integers are written and compared as big-endian (most significant bit first).
//   For example, 0x10u &gt; 0x07u.
// * However, vector&lt;bool&gt; packs bits into words as little-endian (least significant bit first).
//   For example, vector&lt;bool&gt;{false, true, true, true} stores 0b0000'0000'0000'0000'0000'0000'0000'1110u.
// We could bit-reverse words before comparing, but we just need to find the least significant bit that differs.

template &lt;class _Ret&gt;
struct _Vbase_compare_three_way {
    _NODISCARD constexpr _Ret operator()(const _Vbase _Left, const _Vbase _Right) const noexcept {
        const _Vbase _Differing_bits = _Left ^ _Right;

        if (_Differing_bits == 0) { // improves _Countr_zero codegen below
#ifdef __cpp_lib_concepts
            return strong_ordering::equal;
#else // ^^^ defined(__cpp_lib_concepts) / !defined(__cpp_lib_concepts) vvv
            return 0;
#endif // ^^^ !defined(__cpp_lib_concepts) ^^^
        }

        const int _Bit_index = _Countr_zero(_Differing_bits); // number of least significant bits that match
        _STL_INTERNAL_CHECK(_Bit_index &lt; _VBITS); // because we return early for equality

        const _Vbase _Mask = _Vbase{1} &lt;&lt; _Bit_index; // selects the least significant bit that differs

        // Instead of comparing (_Left &amp; _Mask) to (_Right &amp; _Mask), we know that exactly one side will be zero.
#ifdef __cpp_lib_concepts
        return (_Left &amp; _Mask) == 0 ? strong_ordering::less : strong_ordering::greater;
#else // ^^^ defined(__cpp_lib_concepts) / !defined(__cpp_lib_concepts) vvv
        return (_Left &amp; _Mask) == 0 ? -1 : 1;
#endif // ^^^ !defined(__cpp_lib_concepts) ^^^
    }
};

#ifdef __cpp_lib_concepts
template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20_CONTAINER _Synth_three_way_result&lt;_Ty&gt; operator&lt;=&gt;(
    const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    if constexpr (is_same_v&lt;_Ty, bool&gt;) {
        // This optimization works because vector&lt;bool&gt; "trims" its underlying storage by zeroing out unused bits.
        const auto _Min_word_size = (_STD min)(_Left._Myvec.size(), _Right._Myvec.size());
        const auto _Left_words    = _Left._Myvec._Unchecked_begin();
        const auto _Right_words   = _Right._Myvec._Unchecked_begin();

        using _Comp = _Vbase_compare_three_way&lt;strong_ordering&gt;;

        const strong_ordering _Word_comparison = _STD lexicographical_compare_three_way(
            _Left_words, _Left_words + _Min_word_size, _Right_words, _Right_words + _Min_word_size, _Comp{});

        if (_Word_comparison != 0) {
            return _Word_comparison;
        }

        return _Left.size() &lt;=&gt; _Right.size();
    } else {
        return _STD lexicographical_compare_three_way(_Left._Unchecked_begin(), _Left._Unchecked_end(),
            _Right._Unchecked_begin(), _Right._Unchecked_end(), _Synth_three_way{});
    }
}
#else // ^^^ defined(__cpp_lib_concepts) / !defined(__cpp_lib_concepts) vvv
template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20_CONTAINER bool operator&lt;(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    if constexpr (is_same_v&lt;_Ty, bool&gt;) {
        // This optimization works because vector&lt;bool&gt; "trims" its underlying storage by zeroing out unused bits.
        auto _First = _Left._Myvec._Unchecked_begin();
        auto _Other = _Right._Myvec._Unchecked_begin();

        const auto _Last = _First + (_STD min)(_Left._Myvec.size(), _Right._Myvec.size());

        for (; _First != _Last; ++_First, (void) ++_Other) {
            using _Comp = _Vbase_compare_three_way&lt;signed char&gt;;
            const auto _Result = _Comp{}(*_First, *_Other);

            if (_Result &lt; 0) {
                return true;
            } else if (_Result &gt; 0) {
                return false;
            }
        }

        return _Left.size() &lt; _Right.size();
    } else {
        return _STD lexicographical_compare(
            _Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin(), _Right._Unchecked_end());
    }
}

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20_CONTAINER bool operator&gt;(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return _Right &lt; _Left;
}

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20_CONTAINER bool operator&lt;=(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return !(_Right &lt; _Left);
}

template &lt;class _Ty, class _Alloc&gt;
_NODISCARD _CONSTEXPR20_CONTAINER bool operator&gt;=(const vector&lt;_Ty, _Alloc&gt;&amp; _Left, const vector&lt;_Ty, _Alloc&gt;&amp; _Right) {
    return !(_Left &lt; _Right);
}
#endif // ^^^ !defined(__cpp_lib_concepts) ^^^

template &lt;class _Ty, class _Alloc&gt;
_CONSTEXPR20_CONTAINER void swap(vector&lt;_Ty, _Alloc&gt;&amp; _Left, vector&lt;_Ty, _Alloc&gt;&amp; _Right) noexcept /* strengthened */ {
    _Left.swap(_Right);
}

#if _HAS_CXX20
template &lt;class _Ty, class _Alloc, class _Uty&gt;
_CONSTEXPR20_CONTAINER typename vector&lt;_Ty, _Alloc&gt;::size_type erase(vector&lt;_Ty, _Alloc&gt;&amp; _Cont, const _Uty&amp; _Val) {
    return _Erase_remove(_Cont, _Val);
}

template &lt;class _Ty, class _Alloc, class _Pr&gt;
_CONSTEXPR20_CONTAINER typename vector&lt;_Ty, _Alloc&gt;::size_type erase_if(vector&lt;_Ty, _Alloc&gt;&amp; _Cont, _Pr _Pred) {
    return _Erase_remove_if(_Cont, _Pass_fn(_Pred));
}
#endif // _HAS_CXX20

// CLASS TEMPLATE vector&lt;bool, Alloc&gt; AND FRIENDS
template &lt;class _Alloc0&gt;
struct _Wrap_alloc { // TRANSITION, ABI compat, preserves symbol names of vector&lt;bool&gt;::iterator
    using _Alloc = _Alloc0;
};

// CLASS _Vb_iter_base
template &lt;class _Alvbase_wrapped&gt;
class _Vb_iter_base : public _Iterator_base {
    // store information common to reference and iterators
public:
    using _Alvbase         = typename _Alvbase_wrapped::_Alloc;
    using _Size_type       = typename allocator_traits&lt;_Alvbase&gt;::size_type;
    using _Difference_type = typename allocator_traits&lt;_Alvbase&gt;::difference_type;
    using _Mycont          = vector&lt;bool, _Rebind_alloc_t&lt;_Alvbase, bool&gt;&gt;;

    _CONSTEXPR20_CONTAINER _Vb_iter_base() = default;

    _CONSTEXPR20_CONTAINER _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off) {
        this-&gt;_Adopt(_Mypvbool);
    }

    // TRANSITION, DevCom-1331017
    _CONSTEXPR20_CONTAINER _Vb_iter_base&amp; operator=(const _Vb_iter_base&amp;) noexcept = default;

    _CONSTEXPR20_CONTAINER void _Advance(_Size_type _Off) noexcept {
        _Myoff += _Off;
        _Myptr += _Myoff / _VBITS;
        _Myoff %= _VBITS;
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    _CONSTEXPR20_CONTAINER _Difference_type _Total_off(const _Mycont* _Cont) const noexcept {
        return static_cast&lt;_Difference_type&gt;(_VBITS * (_Myptr - _Cont-&gt;_Myvec.data()) + _Myoff);
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    const _Vbase* _Myptr = nullptr;
    _Size_type _Myoff    = 0;
};

// CLASS _Vb_reference
template &lt;class _Alvbase_wrapped&gt;
class _Vb_reference : public _Vb_iter_base&lt;_Alvbase_wrapped&gt; {
    // reference to a bit within a base word
    using _Mybase          = _Vb_iter_base&lt;_Alvbase_wrapped&gt;;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    // TRANSITION, ABI: non-trivial constructor
    _CONSTEXPR20_CONTAINER _Vb_reference() = default;

public:
    _CONSTEXPR20_CONTAINER _Vb_reference(const _Vb_reference&amp;) = default;

    _CONSTEXPR20_CONTAINER _Vb_reference(const _Mybase&amp; _Right) noexcept
        : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont()) {}

    _CONSTEXPR20_CONTAINER _Vb_reference&amp; operator=(const _Vb_reference&amp; _Right) noexcept {
        return *this = static_cast&lt;bool&gt;(_Right);
    }

    _CONSTEXPR20_CONTAINER _Vb_reference&amp; operator=(bool _Val) noexcept {
        if (_Val) {
            *const_cast&lt;_Vbase*&gt;(_Getptr()) |= _Mask();
        } else {
            *const_cast&lt;_Vbase*&gt;(_Getptr()) &amp;= ~_Mask();
        }

        return *this;
    }

    _CONSTEXPR20_CONTAINER void flip() noexcept {
        *const_cast&lt;_Vbase*&gt;(_Getptr()) ^= _Mask();
    }

    _CONSTEXPR20_CONTAINER operator bool() const noexcept {
        return (*_Getptr() &amp; _Mask()) != 0;
    }

    _CONSTEXPR20_CONTAINER const _Vbase* _Getptr() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot dereference value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt;= static_cast&lt;_Difference_type&gt;(_Cont-&gt;_Mysize),
            "vector&lt;bool&gt; iterator not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return this-&gt;_Myptr;
    }

    friend _CONSTEXPR20_CONTAINER void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept {
        bool _Val = _Left; // NOT _STD swap
        _Left     = _Right;
        _Right    = _Val;
    }

protected:
    _CONSTEXPR20_CONTAINER _Vbase _Mask() const noexcept {
        return static_cast&lt;_Vbase&gt;(1) &lt;&lt; this-&gt;_Myoff;
    }
};

// CLASS _Vb_const_iterator
template &lt;class _Alvbase_wrapped&gt;
class _Vb_const_iterator : public _Vb_iter_base&lt;_Alvbase_wrapped&gt; {
private:
    using _Mybase = _Vb_iter_base&lt;_Alvbase_wrapped&gt;;

public:
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;
    using _Size_type       = typename _Mybase::_Size_type;
    using _Reft            = _Vb_reference&lt;_Alvbase_wrapped&gt;;
    using const_reference  = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::_Difference_type;
    using pointer           = const_reference*;
    using reference         = const_reference;

    _CONSTEXPR20_CONTAINER _Vb_const_iterator() = default;

    _CONSTEXPR20_CONTAINER _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept
        : _Mybase(_Ptr, 0, _Mypvbool) {}

    // TRANSITION, DevCom-1331017
    _CONSTEXPR20_CONTAINER _Vb_const_iterator&amp; operator=(const _Vb_const_iterator&amp;) noexcept = default;

    _NODISCARD _CONSTEXPR20_CONTAINER const_reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot dereference value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt; static_cast&lt;_Difference_type&gt;(_Cont-&gt;_Mysize),
            "vector&lt;bool&gt; iterator not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Reft(*this);
    }

    _CONSTEXPR20_CONTAINER _Vb_const_iterator&amp; operator++() noexcept {
        _Inc();
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vb_const_iterator operator++(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Inc();
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vb_const_iterator&amp; operator--() noexcept {
        _Dec();
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vb_const_iterator operator--(int) noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Dec();
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vb_const_iterator&amp; operator+=(const difference_type _Off) noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        if (_Off != 0) {
            const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
            _STL_VERIFY(_Cont, "cannot seek value-initialized vector&lt;bool&gt; iterator");
            const auto _Start_offset = this-&gt;_Total_off(_Cont);
            if (_Off &lt; 0) {
                _STL_VERIFY(-_Start_offset &lt;= _Off, "cannot seek vector&lt;bool&gt; iterator before begin");
            } else if (0 &lt; _Off) {
                _STL_VERIFY(_Off &lt;= static_cast&lt;_Difference_type&gt;(_Cont-&gt;_Mysize - _Start_offset),
                    "cannot seek vector&lt;bool&gt; iterator after end");
            }
        }
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (_Off &lt; 0 &amp;&amp; this-&gt;_Myoff &lt; 0 - static_cast&lt;_Size_type&gt;(_Off)) { // add negative increment
            this-&gt;_Myoff += static_cast&lt;_Size_type&gt;(_Off);
            this-&gt;_Myptr -= 1 + (static_cast&lt;_Size_type&gt;(-1) - this-&gt;_Myoff) / _VBITS;
            this-&gt;_Myoff %= _VBITS;
        } else { // add non-negative increment
            this-&gt;_Myoff += static_cast&lt;_Size_type&gt;(_Off);
            this-&gt;_Myptr += this-&gt;_Myoff / _VBITS;
            this-&gt;_Myoff %= _VBITS;
        }
        return *this;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Vb_const_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp += _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vb_const_iterator&amp; operator-=(const difference_type _Off) noexcept {
        return *this += -_Off;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Vb_const_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_const_iterator _Tmp = *this;
        _Tmp -= _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER difference_type operator-(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return static_cast&lt;difference_type&gt;(_VBITS * (this-&gt;_Myptr - _Right._Myptr))
             + static_cast&lt;difference_type&gt;(this-&gt;_Myoff) - static_cast&lt;difference_type&gt;(_Right._Myoff);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER bool operator==(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return this-&gt;_Myptr == _Right._Myptr &amp;&amp; this-&gt;_Myoff == _Right._Myoff;
    }

#if _HAS_CXX20
    _NODISCARD _CONSTEXPR20_CONTAINER strong_ordering operator&lt;=&gt;(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        if (const auto _CmpResult = this-&gt;_Myptr &lt;=&gt; _Right._Myptr; _CmpResult != 0) {
            return _CmpResult;
        }
        return this-&gt;_Myoff &lt;=&gt; _Right._Myoff;
    }
#else // ^^^ _HAS_CXX20 ^^^ / vvv !_HAS_CXX20 vvv
    _NODISCARD bool operator!=(const _Vb_const_iterator&amp; _Right) const noexcept {
        return !(*this == _Right);
    }

    _NODISCARD bool operator&lt;(const _Vb_const_iterator&amp; _Right) const noexcept {
        _Compat(_Right);
        return this-&gt;_Myptr &lt; _Right._Myptr || (this-&gt;_Myptr == _Right._Myptr &amp;&amp; this-&gt;_Myoff &lt; _Right._Myoff);
    }

    _NODISCARD bool operator&gt;(const _Vb_const_iterator&amp; _Right) const noexcept {
        return _Right &lt; *this;
    }

    _NODISCARD bool operator&lt;=(const _Vb_const_iterator&amp; _Right) const noexcept {
        return !(_Right &lt; *this);
    }

    _NODISCARD bool operator&gt;=(const _Vb_const_iterator&amp; _Right) const noexcept {
        return !(*this &lt; _Right);
    }
#endif // !_HAS_CXX20

    _CONSTEXPR20_CONTAINER void _Compat(const _Vb_const_iterator&amp; _Right) const noexcept {
        // test for compatible iterator pair
#if _ITERATOR_DEBUG_LEVEL == 0
        (void) _Right;
#else // _ITERATOR_DEBUG_LEVEL == 0
        _STL_VERIFY(this-&gt;_Getcont() == _Right._Getcont(), "vector&lt;bool&gt; iterators incompatible");
#endif // _ITERATOR_DEBUG_LEVEL
    }

#if _ITERATOR_DEBUG_LEVEL != 0
    using _Prevent_inheriting_unwrap = _Vb_const_iterator;

    friend _CONSTEXPR20_CONTAINER void _Verify_range(
        const _Vb_const_iterator&amp; _First, const _Vb_const_iterator&amp; _Last) noexcept {
        // note _Compat check inside &lt;=
        _STL_VERIFY(_First &lt;= _Last, "vector&lt;bool&gt; iterator range transposed");
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

    _CONSTEXPR20_CONTAINER void _Dec() noexcept { // decrement bit position
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot decrement value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &gt; 0, "cannot decrement vector&lt;bool&gt; begin iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (this-&gt;_Myoff != 0) {
            --this-&gt;_Myoff;
        } else { // move to previous word
            this-&gt;_Myoff = _VBITS - 1;
            --this-&gt;_Myptr;
        }
    }

    _CONSTEXPR20_CONTAINER void _Inc() noexcept { // increment bit position
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot increment value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt; static_cast&lt;_Difference_type&gt;(_Cont-&gt;_Mysize),
            "cannot increment vector&lt;bool&gt; end iterator");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        if (this-&gt;_Myoff &lt; _VBITS - 1) {
            ++this-&gt;_Myoff;
        } else { // move to next word
            this-&gt;_Myoff = 0;
            ++this-&gt;_Myptr;
        }
    }
};

template &lt;class _Alvbase_wrapped&gt;
_NODISCARD _CONSTEXPR20_CONTAINER _Vb_const_iterator&lt;_Alvbase_wrapped&gt; operator+(
    typename _Vb_const_iterator&lt;_Alvbase_wrapped&gt;::difference_type _Off,
    _Vb_const_iterator&lt;_Alvbase_wrapped&gt; _Right) noexcept {
    return _Right += _Off;
}

// CLASS _Vb_iterator
template &lt;class _Alvbase_wrapped&gt;
class _Vb_iterator : public _Vb_const_iterator&lt;_Alvbase_wrapped&gt; {
public:
    using _Mybase          = _Vb_const_iterator&lt;_Alvbase_wrapped&gt;;
    using _Mycont          = typename _Mybase::_Mycont;
    using _Difference_type = typename _Mybase::_Difference_type;

    using _Reft           = _Vb_reference&lt;_Alvbase_wrapped&gt;;
    using const_reference = bool;

    using iterator_category = random_access_iterator_tag;
    using value_type        = bool;
    using difference_type   = typename _Mybase::difference_type;
    using pointer           = _Reft*;
    using reference         = _Reft;

    using _Mybase::_Mybase;

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator*() const noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        const auto _Cont = static_cast&lt;const _Mycont*&gt;(this-&gt;_Getcont());
        _STL_VERIFY(_Cont, "cannot dereference value-initialized vector&lt;bool&gt; iterator");
        _STL_VERIFY(this-&gt;_Total_off(_Cont) &lt; static_cast&lt;_Difference_type&gt;(_Cont-&gt;_Mysize),
            "vector&lt;bool&gt; iterator not dereferenceable");
#endif // _ITERATOR_DEBUG_LEVEL != 0

        return _Reft(*this);
    }

    // TRANSITION, DevCom-1331017
    _CONSTEXPR20_CONTAINER _Vb_iterator&amp; operator=(const _Vb_iterator&amp;) noexcept = default;

    _CONSTEXPR20_CONTAINER _Vb_iterator&amp; operator++() noexcept {
        _Mybase::operator++();
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vb_iterator operator++(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator++();
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vb_iterator&amp; operator--() noexcept {
        _Mybase::operator--();
        return *this;
    }

    _CONSTEXPR20_CONTAINER _Vb_iterator operator--(int) noexcept {
        _Vb_iterator _Tmp = *this;
        _Mybase::operator--();
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vb_iterator&amp; operator+=(const difference_type _Off) noexcept {
        _Mybase::operator+=(_Off);
        return *this;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER _Vb_iterator operator+(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp += _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _CONSTEXPR20_CONTAINER _Vb_iterator&amp; operator-=(const difference_type _Off) noexcept {
        _Mybase::operator-=(_Off);
        return *this;
    }

    using _Mybase::operator-;

    _NODISCARD _CONSTEXPR20_CONTAINER _Vb_iterator operator-(const difference_type _Off) const noexcept {
        _Vb_iterator _Tmp = *this;
        _Tmp -= _Off; // TRANSITION, LLVM-49342
        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](const difference_type _Off) const noexcept {
        return *(*this + _Off);
    }

    using _Prevent_inheriting_unwrap = _Vb_iterator;
};

template &lt;class _Alvbase_wrapped&gt;
_NODISCARD _CONSTEXPR20_CONTAINER _Vb_iterator&lt;_Alvbase_wrapped&gt; operator+(
    typename _Vb_iterator&lt;_Alvbase_wrapped&gt;::difference_type _Off, _Vb_iterator&lt;_Alvbase_wrapped&gt; _Right) noexcept {
    return _Right += _Off;
}

// CLASS TEMPLATE _Vb_val
template &lt;class _Alloc&gt;
class _Vb_val : public _Container_base {
public:
    using _Alvbase         = _Rebind_alloc_t&lt;_Alloc, _Vbase&gt;;
    using _Alvbase_traits  = allocator_traits&lt;_Alvbase&gt;;
    using _Vectype         = vector&lt;_Vbase, _Alvbase&gt;;
    using _Alvbase_wrapped = _Wrap_alloc&lt;_Alvbase&gt;;
    using size_type        = typename _Alvbase_traits::size_type;

    _CONSTEXPR20_CONTAINER _Vb_val() noexcept(is_nothrow_default_constructible_v&lt;_Vectype&gt;) : _Myvec(), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(const _Alloc&amp; _Al) noexcept(is_nothrow_constructible_v&lt;_Vectype, _Alvbase&gt;)
        : _Myvec(static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(size_type _Count, const bool&amp; _Val)
        : _Myvec(_Nw(_Count), static_cast&lt;_Vbase&gt;(_Val ? -1 : 0)), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(size_type _Count, const bool&amp; _Val, const _Alloc&amp; _Al)
        : _Myvec(_Nw(_Count), static_cast&lt;_Vbase&gt;(_Val ? -1 : 0), static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(0) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(const _Vb_val&amp; _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(const _Vb_val&amp; _Right, const _Alloc&amp; _Al)
        : _Myvec(_Right._Myvec, static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(_Right._Mysize) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(_Vb_val&amp;&amp; _Right) noexcept(is_nothrow_move_constructible_v&lt;_Vectype&gt;)
        : _Myvec(_STD move(_Right._Myvec)), _Mysize(_STD exchange(_Right._Mysize, size_type{0})) {
        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER _Vb_val(_Vb_val&amp;&amp; _Right, const _Alloc&amp; _Al) noexcept(
        is_nothrow_constructible_v&lt;_Vectype, _Vectype, _Alvbase&gt;)
        : _Myvec(_STD move(_Right._Myvec), static_cast&lt;_Alvbase&gt;(_Al)), _Mysize(_Right._Mysize) {
        if (_Right._Myvec.empty()) {
            // we took _Right's buffer, so zero out size
            _Right._Mysize = 0;
        }

        this-&gt;_Alloc_proxy(_GET_PROXY_ALLOCATOR(_Alvbase, _Getal()));
    }

    _CONSTEXPR20_CONTAINER ~_Vb_val() noexcept {
#if _ITERATOR_DEBUG_LEVEL != 0
        this-&gt;_Orphan_all();
        auto&amp;&amp; _Alproxy = _GET_PROXY_ALLOCATOR(_Alvbase, this-&gt;_Getal());
        _Delete_plain_internal(_Alproxy, _STD exchange(this-&gt;_Myproxy, nullptr));
#endif // _ITERATOR_DEBUG_LEVEL != 0
    }

    _CONSTEXPR20_CONTAINER _Alvbase&amp; _Getal() noexcept {
        return _Myvec._Getal();
    }

    _CONSTEXPR20_CONTAINER const _Alvbase&amp; _Getal() const noexcept {
        return _Myvec._Getal();
    }

    static _CONSTEXPR20_CONTAINER size_type _Nw(size_type _Count) noexcept {
        return (_Count + _VBITS - 1) / _VBITS;
    }

    _Vectype _Myvec; // base vector of words
    size_type _Mysize; // current length of sequence
};

// CLASS vector&lt;bool&gt;
template &lt;class _Alloc&gt;
class vector&lt;bool, _Alloc&gt; : public _Vb_val&lt;_Alloc&gt; {
public:
    static_assert(!_ENFORCE_MATCHING_ALLOCATORS || is_same_v&lt;bool, typename _Alloc::value_type&gt;,
        _MISMATCHED_ALLOCATOR_MESSAGE("vector&lt;bool, Allocator&gt;", "bool"));

    using _Mybase          = _Vb_val&lt;_Alloc&gt;;
    using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
    using _Alvbase         = typename _Mybase::_Alvbase;
    using _Alvbase_traits  = typename _Mybase::_Alvbase_traits;

    using size_type       = typename _Alvbase_traits::size_type;
    using difference_type = typename _Alvbase_traits::difference_type;
    using allocator_type  = _Alloc;

    using reference       = _Vb_reference&lt;_Alvbase_wrapped&gt;;
    using const_reference = bool;
    using value_type      = bool;

    using _Reft          = reference;
    using iterator       = _Vb_iterator&lt;_Alvbase_wrapped&gt;;
    using const_iterator = _Vb_const_iterator&lt;_Alvbase_wrapped&gt;;

    using pointer                = iterator;
    using const_pointer          = const_iterator;
    using reverse_iterator       = _STD reverse_iterator&lt;iterator&gt;;
    using const_reverse_iterator = _STD reverse_iterator&lt;const_iterator&gt;;

    static const int _VBITS = _STD _VBITS;
    enum { _EEN_VBITS = _VBITS }; // helper for expression evaluator

    _CONSTEXPR20_CONTAINER vector() noexcept(is_nothrow_default_constructible_v&lt;_Mybase&gt;) // strengthened
        : _Mybase() {}

    _CONSTEXPR20_CONTAINER explicit vector(const _Alloc&amp; _Al) noexcept(
        is_nothrow_constructible_v&lt;_Mybase, const _Alloc&amp;&gt;) // strengthened
        : _Mybase(_Al) {}

    _CONSTEXPR20_CONTAINER explicit vector(_CRT_GUARDOVERFLOW size_type _Count, const _Alloc&amp; _Al = _Alloc())
        : _Mybase(_Count, false, _Al) {
        _Trim(_Count);
    }

    _CONSTEXPR20_CONTAINER vector(_CRT_GUARDOVERFLOW size_type _Count, const bool&amp; _Val, const _Alloc&amp; _Al = _Alloc())
        : _Mybase(_Count, _Val, _Al) {
        _Trim(_Count);
    }

    _CONSTEXPR20_CONTAINER vector(const vector&amp; _Right) : _Mybase(_Right) {}

    _CONSTEXPR20_CONTAINER vector(const vector&amp; _Right, const _Alloc&amp; _Al) : _Mybase(_Right, _Al) {}

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20_CONTAINER vector(_Iter _First, _Iter _Last, const _Alloc&amp; _Al = _Alloc()) : _Mybase(_Al) {
        _BConstruct(_First, _Last);
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _BConstruct(_Iter _First, _Iter _Last) {
        insert(begin(), _First, _Last);
    }

    _CONSTEXPR20_CONTAINER vector(vector&amp;&amp; _Right) noexcept(is_nothrow_move_constructible_v&lt;_Mybase&gt;) // strengthened
        : _Mybase(_STD move(_Right)) {
        this-&gt;_Swap_proxy_and_iterators(_Right);
    }

    _CONSTEXPR20_CONTAINER vector(vector&amp;&amp; _Right, const _Alloc&amp; _Al) noexcept(
        is_nothrow_constructible_v&lt;_Mybase, _Mybase, const _Alloc&amp;&gt;)
        : _Mybase(_STD move(_Right), _Al) {
        if constexpr (!_Alvbase_traits::is_always_equal::value) {
            if (this-&gt;_Getal() != _Right._Getal()) {
                return;
            }
        }

        this-&gt;_Swap_proxy_and_iterators(_Right);
    }

private:
#if _ITERATOR_DEBUG_LEVEL != 0
    _CONSTEXPR20_CONTAINER void _Move_assign(vector&amp; _Right, _Equal_allocators) noexcept {
        this-&gt;_Myvec  = _STD move(_Right._Myvec);
        this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
        this-&gt;_Swap_proxy_and_iterators(_Right);
    }

    _CONSTEXPR20_CONTAINER void _Move_assign(vector&amp; _Right, _Propagate_allocators) noexcept {
        using _Alproxy_type = _Rebind_alloc_t&lt;_Alvbase, _Container_proxy&gt;;
        if (this-&gt;_Getal() != _Right._Getal()) { // reload proxy
            // intentionally slams into noexcept on OOM, TRANSITION, VSO-466800
            _Alproxy_type _Oldal(this-&gt;_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr&lt;_Alvbase&gt; _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this-&gt;_Myvec  = _STD move(_Right._Myvec);
            this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
            _Proxy._Bind(_Oldal, this);
            this-&gt;_Swap_proxy_and_iterators(_Right);
            return;
        }

        this-&gt;_Myvec  = _STD move(_Right._Myvec);
        this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
        this-&gt;_Swap_proxy_and_iterators(_Right);
    }

    _CONSTEXPR20_CONTAINER void _Move_assign(vector&amp; _Right, _No_propagate_allocators) {
        this-&gt;_Myvec  = _STD move(_Right._Myvec);
        this-&gt;_Mysize = _Right._Mysize;
        if (_Right._Myvec.empty()) {
            // we took _Right's buffer, so zero out size
            _Right._Mysize = 0;
        }

        if (this-&gt;_Getal() == _Right._Getal()) {
            this-&gt;_Swap_proxy_and_iterators(_Right);
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

public:
    _CONSTEXPR20_CONTAINER vector&amp; operator=(vector&amp;&amp; _Right) noexcept(is_nothrow_move_assignable_v&lt;_Mybase&gt;) {
        if (this != _STD addressof(_Right)) {
#if _ITERATOR_DEBUG_LEVEL == 0
            this-&gt;_Myvec  = _STD move(_Right._Myvec);
            this-&gt;_Mysize = _STD exchange(_Right._Mysize, size_type{0});
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
            this-&gt;_Orphan_all();
            _Move_assign(_Right, _Choose_pocma&lt;_Alvbase&gt;{});
#endif // _ITERATOR_DEBUG_LEVEL == 0
        }
        return *this;
    }

    template &lt;class... _Valty&gt;
    _CONSTEXPR20_CONTAINER decltype(auto) emplace_back(_Valty&amp;&amp;... _Val) {
        bool _Tmp(_STD forward&lt;_Valty&gt;(_Val)...);
        push_back(_Tmp);

#if _HAS_CXX17
        return back();
#endif // _HAS_CXX17
    }

    template &lt;class... _Valty&gt;
    _CONSTEXPR20_CONTAINER iterator emplace(const_iterator _Where, _Valty&amp;&amp;... _Val) {
        bool _Tmp(_STD forward&lt;_Valty&gt;(_Val)...);
        return insert(_Where, _Tmp);
    }

    _CONSTEXPR20_CONTAINER vector(initializer_list&lt;bool&gt; _Ilist, const _Alloc&amp; _Al = allocator_type())
        : _Mybase(0, false, _Al) {
        insert(begin(), _Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20_CONTAINER vector&amp; operator=(initializer_list&lt;bool&gt; _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
        return *this;
    }

    _CONSTEXPR20_CONTAINER void assign(initializer_list&lt;bool&gt; _Ilist) {
        assign(_Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, initializer_list&lt;bool&gt; _Ilist) {
        return insert(_Where, _Ilist.begin(), _Ilist.end());
    }

    _CONSTEXPR20_CONTAINER ~vector() noexcept {}

private:
#if _ITERATOR_DEBUG_LEVEL != 0
    _CONSTEXPR20_CONTAINER void _Copy_assign(const vector&amp; _Right, false_type) {
        this-&gt;_Myvec  = _Right._Myvec;
        this-&gt;_Mysize = _Right._Mysize;
    }

    _CONSTEXPR20_CONTAINER void _Copy_assign(const vector&amp; _Right, true_type) {
        if (this-&gt;_Getal() == _Right._Getal()) {
            _Copy_assign(_Right, false_type{});
        } else {
            // reload proxy
            using _Alproxy_type = _Rebind_alloc_t&lt;_Alvbase, _Container_proxy&gt;;
            _Alproxy_type _Oldal(this-&gt;_Getal());
            _Alproxy_type _Right_proxy_al(_Right._Getal());
            _Container_proxy_ptr&lt;_Alvbase&gt; _Proxy(_Right_proxy_al, _Leave_proxy_unbound{});
            this-&gt;_Myvec  = _Right._Myvec;
            this-&gt;_Mysize = _Right._Mysize;
            _Proxy._Bind(_Oldal, this);
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL != 0

public:
    _CONSTEXPR20_CONTAINER vector&amp; operator=(const vector&amp; _Right) {
        if (this != _STD addressof(_Right)) {
#if _ITERATOR_DEBUG_LEVEL == 0
            this-&gt;_Myvec  = _Right._Myvec;
            this-&gt;_Mysize = _Right._Mysize;
#else // ^^^ _ITERATOR_DEBUG_LEVEL == 0 ^^^ // vvv _ITERATOR_DEBUG_LEVEL != 0 vvv
            this-&gt;_Orphan_all();
            _Copy_assign(_Right, _Choose_pocca&lt;_Alvbase&gt;{});
#endif // _ITERATOR_DEBUG_LEVEL == 0
        }

        return *this;
    }

    _CONSTEXPR20_CONTAINER void reserve(_CRT_GUARDOVERFLOW size_type _Count) {
        this-&gt;_Myvec.reserve(this-&gt;_Nw(_Count));
    }

    _NODISCARD _CONSTEXPR20_CONTAINER size_type capacity() const noexcept {
        return this-&gt;_Myvec.capacity() * _VBITS;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER iterator begin() noexcept {
        return iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator begin() const noexcept {
        return const_iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER iterator end() noexcept {
        return begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator end() const noexcept {
        return begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator cbegin() const noexcept {
        return begin();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator cend() const noexcept {
        return end();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator crbegin() const noexcept {
        return rbegin();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator crend() const noexcept {
        return rend();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER iterator _Unchecked_begin() noexcept {
        return iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator _Unchecked_begin() const noexcept {
        return const_iterator(this-&gt;_Myvec.data(), this);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER iterator _Unchecked_end() noexcept {
        return _Unchecked_begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_iterator _Unchecked_end() const noexcept {
        return _Unchecked_begin() + static_cast&lt;difference_type&gt;(this-&gt;_Mysize);
    }

    _CONSTEXPR20_CONTAINER void shrink_to_fit() {
        if (this-&gt;_Myvec.capacity() != this-&gt;_Myvec.size()) {
            this-&gt;_Orphan_all();
            this-&gt;_Myvec.shrink_to_fit();
        }
    }

    _CONSTEXPR20_CONTAINER iterator _Make_iter(const_iterator _Where) noexcept {
        iterator _Tmp = begin();
        if (0 &lt; this-&gt;_Mysize) {
            _Tmp += _Where - begin();
        }

        return _Tmp;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reverse_iterator rbegin() noexcept {
        return reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator rbegin() const noexcept {
        return const_reverse_iterator(end());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reverse_iterator rend() noexcept {
        return reverse_iterator(begin());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reverse_iterator rend() const noexcept {
        return const_reverse_iterator(begin());
    }

    _CONSTEXPR20_CONTAINER void resize(_CRT_GUARDOVERFLOW size_type _Newsize, bool _Val = false) {
        if (size() &lt; _Newsize) {
            _Insert_n(end(), _Newsize - size(), _Val);
        } else if (_Newsize &lt; size()) {
            erase(begin() + static_cast&lt;difference_type&gt;(_Newsize), end());
        }
    }

    _NODISCARD _CONSTEXPR20_CONTAINER size_type size() const noexcept {
        return this-&gt;_Mysize;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER size_type max_size() const noexcept {
        constexpr auto _Diff_max  = static_cast&lt;size_type&gt;((numeric_limits&lt;difference_type&gt;::max)());
        const size_type _Ints_max = this-&gt;_Myvec.max_size();
        if (_Ints_max &gt; _Diff_max / _VBITS) { // max_size bound by difference_type limits
            return _Diff_max;
        }

        // max_size bound by underlying storage limits
        return _Ints_max * _VBITS;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER bool empty() const noexcept {
        return size() == 0;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER allocator_type get_allocator() const noexcept {
        return static_cast&lt;allocator_type&gt;(this-&gt;_Myvec.get_allocator());
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reference at(size_type _Off) const {
        if (size() &lt;= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference at(size_type _Off) {
        if (size() &lt;= _Off) {
            _Xran();
        }

        return (*this)[_Off];
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reference operator[](size_type _Off) const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(_Off &lt; this-&gt;_Mysize, "vector&lt;bool&gt; subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        const_iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference operator[](size_type _Off) noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(_Off &lt; this-&gt;_Mysize, "vector&lt;bool&gt; subscript out of range");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        iterator _It = begin();
        _It._Advance(_Off);
        return *_It;
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference front() noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "front() called on empty vector&lt;bool&gt;");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return *begin();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reference front() const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "front() called on empty vector&lt;bool&gt;");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return *begin();
    }

    _NODISCARD _CONSTEXPR20_CONTAINER reference back() noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "back() called on empty vector&lt;bool&gt;");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return *(end() - 1);
    }

    _NODISCARD _CONSTEXPR20_CONTAINER const_reference back() const noexcept /* strengthened */ {
#if _CONTAINER_DEBUG_LEVEL &gt; 0
        _STL_VERIFY(this-&gt;_Mysize != 0, "back() called on empty vector&lt;bool&gt;");
#endif // _CONTAINER_DEBUG_LEVEL &gt; 0

        return *(end() - 1);
    }

    _CONSTEXPR20_CONTAINER void push_back(const bool&amp; _Val) {
        insert(end(), _Val);
    }

    _CONSTEXPR20_CONTAINER void pop_back() noexcept /* strengthened */ {
        erase(end() - 1);
    }

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20_CONTAINER void assign(_Iter _First, _Iter _Last) {
        clear();
        insert(begin(), _First, _Last);
    }

    _CONSTEXPR20_CONTAINER void assign(_CRT_GUARDOVERFLOW size_type _Count, const bool&amp; _Val) {
        clear();
        _Insert_n(begin(), _Count, _Val);
    }

    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, const bool&amp; _Val) {
        return _Insert_n(_Where, static_cast&lt;size_type&gt;(1), _Val);
    }

    _CONSTEXPR20_CONTAINER iterator insert(
        const_iterator _Where, _CRT_GUARDOVERFLOW size_type _Count, const bool&amp; _Val) {
        return _Insert_n(_Where, _Count, _Val);
    }

    template &lt;class _Iter, enable_if_t&lt;_Is_iterator_v&lt;_Iter&gt;, int&gt; = 0&gt;
    _CONSTEXPR20_CONTAINER iterator insert(const_iterator _Where, _Iter _First, _Iter _Last) {
        difference_type _Off = _Where - begin();
        _Insert(_Where, _First, _Last, _Iter_cat_t&lt;_Iter&gt;{});
        return begin() + _Off;
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag) {
        difference_type _Off = _Where - begin();

        for (; _First != _Last; ++_First, (void) ++_Off) {
            insert(begin() + _Off, *_First);
        }
    }

    template &lt;class _Iter&gt;
    _CONSTEXPR20_CONTAINER void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag) {
        _Adl_verify_range(_First, _Last);
        auto _Count    = _Convert_size&lt;size_type&gt;(static_cast&lt;size_t&gt;(_STD distance(_First, _Last)));
        size_type _Off = _Insert_x(_Where, _Count);
        _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast&lt;difference_type&gt;(_Off));
    }

    _CONSTEXPR20_CONTAINER iterator erase(const_iterator _Where_arg) noexcept /* strengthened */ {
        iterator _Where      = _Make_iter(_Where_arg);
        difference_type _Off = _Where - begin();

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(end() &gt; _Where, "vector&lt;bool&gt; erase iterator outside range");
        _STD copy(_Next_iter(_Where), end(), _Where);
        _Orphan_range(static_cast&lt;size_type&gt;(_Off), this-&gt;_Mysize);

#else // _ITERATOR_DEBUG_LEVEL == 2
        _STD copy(_Next_iter(_Where), end(), _Where);
#endif // _ITERATOR_DEBUG_LEVEL == 2

        _Trim(this-&gt;_Mysize - 1);
        return begin() + _Off;
    }

    _CONSTEXPR20_CONTAINER iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
    /* strengthened */ {
        iterator _First      = _Make_iter(_First_arg);
        iterator _Last       = _Make_iter(_Last_arg);
        difference_type _Off = _First - begin();

        if (_First != _Last) { // worth doing, copy down over hole
#if _ITERATOR_DEBUG_LEVEL == 2
            _STL_VERIFY(_Last &gt;= _First &amp;&amp; end() &gt;= _Last, "vector&lt;bool&gt; erase iterator outside range");
            iterator _Next      = _STD copy(_Last, end(), _First);
            const auto _Newsize = static_cast&lt;size_type&gt;(_Next - begin());
            _Orphan_range(_Newsize, this-&gt;_Mysize);
            _Trim(_Newsize);

#else // _ITERATOR_DEBUG_LEVEL == 2
            iterator _Next = _STD copy(_Last, end(), _First);
            _Trim(static_cast&lt;size_type&gt;(_Next - begin()));
#endif // _ITERATOR_DEBUG_LEVEL == 2
        }
        return begin() + _Off;
    }

    _CONSTEXPR20_CONTAINER void clear() noexcept {
        this-&gt;_Orphan_all();
        this-&gt;_Myvec.clear();
        this-&gt;_Mysize = 0;
    }

    _CONSTEXPR20_CONTAINER void flip() noexcept { // toggle all elements
        for (auto&amp; _Elem : this-&gt;_Myvec) {
            _Elem = ~_Elem;
        }

        _Trim(this-&gt;_Mysize);
    }

    _CONSTEXPR20_CONTAINER void swap(vector&amp; _Right) noexcept /* strengthened */ {
        if (this != _STD addressof(_Right)) {
            this-&gt;_Swap_proxy_and_iterators(_Right);
            this-&gt;_Myvec.swap(_Right._Myvec);
            _STD swap(this-&gt;_Mysize, _Right._Mysize);
        }
    }

    static _CONSTEXPR20_CONTAINER void swap(reference _Left, reference _Right) noexcept {
        bool _Val = _Left; // NOT _STD swap
        _Left     = _Right;
        _Right    = _Val;
    }

    friend hash&lt;vector&lt;bool, _Alloc&gt;&gt;;

    _CONSTEXPR20_CONTAINER iterator _Insert_n(const_iterator _Where, size_type _Count, const bool&amp; _Val) {
        size_type _Off     = _Insert_x(_Where, _Count);
        const auto _Result = begin() + static_cast&lt;difference_type&gt;(_Off);
        _STD fill(_Result, _Result + static_cast&lt;difference_type&gt;(_Count), _Val);
        return _Result;
    }

    _CONSTEXPR20_CONTAINER size_type _Insert_x(const_iterator _Where, size_type _Count) {
        difference_type _Off = _Where - begin();

#if _ITERATOR_DEBUG_LEVEL == 2
        _STL_VERIFY(end() &gt;= _Where, "vector&lt;bool&gt; insert iterator outside range");
        bool _Realloc = capacity() - size() &lt; _Count;
#endif // _ITERATOR_DEBUG_LEVEL == 2

        if (_Count != 0) {
            if (max_size() - size() &lt; _Count) {
                _Xlen(); // result too long
            }

            // worth doing
            this-&gt;_Myvec.resize(this-&gt;_Nw(size() + _Count), 0);
            if (empty()) {
                this-&gt;_Mysize += _Count;
            } else { // make room and copy down suffix
                iterator _Oldend = end();
                this-&gt;_Mysize += _Count;
                _STD copy_backward(begin() + _Off, _Oldend, end());
            }

#if _ITERATOR_DEBUG_LEVEL == 2
            _Orphan_range(static_cast&lt;size_type&gt;(_Realloc ? 0 : _Off), this-&gt;_Mysize);
#endif // _ITERATOR_DEBUG_LEVEL == 2
        }

        return static_cast&lt;size_type&gt;(_Off);
    }

#if _ITERATOR_DEBUG_LEVEL == 2
    _CONSTEXPR20_CONTAINER void _Orphan_range_unlocked(size_type _Offlo, size_type _Offhi) const {
        const auto _Base = this-&gt;_Myvec.data();

        _Iterator_base12** _Pnext = &amp;this-&gt;_Myproxy-&gt;_Myfirstiter;
        while (*_Pnext) { // test offset from beginning of vector
            const auto&amp; _Pnextiter = static_cast&lt;const_iterator&amp;&gt;(**_Pnext);
            const auto _Temp       = *_Pnext; // TRANSITION, VSO-1269037
            if (!_Pnextiter._Myptr) { // orphan the iterator
                _Temp-&gt;_Myproxy = nullptr;
                *_Pnext         = _Temp-&gt;_Mynextiter;
                continue;
            }
            const auto _Off = static_cast&lt;size_type&gt;(_VBITS * (_Pnextiter._Myptr - _Base)) + _Pnextiter._Myoff;
            if (_Off &lt; _Offlo || _Offhi &lt; _Off) {
                _Pnext = &amp;_Temp-&gt;_Mynextiter;
            } else { // orphan the iterator
                _Temp-&gt;_Myproxy = nullptr;
                *_Pnext         = _Temp-&gt;_Mynextiter;
            }
        }
    }

    void _Orphan_range_locked(size_type _Offlo, size_type _Offhi) const {
        _Lockit _Lock(_LOCK_DEBUG);
        _Orphan_range_unlocked(_Offlo, _Offhi);
    }

    _CONSTEXPR20_CONTAINER void _Orphan_range(size_type _Offlo, size_type _Offhi) const {
#ifdef __cpp_lib_constexpr_dynamic_alloc
        if (_STD is_constant_evaluated()) {
            _Orphan_range_unlocked(_Offlo, _Offhi);
        } else
#endif // __cpp_lib_constexpr_dynamic_alloc
        {
            _Orphan_range_locked(_Offlo, _Offhi);
        }
    }
#endif // _ITERATOR_DEBUG_LEVEL == 2

    _CONSTEXPR20_CONTAINER void _Trim(size_type _Size) {
        if (max_size() &lt; _Size) {
            _Xlen(); // result too long
        }

        const size_type _Words = this-&gt;_Nw(_Size);
        if (_Words &lt; this-&gt;_Myvec.size()) {
            this-&gt;_Myvec.erase(this-&gt;_Myvec.begin() + static_cast&lt;difference_type&gt;(_Words), this-&gt;_Myvec.end());
        }

        this-&gt;_Mysize = _Size;
        _Size %= _VBITS;
        if (0 &lt; _Size) {
            this-&gt;_Myvec[_Words - 1] &amp;= (static_cast&lt;_Vbase&gt;(1) &lt;&lt; _Size) - 1;
        }
    }

    [[noreturn]] void _Xlen() const {
        _Xlength_error("vector&lt;bool&gt; too long");
    }

    [[noreturn]] void _Xran() const {
        _Xout_of_range("invalid vector&lt;bool&gt; subscript");
    }
};

// STRUCT TEMPLATE SPECIALIZATION hash
template &lt;class _Alloc&gt;
struct hash&lt;vector&lt;bool, _Alloc&gt;&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef vector&lt;bool, _Alloc&gt; _ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;

    _NODISCARD size_t operator()(const vector&lt;bool, _Alloc&gt;&amp; _Keyval) const noexcept {
        return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
    }
};

#if _HAS_CXX17
namespace pmr {
    template &lt;class _Ty&gt;
    using vector = _STD vector&lt;_Ty, polymorphic_allocator&lt;_Ty&gt;&gt;;
} // namespace pmr
#endif // _HAS_CXX17

// VARIABLE TEMPLATE _Is_vb_iterator
template &lt;class _Alloc, bool _RequiresMutable&gt;
_INLINE_VAR constexpr bool _Is_vb_iterator&lt;_Vb_iterator&lt;_Alloc&gt;, _RequiresMutable&gt; = true;

template &lt;class _Alloc&gt;
_INLINE_VAR constexpr bool _Is_vb_iterator&lt;_Vb_const_iterator&lt;_Alloc&gt;, false&gt; = true;

template &lt;class _FwdIt, class _Ty&gt;
_CONSTEXPR20 void _Fill_vbool(_FwdIt _First, _FwdIt _Last, const _Ty&amp; _Val) {
    // Set [_First, _Last) to _Val
    if (_First == _Last) {
        return;
    }

    _Vbase* _VbFirst      = const_cast&lt;_Vbase*&gt;(_First._Myptr);
    _Vbase* const _VbLast = const_cast&lt;_Vbase*&gt;(_Last._Myptr);

    const auto _FirstSourceMask = static_cast&lt;_Vbase&gt;(-1) &lt;&lt; _First._Myoff;
    const auto _FirstDestMask   = ~_FirstSourceMask;
    const auto _FillVal         = static_cast&lt;_Vbase&gt;(_Val ? -1 : 0);

    if (_VbFirst == _VbLast) {
        // We already excluded _First == _Last, so here _Last._Myoff &gt; 0 and the shift is safe
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        const auto _SourceMask     = _FirstSourceMask &amp; _LastSourceMask;
        const auto _DestMask       = _FirstDestMask | _LastDestMask;
        *_VbFirst                  = (*_VbFirst &amp; _DestMask) | (_FillVal &amp; _SourceMask);
        return;
    }

    *_VbFirst = (*_VbFirst &amp; _FirstDestMask) | (_FillVal &amp; _FirstSourceMask);
    ++_VbFirst;

#ifdef __cpp_lib_constexpr_dynamic_alloc
    if (_STD is_constant_evaluated()) {
        for (; _VbFirst != _VbLast; ++_VbFirst) {
            *_VbFirst = _FillVal;
        }
    } else
#endif // __cpp_lib_constexpr_dynamic_alloc
    {
        const auto _VbFirst_ch = reinterpret_cast&lt;const char*&gt;(_VbFirst);
        const auto _VbLast_ch  = reinterpret_cast&lt;const char*&gt;(_VbLast);
        const auto _Count_ch   = static_cast&lt;size_t&gt;(_VbLast_ch - _VbFirst_ch);
        const auto _ValChar    = static_cast&lt;unsigned char&gt;(_Val ? -1 : 0);
        _CSTD memset(_VbFirst, _ValChar, _Count_ch);
        _VbFirst = _VbLast;
    }

    if (_Last._Myoff != 0) {
        const auto _LastSourceMask = static_cast&lt;_Vbase&gt;(-1) &gt;&gt; (_VBITS - _Last._Myoff);
        const auto _LastDestMask   = ~_LastSourceMask;
        *_VbFirst                  = (*_VbFirst &amp; _LastDestMask) | (_FillVal &amp; _LastSourceMask);
    }
}
_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)
#endif // _STL_COMPILER_PREPROCESSOR
#endif // _VECTOR_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>
<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>type_traits</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
// type_traits standard header (core)

// Copyright (c) Microsoft Corporation.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception

#pragma once
#ifndef _TYPE_TRAITS_
#define _TYPE_TRAITS_
#include &lt;yvals_core.h&gt;
#if _STL_COMPILER_PREPROCESSOR
#include &lt;cstdint&gt;
#include &lt;xstddef&gt;

#pragma pack(push, _CRT_PACKING)
#pragma warning(push, _STL_WARNING_LEVEL)
#pragma warning(disable : _STL_DISABLED_WARNINGS)
_STL_DISABLE_CLANG_WARNINGS
#pragma push_macro("new")
#undef new

_STD_BEGIN
// STRUCT TEMPLATE integer_sequence
template &lt;class _Ty, _Ty... _Vals&gt;
struct integer_sequence { // sequence of integer parameters
    static_assert(is_integral_v&lt;_Ty&gt;, "integer_sequence&lt;T, I...&gt; requires T to be an integral type.");

    using value_type = _Ty;

    _NODISCARD static constexpr size_t size() noexcept {
        return sizeof...(_Vals);
    }
};

// ALIAS TEMPLATE make_integer_sequence
template &lt;class _Ty, _Ty _Size&gt;
using make_integer_sequence = __make_integer_seq&lt;integer_sequence, _Ty, _Size&gt;;

template &lt;size_t... _Vals&gt;
using index_sequence = integer_sequence&lt;size_t, _Vals...&gt;;

template &lt;size_t _Size&gt;
using make_index_sequence = make_integer_sequence&lt;size_t, _Size&gt;;

template &lt;class... _Types&gt;
using index_sequence_for = make_index_sequence&lt;sizeof...(_Types)&gt;;

// STRUCT TEMPLATE conjunction
template &lt;bool _First_value, class _First, class... _Rest&gt;
struct _Conjunction { // handle false trait or last trait
    using type = _First;
};

template &lt;class _True, class _Next, class... _Rest&gt;
struct _Conjunction&lt;true, _True, _Next, _Rest...&gt; { // the first trait is true, try the next one
    using type = typename _Conjunction&lt;_Next::value, _Next, _Rest...&gt;::type;
};

template &lt;class... _Traits&gt;
struct conjunction : true_type {}; // If _Traits is empty, true_type

template &lt;class _First, class... _Rest&gt;
struct conjunction&lt;_First, _Rest...&gt; : _Conjunction&lt;_First::value, _First, _Rest...&gt;::type {
    // the first false trait in _Traits, or the last trait if none are false
};

template &lt;class... _Traits&gt;
_INLINE_VAR constexpr bool conjunction_v = conjunction&lt;_Traits...&gt;::value;

// STRUCT TEMPLATE negation
template &lt;class _Trait&gt;
struct negation : bool_constant&lt;!static_cast&lt;bool&gt;(_Trait::value)&gt; {}; // The negated result of _Trait

template &lt;class _Trait&gt;
_INLINE_VAR constexpr bool negation_v = negation&lt;_Trait&gt;::value;

// STRUCT TEMPLATE is_void
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_void_v = is_same_v&lt;remove_cv_t&lt;_Ty&gt;, void&gt;;

template &lt;class _Ty&gt;
struct is_void : bool_constant&lt;is_void_v&lt;_Ty&gt;&gt; {};

// ALIAS TEMPLATE void_t
template &lt;class... _Types&gt;
using void_t = void;

// Type modifiers
// STRUCT TEMPLATE add_const
template &lt;class _Ty&gt;
struct add_const { // add top-level const qualifier
    using type = const _Ty;
};

template &lt;class _Ty&gt;
using add_const_t = typename add_const&lt;_Ty&gt;::type;

// STRUCT TEMPLATE add_volatile
template &lt;class _Ty&gt;
struct add_volatile { // add top-level volatile qualifier
    using type = volatile _Ty;
};

template &lt;class _Ty&gt;
using add_volatile_t = typename add_volatile&lt;_Ty&gt;::type;

// STRUCT TEMPLATE add_cv
template &lt;class _Ty&gt;
struct add_cv { // add top-level const and volatile qualifiers
    using type = const volatile _Ty;
};

template &lt;class _Ty&gt;
using add_cv_t = typename add_cv&lt;_Ty&gt;::type;

// STRUCT TEMPLATE _Add_reference
template &lt;class _Ty, class = void&gt;
struct _Add_reference { // add reference (non-referenceable type)
    using _Lvalue = _Ty;
    using _Rvalue = _Ty;
};

template &lt;class _Ty&gt;
struct _Add_reference&lt;_Ty, void_t&lt;_Ty&amp;&gt;&gt; { // (referenceable type)
    using _Lvalue = _Ty&amp;;
    using _Rvalue = _Ty&amp;&amp;;
};

// STRUCT TEMPLATE add_lvalue_reference
template &lt;class _Ty&gt;
struct add_lvalue_reference {
    using type = typename _Add_reference&lt;_Ty&gt;::_Lvalue;
};

template &lt;class _Ty&gt;
using add_lvalue_reference_t = typename _Add_reference&lt;_Ty&gt;::_Lvalue;

// STRUCT TEMPLATE add_rvalue_reference
template &lt;class _Ty&gt;
struct add_rvalue_reference {
    using type = typename _Add_reference&lt;_Ty&gt;::_Rvalue;
};

template &lt;class _Ty&gt;
using add_rvalue_reference_t = typename _Add_reference&lt;_Ty&gt;::_Rvalue;

// FUNCTION TEMPLATE declval
template &lt;class _Ty&gt;
add_rvalue_reference_t&lt;_Ty&gt; declval() noexcept;

// STRUCT TEMPLATE remove_extent
template &lt;class _Ty&gt;
struct remove_extent { // remove array extent
    using type = _Ty;
};

template &lt;class _Ty, size_t _Ix&gt;
struct remove_extent&lt;_Ty[_Ix]&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_extent&lt;_Ty[]&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
using remove_extent_t = typename remove_extent&lt;_Ty&gt;::type;

// STRUCT TEMPLATE remove_all_extents
template &lt;class _Ty&gt;
struct remove_all_extents { // remove all array extents
    using type = _Ty;
};

template &lt;class _Ty, size_t _Ix&gt;
struct remove_all_extents&lt;_Ty[_Ix]&gt; {
    using type = typename remove_all_extents&lt;_Ty&gt;::type;
};

template &lt;class _Ty&gt;
struct remove_all_extents&lt;_Ty[]&gt; {
    using type = typename remove_all_extents&lt;_Ty&gt;::type;
};

template &lt;class _Ty&gt;
using remove_all_extents_t = typename remove_all_extents&lt;_Ty&gt;::type;

// STRUCT TEMPLATE remove_pointer
template &lt;class _Ty&gt;
struct remove_pointer {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty*&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty* const&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty* volatile&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct remove_pointer&lt;_Ty* const volatile&gt; {
    using type = _Ty;
};

template &lt;class _Ty&gt;
using remove_pointer_t = typename remove_pointer&lt;_Ty&gt;::type;

// STRUCT TEMPLATE add_pointer
template &lt;class _Ty, class = void&gt;
struct _Add_pointer { // add pointer (pointer type cannot be formed)
    using type = _Ty;
};

template &lt;class _Ty&gt;
struct _Add_pointer&lt;_Ty, void_t&lt;remove_reference_t&lt;_Ty&gt;*&gt;&gt; { // (pointer type can be formed)
    using type = remove_reference_t&lt;_Ty&gt;*;
};

template &lt;class _Ty&gt;
struct add_pointer {
    using type = typename _Add_pointer&lt;_Ty&gt;::type;
};

template &lt;class _Ty&gt;
using add_pointer_t = typename _Add_pointer&lt;_Ty&gt;::type;

// TYPE PREDICATES
// STRUCT TEMPLATE is_array
template &lt;class&gt;
_INLINE_VAR constexpr bool is_array_v = false; // determine whether type argument is an array

template &lt;class _Ty, size_t _Nx&gt;
_INLINE_VAR constexpr bool is_array_v&lt;_Ty[_Nx]&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_array_v&lt;_Ty[]&gt; = true;

template &lt;class _Ty&gt;
struct is_array : bool_constant&lt;is_array_v&lt;_Ty&gt;&gt; {};

#if _HAS_CXX20
// STRUCT TEMPLATE is_bounded_array
template &lt;class&gt;
inline constexpr bool is_bounded_array_v = false;

template &lt;class _Ty, size_t _Nx&gt;
inline constexpr bool is_bounded_array_v&lt;_Ty[_Nx]&gt; = true;

template &lt;class _Ty&gt;
struct is_bounded_array : bool_constant&lt;is_bounded_array_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_unbounded_array
template &lt;class&gt;
inline constexpr bool is_unbounded_array_v = false;

template &lt;class _Ty&gt;
inline constexpr bool is_unbounded_array_v&lt;_Ty[]&gt; = true;

template &lt;class _Ty&gt;
struct is_unbounded_array : bool_constant&lt;is_unbounded_array_v&lt;_Ty&gt;&gt; {};
#endif // _HAS_CXX20

// STRUCT TEMPLATE is_lvalue_reference
template &lt;class&gt;
_INLINE_VAR constexpr bool is_lvalue_reference_v = false; // determine whether type argument is an lvalue reference

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_lvalue_reference_v&lt;_Ty&amp;&gt; = true;

template &lt;class _Ty&gt;
struct is_lvalue_reference : bool_constant&lt;is_lvalue_reference_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_rvalue_reference
template &lt;class&gt;
_INLINE_VAR constexpr bool is_rvalue_reference_v = false; // determine whether type argument is an rvalue reference

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_rvalue_reference_v&lt;_Ty&amp;&amp;&gt; = true;

template &lt;class _Ty&gt;
struct is_rvalue_reference : bool_constant&lt;is_rvalue_reference_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_reference
template &lt;class&gt;
_INLINE_VAR constexpr bool is_reference_v = false; // determine whether type argument is a reference

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_reference_v&lt;_Ty&amp;&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_reference_v&lt;_Ty&amp;&amp;&gt; = true;

template &lt;class _Ty&gt;
struct is_reference : bool_constant&lt;is_reference_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_pointer
template &lt;class&gt;
_INLINE_VAR constexpr bool is_pointer_v = false; // determine whether _Ty is a pointer

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty*&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty* const&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty* volatile&gt; = true;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_pointer_v&lt;_Ty* const volatile&gt; = true;

template &lt;class _Ty&gt;
struct is_pointer : bool_constant&lt;is_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_null_pointer
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_null_pointer_v =
    is_same_v&lt;remove_cv_t&lt;_Ty&gt;, nullptr_t&gt;; // determine whether _Ty is cv-qualified nullptr_t

template &lt;class _Ty&gt;
struct is_null_pointer : bool_constant&lt;is_null_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_union
template &lt;class _Ty&gt;
struct is_union : bool_constant&lt;__is_union(_Ty)&gt; {}; // determine whether _Ty is a union

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_union_v = __is_union(_Ty);

// STRUCT TEMPLATE is_class
template &lt;class _Ty&gt;
struct is_class : bool_constant&lt;__is_class(_Ty)&gt; {}; // determine whether _Ty is a class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_class_v = __is_class(_Ty);

// STRUCT TEMPLATE is_fundamental
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_fundamental_v = is_arithmetic_v&lt;_Ty&gt; || is_void_v&lt;_Ty&gt; || is_null_pointer_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_fundamental : bool_constant&lt;is_fundamental_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is a fundamental type

// STRUCT TEMPLATE is_convertible
template &lt;class _From, class _To&gt;
struct is_convertible : bool_constant&lt;__is_convertible_to(_From, _To)&gt; {
    // determine whether _From is convertible to _To
};

template &lt;class _From, class _To&gt;
_INLINE_VAR constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

// STRUCT TEMPLATE is_enum
template &lt;class _Ty&gt;
struct is_enum : bool_constant&lt;__is_enum(_Ty)&gt; {}; // determine whether _Ty is an enumerated type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_enum_v = __is_enum(_Ty);

// STRUCT TEMPLATE is_compound
template &lt;class _Ty&gt;
struct is_compound : bool_constant&lt;!is_fundamental_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is a compound type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_compound_v = !is_fundamental_v&lt;_Ty&gt;;

// STRUCT TEMPLATE _Arg_types
template &lt;class... _Types&gt;
struct _Arg_types {}; // provide argument_type, etc. when sizeof...(_Types) is 1 or 2

template &lt;class _Ty1&gt;
struct _Arg_types&lt;_Ty1&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 _ARGUMENT_TYPE_NAME;
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Arg_types&lt;_Ty1, _Ty2&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty1 _FIRST_ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ty2 _SECOND_ARGUMENT_TYPE_NAME;
};

// STRUCT TEMPLATE is_member_function_pointer
template &lt;class _Ty&gt;
struct _Is_memfunptr { // base class for member function pointer predicates
    using _Bool_type = false_type; // NB: members are user-visible via _Weak_types
};

#define _IS_MEMFUNPTR(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                            \
    template &lt;class _Ret, class _Arg0, class... _Types&gt;                                   \
    struct _Is_memfunptr&lt;_Ret (CALL_OPT _Arg0::*)(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT&gt; \
        : _Arg_types&lt;CV_OPT _Arg0*, _Types...&gt; {                                          \
        using _Bool_type = true_type;                                                     \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret _RESULT_TYPE_NAME;                 \
        using _Class_type = _Arg0;                                                        \
        using _Guide_type = enable_if&lt;!is_same_v&lt;int REF_OPT, int&amp;&amp;&gt;, _Ret(_Types...)&gt;;   \
    };

_MEMBER_CALL_CV_REF_NOEXCEPT(_IS_MEMFUNPTR)
#undef _IS_MEMFUNPTR

#define _IS_MEMFUNPTR_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                          \
    template &lt;class _Ret, class _Arg0, class... _Types&gt;                      \
    struct _Is_memfunptr&lt;_Ret (_Arg0::*)(_Types..., ...)                     \
            CV_REF_NOEXCEPT_OPT&gt; { /* no calling conventions for ellipsis */ \
        using _Bool_type = true_type;                                        \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret _RESULT_TYPE_NAME;    \
        using _Class_type = _Arg0;                                           \
        using _Guide_type = enable_if&lt;false&gt;;                                \
    };

_CLASS_DEFINE_CV_REF_NOEXCEPT(_IS_MEMFUNPTR_ELLIPSIS)
#undef _IS_MEMFUNPTR_ELLIPSIS

#ifdef __clang__
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_function_pointer_v = __is_member_function_pointer(_Ty);
#else // ^^^ Clang ^^^ / vvv Other vvv
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_function_pointer_v = _Is_memfunptr&lt;remove_cv_t&lt;_Ty&gt;&gt;::_Bool_type::value;
#endif // ^^^ Other ^^^

template &lt;class _Ty&gt;
struct is_member_function_pointer : bool_constant&lt;is_member_function_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_const
template &lt;class&gt;
_INLINE_VAR constexpr bool is_const_v = false; // determine whether type argument is const qualified

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_const_v&lt;const _Ty&gt; = true;

template &lt;class _Ty&gt;
struct is_const : bool_constant&lt;is_const_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_volatile
template &lt;class&gt;
_INLINE_VAR constexpr bool is_volatile_v = false; // determine whether type argument is volatile qualified

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_volatile_v&lt;volatile _Ty&gt; = true;

template &lt;class _Ty&gt;
struct is_volatile : bool_constant&lt;is_volatile_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_function
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_function_v = // only function types and reference types can't be const qualified
    !is_const_v&lt;const _Ty&gt; &amp;&amp; !is_reference_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_function : bool_constant&lt;is_function_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_object
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_object_v = // only function types and reference types can't be const qualified
    is_const_v&lt;const _Ty&gt; &amp;&amp; !is_void_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_object : bool_constant&lt;is_object_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_member_object_pointer
template &lt;class&gt;
struct _Is_member_object_pointer {
    static constexpr bool value = false;
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Is_member_object_pointer&lt;_Ty1 _Ty2::*&gt; {
    static constexpr bool value = !is_function_v&lt;_Ty1&gt;;
    using _Class_type           = _Ty2;
};

#ifdef __clang__
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_object_pointer_v = __is_member_object_pointer(_Ty);
#else // ^^^ Clang / Other vvv
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_object_pointer_v = _Is_member_object_pointer&lt;remove_cv_t&lt;_Ty&gt;&gt;::value;
#endif // ^^^ Other ^^^

template &lt;class _Ty&gt;
struct is_member_object_pointer : bool_constant&lt;is_member_object_pointer_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_member_pointer
#ifdef __clang__
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_pointer_v = __is_member_pointer(_Ty);
#else // ^^^ Clang / Other vvv
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_member_pointer_v = is_member_object_pointer_v&lt;_Ty&gt; || is_member_function_pointer_v&lt;_Ty&gt;;
#endif // ^^^ Other ^^^

template &lt;class _Ty&gt;
struct is_member_pointer : bool_constant&lt;is_member_pointer_v&lt;_Ty&gt;&gt; {}; // determine whether _Ty is a pointer to member

// STRUCT TEMPLATE is_scalar
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_scalar_v = // determine whether _Ty is a scalar type
    is_arithmetic_v&lt;_Ty&gt; || is_enum_v&lt;_Ty&gt; || is_pointer_v&lt;_Ty&gt; || is_member_pointer_v&lt;_Ty&gt; || is_null_pointer_v&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct is_scalar : bool_constant&lt;is_scalar_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE is_pod
template &lt;class _Ty&gt;
struct _CXX20_DEPRECATE_IS_POD is_pod : bool_constant&lt;__is_pod(_Ty)&gt; {}; // determine whether _Ty is a POD type

template &lt;class _Ty&gt;
_CXX20_DEPRECATE_IS_POD _INLINE_VAR constexpr bool is_pod_v = __is_pod(_Ty);

// STRUCT TEMPLATE is_empty
template &lt;class _Ty&gt;
struct is_empty : bool_constant&lt;__is_empty(_Ty)&gt; {}; // determine whether _Ty is an empty class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_empty_v = __is_empty(_Ty);

// STRUCT TEMPLATE is_polymorphic
template &lt;class _Ty&gt;
struct is_polymorphic : bool_constant&lt;__is_polymorphic(_Ty)&gt; {}; // determine whether _Ty is a polymorphic type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

// STRUCT TEMPLATE is_abstract
template &lt;class _Ty&gt;
struct is_abstract : bool_constant&lt;__is_abstract(_Ty)&gt; {}; // determine whether _Ty is an abstract class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_abstract_v = __is_abstract(_Ty);

// STRUCT TEMPLATE is_final
template &lt;class _Ty&gt;
struct is_final : bool_constant&lt;__is_final(_Ty)&gt; {}; // determine whether _Ty is a final class

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_final_v = __is_final(_Ty);

// STRUCT TEMPLATE is_standard_layout
template &lt;class _Ty&gt;
struct is_standard_layout : bool_constant&lt;__is_standard_layout(_Ty)&gt; {}; // determine whether _Ty is standard layout

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);

#if _HAS_DEPRECATED_IS_LITERAL_TYPE
// STRUCT TEMPLATE is_literal_type
template &lt;class _Ty&gt;
struct _CXX17_DEPRECATE_IS_LITERAL_TYPE is_literal_type : bool_constant&lt;__is_literal_type(_Ty)&gt; {
    // determine whether _Ty is a literal type
};

template &lt;class _Ty&gt;
_CXX17_DEPRECATE_IS_LITERAL_TYPE _INLINE_VAR constexpr bool is_literal_type_v = __is_literal_type(_Ty);
#endif // _HAS_DEPRECATED_IS_LITERAL_TYPE

// STRUCT TEMPLATE is_trivial
#if 1 // TRANSITION, VSO-119526 and LLVM-41915
template &lt;class _Ty&gt;
struct is_trivial : bool_constant&lt;__is_trivially_constructible(_Ty) &amp;&amp; __is_trivially_copyable(_Ty)&gt; {
    // determine whether _Ty is a trivial type
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) &amp;&amp; __is_trivially_copyable(_Ty);
#else // ^^^ workaround / no workaround vvv
template &lt;class _Ty&gt;
struct is_trivial : bool_constant&lt;__is_trivial(_Ty)&gt; {}; // determine whether _Ty is a trivial type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivial_v = __is_trivial(_Ty);
#endif // TRANSITION

// STRUCT TEMPLATE is_trivially_copyable
template &lt;class _Ty&gt;
struct is_trivially_copyable : bool_constant&lt;__is_trivially_copyable(_Ty)&gt; {
    // determine whether _Ty is a trivially copyable type
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

// STRUCT TEMPLATE has_virtual_destructor
template &lt;class _Ty&gt;
struct has_virtual_destructor : bool_constant&lt;__has_virtual_destructor(_Ty)&gt; {
    // determine whether _Ty has a virtual destructor
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);

#if _HAS_CXX17
// STRUCT TEMPLATE has_unique_object_representations
template &lt;class _Ty&gt;
struct has_unique_object_representations : bool_constant&lt;__has_unique_object_representations(_Ty)&gt; {
    // determine whether _Ty has unique object representations
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool has_unique_object_representations_v = __has_unique_object_representations(_Ty);

// STRUCT TEMPLATE is_aggregate
template &lt;class _Ty&gt;
struct is_aggregate : bool_constant&lt;__is_aggregate(_Ty)&gt; {}; // determine whether _Ty is an aggregate

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_aggregate_v = __is_aggregate(_Ty);
#endif // _HAS_CXX17

// CONSTRUCTIBLE/ASSIGNABLE TRAITS
// STRUCT TEMPLATE is_constructible
template &lt;class _Ty, class... _Args&gt;
struct is_constructible : bool_constant&lt;__is_constructible(_Ty, _Args...)&gt; {
    // determine whether _Ty can be direct-initialized with _Args...
};

template &lt;class _Ty, class... _Args&gt;
_INLINE_VAR constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_copy_constructible
template &lt;class _Ty&gt;
struct is_copy_constructible : bool_constant&lt;__is_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether _Ty can be direct-initialized with an lvalue const _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_default_constructible
template &lt;class _Ty&gt;
struct is_default_constructible : bool_constant&lt;__is_constructible(_Ty)&gt; {
    // determine whether _Ty can be value-initialized
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_default_constructible_v = __is_constructible(_Ty);

// STRUCT TEMPLATE _Is_implicitly_default_constructible
template &lt;class _Ty, class = void&gt;
struct _Is_implicitly_default_constructible : false_type {
    // determine whether _Ty can be copy-initialized with {}
};

template &lt;class _Ty&gt;
void _Implicitly_default_construct(const _Ty&amp;);

template &lt;class _Ty&gt;
struct _Is_implicitly_default_constructible&lt;_Ty, void_t&lt;decltype(_Implicitly_default_construct&lt;_Ty&gt;({}))&gt;&gt; : true_type {
};

// STRUCT TEMPLATE is_move_constructible
template &lt;class _Ty&gt;
struct is_move_constructible : bool_constant&lt;__is_constructible(_Ty, _Ty)&gt; {
    // determine whether _Ty can be direct-initialized from an rvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_assignable
template &lt;class _To, class _From&gt;
struct is_assignable : bool_constant&lt;__is_assignable(_To, _From)&gt; {}; // determine whether _From can be assigned to _To

template &lt;class _To, class _From&gt;
_INLINE_VAR constexpr bool is_assignable_v = __is_assignable(_To, _From);

// STRUCT TEMPLATE is_copy_assignable
template &lt;class _Ty&gt;
struct is_copy_assignable
    : bool_constant&lt;__is_assignable(add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether an lvalue const _Ty can be assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_copy_assignable_v = __is_assignable(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)
template &lt;class _Ty&gt;
struct _Is_copy_assignable_no_precondition_check
    : bool_constant&lt;__is_assignable_no_precondition_check(
          add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_copy_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template &lt;class _Ty&gt;
using _Is_copy_assignable_no_precondition_check = is_copy_assignable&lt;_Ty&gt;;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_copy_assignable_unchecked_v = is_copy_assignable_v&lt;_Ty&gt;;
#endif // defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)

// STRUCT TEMPLATE is_move_assignable
template &lt;class _Ty&gt;
struct is_move_assignable : bool_constant&lt;__is_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {
    // determine whether an rvalue _Ty can be assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty);

#if defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)
template &lt;class _Ty&gt;
struct _Is_move_assignable_no_precondition_check
    : bool_constant&lt;__is_assignable_no_precondition_check(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(
    add_lvalue_reference_t&lt;_Ty&gt;, _Ty);
#else // ^^^ Use intrinsic / intrinsic not supported vvv
template &lt;class _Ty&gt;
using _Is_move_assignable_no_precondition_check = is_move_assignable&lt;_Ty&gt;;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_move_assignable_unchecked_v = is_move_assignable_v&lt;_Ty&gt;;
#endif // defined(_IS_ASSIGNABLE_NOCHECK_SUPPORTED) &amp;&amp; !defined(__CUDACC__)

// STRUCT TEMPLATE is_destructible
template &lt;class _Ty&gt;
struct is_destructible : bool_constant&lt;__is_destructible(_Ty)&gt; {
    // true iff remove_all_extents_t&lt;_Ty&gt; is a reference type, or can be explicitly destroyed
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_destructible_v = __is_destructible(_Ty);

// TRIVIAL TRAITS
// STRUCT TEMPLATE is_trivially_constructible
template &lt;class _Ty, class... _Args&gt;
struct is_trivially_constructible : bool_constant&lt;__is_trivially_constructible(_Ty, _Args...)&gt; {
    // determine whether direct-initialization of _Ty with _Args... is trivial
};

template &lt;class _Ty, class... _Args&gt;
_INLINE_VAR constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_trivially_copy_constructible
template &lt;class _Ty&gt;
struct is_trivially_copy_constructible
    : bool_constant&lt;__is_trivially_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether direct-initialization of _Ty with an lvalue const _Ty is trivial
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(
    _Ty, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_trivially_default_constructible
template &lt;class _Ty&gt;
struct is_trivially_default_constructible : bool_constant&lt;__is_trivially_constructible(_Ty)&gt; {
    // determine whether value-initialization of _Ty is trivial
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

// STRUCT TEMPLATE is_trivially_move_constructible
template &lt;class _Ty&gt;
struct is_trivially_move_constructible : bool_constant&lt;__is_trivially_constructible(_Ty, _Ty)&gt; {
    // determine whether direct-initialization of _Ty with an rvalue _Ty is trivial
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_trivially_assignable
template &lt;class _To, class _From&gt;
struct is_trivially_assignable : bool_constant&lt;__is_trivially_assignable(_To, _From)&gt; {
    // determine whether _From can be trivially assigned to _To
};

template &lt;class _To, class _From&gt;
_INLINE_VAR constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

// STRUCT TEMPLATE is_trivially_copy_assignable
template &lt;class _Ty&gt;
struct is_trivially_copy_assignable
    : bool_constant&lt;__is_trivially_assignable(add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether an lvalue const _Ty can be trivially assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_copy_assignable_v = __is_trivially_assignable(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_trivially_move_assignable
template &lt;class _Ty&gt;
struct is_trivially_move_assignable : bool_constant&lt;__is_trivially_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {
    // determine whether an rvalue _Ty can be trivially assigned to an lvalue _Ty
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty);

// STRUCT TEMPLATE is_trivially_destructible
template &lt;class _Ty&gt;
struct is_trivially_destructible : bool_constant&lt;__is_trivially_destructible(_Ty)&gt; {
    // determine whether remove_all_extents_t&lt;_Ty&gt; is a reference type or can trivially be explicitly destroyed
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

// NOTHROW TRAITS
// STRUCT TEMPLATE is_nothrow_constructible
template &lt;class _Ty, class... _Args&gt;
struct is_nothrow_constructible : bool_constant&lt;__is_nothrow_constructible(_Ty, _Args...)&gt; {
    // determine whether direct-initialization of _Ty from _Args... is both valid and not potentially-throwing
};

template &lt;class _Ty, class... _Args&gt;
_INLINE_VAR constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

// STRUCT TEMPLATE is_nothrow_copy_constructible
template &lt;class _Ty&gt;
struct is_nothrow_copy_constructible
    : bool_constant&lt;__is_nothrow_constructible(_Ty, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether direct-initialization of _Ty from an lvalue const _Ty is both valid
    // and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(
    _Ty, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_nothrow_default_constructible
template &lt;class _Ty&gt;
struct is_nothrow_default_constructible : bool_constant&lt;__is_nothrow_constructible(_Ty)&gt; {
    // determine whether value-initialization of _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

// STRUCT TEMPLATE is_nothrow_move_constructible
template &lt;class _Ty&gt;
struct is_nothrow_move_constructible : bool_constant&lt;__is_nothrow_constructible(_Ty, _Ty)&gt; {
    // determine whether direct-initialization of _Ty from an rvalue _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

// STRUCT TEMPLATE is_nothrow_assignable
template &lt;class _To, class _From&gt;
struct is_nothrow_assignable : bool_constant&lt;__is_nothrow_assignable(_To, _From)&gt; {
    // determine whether assignment of _From to _To is both valid and not potentially-throwing
};

template &lt;class _To, class _From&gt;
_INLINE_VAR constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

// STRUCT TEMPLATE is_nothrow_copy_assignable
template &lt;class _Ty&gt;
struct is_nothrow_copy_assignable
    : bool_constant&lt;__is_nothrow_assignable(add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;)&gt; {
    // determine whether assignment of an lvalue const _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_copy_assignable_v = __is_nothrow_assignable(
    add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;const _Ty&gt;);

// STRUCT TEMPLATE is_nothrow_move_assignable
template &lt;class _Ty&gt;
struct is_nothrow_move_assignable : bool_constant&lt;__is_nothrow_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty)&gt; {
    // determine whether assignment of an rvalue _Ty to an lvalue _Ty is both valid and not potentially-throwing
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t&lt;_Ty&gt;, _Ty);

// STRUCT TEMPLATE is_nothrow_destructible
template &lt;class _Ty&gt;
struct is_nothrow_destructible : bool_constant&lt;__is_nothrow_destructible(_Ty)&gt; {
    // determine whether remove_all_extents_t&lt;_Ty&gt; is a reference type or has
    // non-potentially-throwing explicit destruction
};

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

// STRUCT TEMPLATE is_signed
template &lt;class _Ty, bool = is_integral_v&lt;_Ty&gt;&gt;
struct _Sign_base { // determine whether integral type _Ty is signed or unsigned
    using _Uty = remove_cv_t&lt;_Ty&gt;;

    static constexpr bool _Signed   = static_cast&lt;_Uty&gt;(-1) &lt; static_cast&lt;_Uty&gt;(0);
    static constexpr bool _Unsigned = !_Signed;
};

template &lt;class _Ty&gt;
struct _Sign_base&lt;_Ty, false&gt; { // floating-point _Ty is signed
                                // non-arithmetic _Ty is neither signed nor unsigned
    static constexpr bool _Signed   = is_floating_point_v&lt;_Ty&gt;;
    static constexpr bool _Unsigned = false;
};

template &lt;class _Ty&gt;
struct is_signed : bool_constant&lt;_Sign_base&lt;_Ty&gt;::_Signed&gt; {}; // determine whether _Ty is a signed type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_signed_v = _Sign_base&lt;_Ty&gt;::_Signed;

// STRUCT TEMPLATE is_unsigned
template &lt;class _Ty&gt;
struct is_unsigned : bool_constant&lt;_Sign_base&lt;_Ty&gt;::_Unsigned&gt; {}; // determine whether _Ty is an unsigned type

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool is_unsigned_v = _Sign_base&lt;_Ty&gt;::_Unsigned;

// VARIABLE TEMPLATE _Is_nonbool_integral
template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_nonbool_integral = is_integral_v&lt;_Ty&gt; &amp;&amp; !is_same_v&lt;remove_cv_t&lt;_Ty&gt;, bool&gt;;

// STRUCT TEMPLATE make_signed
template &lt;bool&gt;
struct _Select { // Select between aliases that extract either their first or second parameter
    template &lt;class _Ty1, class&gt;
    using _Apply = _Ty1;
};

template &lt;&gt;
struct _Select&lt;false&gt; {
    template &lt;class, class _Ty2&gt;
    using _Apply = _Ty2;
};

template &lt;size_t&gt;
struct _Make_signed2; // Choose make_signed strategy by type size

template &lt;&gt;
struct _Make_signed2&lt;1&gt; {
    template &lt;class&gt;
    using _Apply = signed char;
};

template &lt;&gt;
struct _Make_signed2&lt;2&gt; {
    template &lt;class&gt;
    using _Apply = short;
};

template &lt;&gt;
struct _Make_signed2&lt;4&gt; {
    template &lt;class _Ty&gt;
    using _Apply = // assumes LLP64
        typename _Select&lt;is_same_v&lt;_Ty, long&gt; || is_same_v&lt;_Ty, unsigned long&gt;&gt;::template _Apply&lt;long, int&gt;;
};

template &lt;&gt;
struct _Make_signed2&lt;8&gt; {
    template &lt;class&gt;
    using _Apply = long long;
};

template &lt;class _Ty&gt;
using _Make_signed1 = // signed partner to cv-unqualified _Ty
    typename _Make_signed2&lt;sizeof(_Ty)&gt;::template _Apply&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct make_signed { // signed partner to _Ty
    static_assert(_Is_nonbool_integral&lt;_Ty&gt; || is_enum_v&lt;_Ty&gt;,
        "make_signed&lt;T&gt; requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv&lt;_Ty&gt;::template _Apply&lt;_Make_signed1&gt;;
};

template &lt;class _Ty&gt;
using make_signed_t = typename make_signed&lt;_Ty&gt;::type;

// STRUCT TEMPLATE make_unsigned
template &lt;size_t&gt;
struct _Make_unsigned2; // Choose make_unsigned strategy by type size

template &lt;&gt;
struct _Make_unsigned2&lt;1&gt; {
    template &lt;class&gt;
    using _Apply = unsigned char;
};

template &lt;&gt;
struct _Make_unsigned2&lt;2&gt; {
    template &lt;class&gt;
    using _Apply = unsigned short;
};

template &lt;&gt;
struct _Make_unsigned2&lt;4&gt; {
    template &lt;class _Ty&gt;
    using _Apply = // assumes LLP64
        typename _Select&lt;is_same_v&lt;_Ty, long&gt; || is_same_v&lt;_Ty, unsigned long&gt;&gt;::template _Apply&lt;unsigned long,
            unsigned int&gt;;
};

template &lt;&gt;
struct _Make_unsigned2&lt;8&gt; {
    template &lt;class&gt;
    using _Apply = unsigned long long;
};

template &lt;class _Ty&gt;
using _Make_unsigned1 = // unsigned partner to cv-unqualified _Ty
    typename _Make_unsigned2&lt;sizeof(_Ty)&gt;::template _Apply&lt;_Ty&gt;;

template &lt;class _Ty&gt;
struct make_unsigned { // unsigned partner to _Ty
    static_assert(_Is_nonbool_integral&lt;_Ty&gt; || is_enum_v&lt;_Ty&gt;,
        "make_unsigned&lt;T&gt; requires that T shall be a (possibly cv-qualified) "
        "integral type or enumeration but not a bool type.");

    using type = typename remove_cv&lt;_Ty&gt;::template _Apply&lt;_Make_unsigned1&gt;;
};

template &lt;class _Ty&gt;
using make_unsigned_t = typename make_unsigned&lt;_Ty&gt;::type;

// FUNCTION TEMPLATE _Unsigned_value
template &lt;class _Rep&gt;
constexpr make_unsigned_t&lt;_Rep&gt; _Unsigned_value(_Rep _Val) { // makes _Val unsigned
    return static_cast&lt;make_unsigned_t&lt;_Rep&gt;&gt;(_Val);
}

// STRUCT TEMPLATE alignment_of
template &lt;class _Ty&gt;
struct alignment_of : integral_constant&lt;size_t, alignof(_Ty)&gt; {}; // determine alignment of _Ty

template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t alignment_of_v = alignof(_Ty);

// STRUCT TEMPLATE aligned_storage
template &lt;class _Ty, size_t _Len&gt;
union _Align_type { // union with size _Len bytes and alignment of _Ty
    _Ty _Val;
    char _Pad[_Len];
};

template &lt;size_t _Len, size_t _Align, class _Ty, bool _Ok&gt;
struct _Aligned; // define type with size _Len and alignment _Ty

template &lt;size_t _Len, size_t _Align, class _Ty&gt;
struct _Aligned&lt;_Len, _Align, _Ty, true&gt; {
    using type = _Align_type&lt;_Ty, _Len&gt;;
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, double, false&gt; {
#ifdef _ENABLE_EXTENDED_ALIGNED_STORAGE
    struct type {
        alignas(_Align) char _Space[_Len];
    };
#else // ^^^ _ENABLE_EXTENDED_ALIGNED_STORAGE / !_ENABLE_EXTENDED_ALIGNED_STORAGE vvv
#ifndef _DISABLE_EXTENDED_ALIGNED_STORAGE
    static_assert(_Always_false&lt;_Aligned&gt;,
        "You've instantiated std::aligned_storage&lt;Len, Align&gt; with an extended alignment (in other "
        "words, Align &gt; alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
        "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
        "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
        "(*only* for uses of aligned_storage with extended alignments). "
        "Please define either "
        "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
        "that you actually want a type with an extended alignment, or "
        "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
        "behavior.");
#endif // !_DISABLE_EXTENDED_ALIGNED_STORAGE
    using type = _Align_type&lt;max_align_t, _Len&gt;;
#endif // _ENABLE_EXTENDED_ALIGNED_STORAGE
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, int, false&gt; {
    using _Next                 = double;
    static constexpr bool _Fits = _Align &lt;= alignof(_Next);
    using type                  = typename _Aligned&lt;_Len, _Align, _Next, _Fits&gt;::type;
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, short, false&gt; {
    using _Next                 = int;
    static constexpr bool _Fits = _Align &lt;= alignof(_Next);
    using type                  = typename _Aligned&lt;_Len, _Align, _Next, _Fits&gt;::type;
};

template &lt;size_t _Len, size_t _Align&gt;
struct _Aligned&lt;_Len, _Align, char, false&gt; {
    using _Next                 = short;
    static constexpr bool _Fits = _Align &lt;= alignof(_Next);
    using type                  = typename _Aligned&lt;_Len, _Align, _Next, _Fits&gt;::type;
};

template &lt;size_t _Len, size_t _Align = alignof(max_align_t)&gt;
struct aligned_storage { // define type with size _Len and alignment _Align
    using _Next                 = char;
    static constexpr bool _Fits = _Align &lt;= alignof(_Next);
    using type                  = typename _Aligned&lt;_Len, _Align, _Next, _Fits&gt;::type;
};

template &lt;size_t _Len, size_t _Align = alignof(max_align_t)&gt;
using aligned_storage_t = typename aligned_storage&lt;_Len, _Align&gt;::type;

// STRUCT TEMPLATE aligned_union
template &lt;size_t... _Vals&gt;
struct _Maximum;

template &lt;&gt;
struct _Maximum&lt;&gt; : integral_constant&lt;size_t, 0&gt; {}; // maximum of nothing is 0

template &lt;size_t _Val&gt;
struct _Maximum&lt;_Val&gt; : integral_constant&lt;size_t, _Val&gt; {}; // maximum of _Val is _Val

template &lt;size_t _First, size_t _Second, size_t... _Rest&gt;
struct _Maximum&lt;_First, _Second, _Rest...&gt; : _Maximum&lt;(_First &lt; _Second ? _Second : _First), _Rest...&gt;::type {
    // find maximum value in _First, _Second, _Rest...
};

template &lt;size_t _Len, class... _Types&gt;
struct aligned_union { // define type with size at least _Len, for storing anything in _Types
    static constexpr size_t _Max_len        = _Maximum&lt;_Len, sizeof(_Types)...&gt;::value; // NOT sizeof...(_Types)
    static constexpr size_t alignment_value = _Maximum&lt;alignof(_Types)...&gt;::value;

    using type = aligned_storage_t&lt;_Max_len, alignment_value&gt;;
};

template &lt;size_t _Len, class... _Types&gt;
using aligned_union_t = typename aligned_union&lt;_Len, _Types...&gt;::type;

// STRUCT TEMPLATE underlying_type
template &lt;class _Ty, bool = is_enum_v&lt;_Ty&gt;&gt;
struct _Underlying_type {
    using type = __underlying_type(_Ty);
};

template &lt;class _Ty&gt;
struct _Underlying_type&lt;_Ty, false&gt; {};

template &lt;class _Ty&gt;
struct underlying_type : _Underlying_type&lt;_Ty&gt; {}; // determine underlying type for enum

template &lt;class _Ty&gt;
using underlying_type_t = typename _Underlying_type&lt;_Ty&gt;::type;

// STRUCT TEMPLATE rank
template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t rank_v = 0; // determine number of dimensions of array _Ty

template &lt;class _Ty, size_t _Nx&gt;
_INLINE_VAR constexpr size_t rank_v&lt;_Ty[_Nx]&gt; = rank_v&lt;_Ty&gt; + 1;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr size_t rank_v&lt;_Ty[]&gt; = rank_v&lt;_Ty&gt; + 1;

template &lt;class _Ty&gt;
struct rank : integral_constant&lt;size_t, rank_v&lt;_Ty&gt;&gt; {};

// STRUCT TEMPLATE extent
template &lt;class _Ty, unsigned int _Ix = 0&gt;
_INLINE_VAR constexpr size_t extent_v = 0; // determine extent of dimension _Ix of array _Ty

template &lt;class _Ty, size_t _Nx&gt;
_INLINE_VAR constexpr size_t extent_v&lt;_Ty[_Nx], 0&gt; = _Nx;

template &lt;class _Ty, unsigned int _Ix, size_t _Nx&gt;
_INLINE_VAR constexpr size_t extent_v&lt;_Ty[_Nx], _Ix&gt; = extent_v&lt;_Ty, _Ix - 1&gt;;

template &lt;class _Ty, unsigned int _Ix&gt;
_INLINE_VAR constexpr size_t extent_v&lt;_Ty[], _Ix&gt; = extent_v&lt;_Ty, _Ix - 1&gt;;

template &lt;class _Ty, unsigned int _Ix = 0&gt;
struct extent : integral_constant&lt;size_t, extent_v&lt;_Ty, _Ix&gt;&gt; {};

// STRUCT TEMPLATE is_base_of
template &lt;class _Base, class _Derived&gt;
struct is_base_of : bool_constant&lt;__is_base_of(_Base, _Derived)&gt; {
    // determine whether _Base is a base of or the same as _Derived
};

template &lt;class _Base, class _Derived&gt;
_INLINE_VAR constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

// STRUCT TEMPLATE decay
template &lt;class _Ty&gt;
struct decay { // determines decayed version of _Ty
    using _Ty1 = remove_reference_t&lt;_Ty&gt;;
    using _Ty2 = typename _Select&lt;is_function_v&lt;_Ty1&gt;&gt;::template _Apply&lt;add_pointer&lt;_Ty1&gt;, remove_cv&lt;_Ty1&gt;&gt;;
    using type = typename _Select&lt;is_array_v&lt;_Ty1&gt;&gt;::template _Apply&lt;add_pointer&lt;remove_extent_t&lt;_Ty1&gt;&gt;, _Ty2&gt;::type;
};

template &lt;class _Ty&gt;
using decay_t = typename decay&lt;_Ty&gt;::type;

// ALIAS TEMPLATE _Conditional_type
template &lt;class _Ty1, class _Ty2&gt;
using _Conditional_type = decltype(false ? _STD declval&lt;_Ty1&gt;() : _STD declval&lt;_Ty2&gt;());

// STRUCT TEMPLATE common_type
#if _HAS_CXX20
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Const_lvalue_cond_oper {};

// N4810 [meta.trans.other]/3.3.4 (per the proposed resolution of LWG-3205): "Otherwise, if remove_cvref_t&lt;/**/&gt; denotes
// a type..."
template &lt;class _Ty1, class _Ty2&gt;
struct _Const_lvalue_cond_oper&lt;_Ty1, _Ty2, void_t&lt;_Conditional_type&lt;const _Ty1&amp;, const _Ty2&amp;&gt;&gt;&gt; {
    using type = remove_cvref_t&lt;_Conditional_type&lt;const _Ty1&amp;, const _Ty2&amp;&gt;&gt;;
};

template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Decayed_cond_oper : _Const_lvalue_cond_oper&lt;_Ty1, _Ty2&gt; {};
#else // ^^^ &gt;= C++20 / &lt;= C++17 vvv
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Decayed_cond_oper {};
#endif // _HAS_CXX20

template &lt;class _Ty1, class _Ty2&gt;
struct _Decayed_cond_oper&lt;_Ty1, _Ty2, void_t&lt;_Conditional_type&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = decay_t&lt;_Conditional_type&lt;_Ty1, _Ty2&gt;&gt;;
};

template &lt;class... _Ty&gt;
struct common_type;

template &lt;class... _Ty&gt;
using common_type_t = typename common_type&lt;_Ty...&gt;::type;

template &lt;&gt;
struct common_type&lt;&gt; {};

template &lt;class _Ty1&gt;
struct common_type&lt;_Ty1&gt; : common_type&lt;_Ty1, _Ty1&gt; {};

template &lt;class _Ty1, class _Ty2, class _Decayed1 = decay_t&lt;_Ty1&gt;, class _Decayed2 = decay_t&lt;_Ty2&gt;&gt;
struct _Common_type2 : common_type&lt;_Decayed1, _Decayed2&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_type2&lt;_Ty1, _Ty2, _Ty1, _Ty2&gt; : _Decayed_cond_oper&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
struct common_type&lt;_Ty1, _Ty2&gt; : _Common_type2&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Void, class _Ty1, class _Ty2, class... _Rest&gt;
struct _Common_type3 {};

template &lt;class _Ty1, class _Ty2, class... _Rest&gt;
struct _Common_type3&lt;void_t&lt;common_type_t&lt;_Ty1, _Ty2&gt;&gt;, _Ty1, _Ty2, _Rest...&gt;
    : common_type&lt;common_type_t&lt;_Ty1, _Ty2&gt;, _Rest...&gt; {};

template &lt;class _Ty1, class _Ty2, class... _Rest&gt;
struct common_type&lt;_Ty1, _Ty2, _Rest...&gt; : _Common_type3&lt;void, _Ty1, _Ty2, _Rest...&gt; {};

#if _HAS_CXX20
// STRUCT TEMPLATE basic_common_reference
template &lt;class, class, template &lt;class&gt; class, template &lt;class&gt; class&gt;
struct basic_common_reference {};

// FUNCTION TEMPLATE _Returns_exactly
template &lt;class _Ty&gt;
_Ty _Returns_exactly() noexcept; // not defined

// ALIAS TEMPLATE _Cond_res
template &lt;class _Ty1, class _Ty2&gt;
using _Cond_res = // N4810 [meta.trans.other]/2.4
    decltype(false ? _Returns_exactly&lt;_Ty1&gt;() : _Returns_exactly&lt;_Ty2&gt;());

// ALIAS TEMPLATE _Copy_cv
template &lt;class _From&gt;
struct _Copy_cv_impl {
    template &lt;class _To&gt;
    using _Apply = _To;
};
template &lt;class _From&gt;
struct _Copy_cv_impl&lt;const _From&gt; {
    template &lt;class _To&gt;
    using _Apply = const _To;
};
template &lt;class _From&gt;
struct _Copy_cv_impl&lt;volatile _From&gt; {
    template &lt;class _To&gt;
    using _Apply = volatile _To;
};
template &lt;class _From&gt;
struct _Copy_cv_impl&lt;const volatile _From&gt; {
    template &lt;class _To&gt;
    using _Apply = const volatile _To;
};
template &lt;class _From, class _To&gt;
using _Copy_cv = // N4810 [meta.trans.other]/2.3
    typename _Copy_cv_impl&lt;_From&gt;::template _Apply&lt;_To&gt;;

// STRUCT TEMPLATE _Add_qualifiers
template &lt;class _Ty1&gt;
struct _Add_qualifiers { // _Add_qualifiers&lt;A&gt;::template _Apply is XREF(A) from N4810 [meta.trans.other]/2.1
    template &lt;class _Ty2&gt;
    using _Apply = _Copy_cv&lt;_Ty1, _Ty2&gt;;
};
template &lt;class _Ty1&gt;
struct _Add_qualifiers&lt;_Ty1&amp;&gt; {
    template &lt;class _Ty2&gt;
    using _Apply = add_lvalue_reference_t&lt;_Copy_cv&lt;_Ty1, _Ty2&gt;&gt;;
};
template &lt;class _Ty1&gt;
struct _Add_qualifiers&lt;_Ty1&amp;&amp;&gt; {
    template &lt;class _Ty2&gt;
    using _Apply = add_rvalue_reference_t&lt;_Copy_cv&lt;_Ty1, _Ty2&gt;&gt;;
};

// STRUCT TEMPLATE common_reference
template &lt;class...&gt;
struct common_reference;

// ALIAS TEMPLATE common_reference_t
template &lt;class... _Types&gt;
using common_reference_t = typename common_reference&lt;_Types...&gt;::type;

// N4810 [meta.trans.other]/5.1: "If sizeof...(T) is zero ..."
template &lt;&gt;
struct common_reference&lt;&gt; {};

// N4810 [meta.trans.other]/5.2: "...if sizeof...(T) is one ..."
template &lt;class _Ty&gt;
struct common_reference&lt;_Ty&gt; {
    using type = _Ty;
};

// N4810 [meta.trans.other]/5.3: "...if sizeof...(T) is two..."

// N4810 [meta.trans.other]/5.3.4: "if common_type_t&lt;T1, T2&gt; is well-formed..."
// N4810 [meta.trans.other]/5.3.5: "Otherwise, there shall be no member type."
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Common_reference2C : common_type&lt;_Ty1, _Ty2&gt; {};

// N4810 [meta.trans.other]/5.3.3: "if COND_RES(T1, T2) is well-formed..."
template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2C&lt;_Ty1, _Ty2, void_t&lt;_Cond_res&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = _Cond_res&lt;_Ty1, _Ty2&gt;;
};

// N4810 [meta.trans.other]/5.3.2: "if basic_common_reference&lt;[...]&gt;::type is well-formed..."
template &lt;class _Ty1, class _Ty2&gt;
using _Basic_specialization = typename basic_common_reference&lt;remove_cvref_t&lt;_Ty1&gt;, remove_cvref_t&lt;_Ty2&gt;,
    _Add_qualifiers&lt;_Ty1&gt;::template _Apply, _Add_qualifiers&lt;_Ty2&gt;::template _Apply&gt;::type;

template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Common_reference2B : _Common_reference2C&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2B&lt;_Ty1, _Ty2, void_t&lt;_Basic_specialization&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = _Basic_specialization&lt;_Ty1, _Ty2&gt;;
};

// N4810 [meta.trans.other]/5.3.1: "If T1 and T2 are reference types and COMMON_REF(T1, T2) is well-formed..."
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Common_reference2A : _Common_reference2B&lt;_Ty1, _Ty2&gt; {};

template &lt;class _Ty1, class _Ty2, class _Result = _Cond_res&lt;_Copy_cv&lt;_Ty1, _Ty2&gt;&amp;, _Copy_cv&lt;_Ty2, _Ty1&gt;&amp;&gt;,
#ifdef __EDG__ // TRANSITION, VSO-948614
    enable_if_t&lt;is_lvalue_reference&lt;_Result&gt;::value, int&gt; = 0&gt;
#else // ^^^ workaround / no workaround vvv
    enable_if_t&lt;is_lvalue_reference_v&lt;_Result&gt;, int&gt; = 0&gt;
#endif // TRANSITION, VSO-948614
using _LL_common_ref = _Result;

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;, _Ty2&amp;, void_t&lt;_LL_common_ref&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    using type = _LL_common_ref&lt;_Ty1, _Ty2&gt;; // "both lvalues" case from N4810 [meta.trans.other]/2.5
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;&amp;, _Ty2&amp;, enable_if_t&lt;is_convertible_v&lt;_Ty1&amp;&amp;, _LL_common_ref&lt;const _Ty1, _Ty2&gt;&gt;&gt;&gt; {
    using type = _LL_common_ref&lt;const _Ty1, _Ty2&gt;; // "rvalue and lvalue" case from N4810 [meta.trans.other]/2.7
};

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;, _Ty2&amp;&amp;, enable_if_t&lt;is_convertible_v&lt;_Ty2&amp;&amp;, _LL_common_ref&lt;const _Ty2, _Ty1&gt;&gt;&gt;&gt; {
    using type = _LL_common_ref&lt;const _Ty2, _Ty1&gt;; // "lvalue and rvalue" case from N4810 [meta.trans.other]/2.8
};

template &lt;class _Ty1, class _Ty2&gt;
using _RR_common_ref = remove_reference_t&lt;_LL_common_ref&lt;_Ty1, _Ty2&gt;&gt;&amp;&amp;;

template &lt;class _Ty1, class _Ty2&gt;
struct _Common_reference2A&lt;_Ty1&amp;&amp;, _Ty2&amp;&amp;,
    enable_if_t&lt;
        is_convertible_v&lt;_Ty1&amp;&amp;, _RR_common_ref&lt;_Ty1, _Ty2&gt;&gt; &amp;&amp; is_convertible_v&lt;_Ty2&amp;&amp;, _RR_common_ref&lt;_Ty1, _Ty2&gt;&gt;&gt;&gt; {
    using type = _RR_common_ref&lt;_Ty1, _Ty2&gt;; // "both rvalues" case from N4810 [meta.trans.other]/2.6
};

template &lt;class _Ty1, class _Ty2&gt;
struct common_reference&lt;_Ty1, _Ty2&gt; : _Common_reference2A&lt;_Ty1, _Ty2&gt; {};

// N4810 [meta.trans.other]/5.4: "if sizeof...(T) is greater than two..."
template &lt;class _Void, class _Ty1, class _Ty2, class... _Types&gt;
struct _Fold_common_reference {};
template &lt;class _Ty1, class _Ty2, class... _Types&gt;
struct _Fold_common_reference&lt;void_t&lt;common_reference_t&lt;_Ty1, _Ty2&gt;&gt;, _Ty1, _Ty2, _Types...&gt;
    : common_reference&lt;common_reference_t&lt;_Ty1, _Ty2&gt;, _Types...&gt; {};

template &lt;class _Ty1, class _Ty2, class _Ty3, class... _Rest&gt;
struct common_reference&lt;_Ty1, _Ty2, _Ty3, _Rest...&gt; : _Fold_common_reference&lt;void, _Ty1, _Ty2, _Ty3, _Rest...&gt; {};
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Identity
template &lt;class _Ty&gt;
struct _Identity {
    using type = _Ty;
};
template &lt;class _Ty&gt;
using _Identity_t = typename _Identity&lt;_Ty&gt;::type;

#if _HAS_CXX20
// STRUCT TEMPLATE type_identity
template &lt;class _Ty&gt;
struct type_identity {
    using type = _Ty;
};
template &lt;class _Ty&gt;
using type_identity_t = typename type_identity&lt;_Ty&gt;::type;
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Is_specialization
template &lt;class _Type, template &lt;class...&gt; class _Template&gt;
_INLINE_VAR constexpr bool _Is_specialization_v = false; // true if and only if _Type is a specialization of _Template
template &lt;template &lt;class...&gt; class _Template, class... _Types&gt;
_INLINE_VAR constexpr bool _Is_specialization_v&lt;_Template&lt;_Types...&gt;, _Template&gt; = true;

template &lt;class _Type, template &lt;class...&gt; class _Template&gt;
struct _Is_specialization : bool_constant&lt;_Is_specialization_v&lt;_Type, _Template&gt;&gt; {};

// FUNCTION TEMPLATE forward
template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty&amp;&amp; forward(
<span style = "background-color:#dfd">    remove_reference_t&lt;_Ty&gt;&amp; _Arg) noexcept { // forward an lvalue as either an lvalue or an rvalue
    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);
}</span>

template &lt;class _Ty&gt;
_NODISCARD constexpr _Ty&amp;&amp; forward(remove_reference_t&lt;_Ty&gt;&amp;&amp; _Arg) noexcept { // forward an rvalue as an rvalue
    static_assert(!is_lvalue_reference_v&lt;_Ty&gt;, "bad forward call");
    return static_cast&lt;_Ty&amp;&amp;&gt;(_Arg);
}

// FUNCTION TEMPLATE move
template &lt;class _Ty&gt;
<span style = "background-color:#dfd">_NODISCARD constexpr remove_reference_t&lt;_Ty&gt;&amp;&amp; move(_Ty&amp;&amp; _Arg) noexcept { // forward _Arg as movable
    return static_cast&lt;remove_reference_t&lt;_Ty&gt;&amp;&amp;&gt;(_Arg);
}</span>

// FUNCTION TEMPLATE move_if_noexcept
template &lt;class _Ty&gt;
_NODISCARD constexpr conditional_t&lt;!is_nothrow_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_copy_constructible_v&lt;_Ty&gt;, const _Ty&amp;,
    _Ty&amp;&amp;&gt;
    move_if_noexcept(_Ty&amp; _Arg) noexcept { // forward _Arg as movable, sometimes
    return _STD move(_Arg);
}

template &lt;class _Ty&gt;
class reference_wrapper;

// std::invoke isn't constexpr in C++17, and normally implementers are forbidden from "strengthening" constexpr
// (WG21-N4842 [constexpr.functions]/1), yet both std::apply and std::visit are required to be constexpr and have
// invoke-like behavior. As a result, we've chosen to apply the part of P1065R2 resolving LWG-2894 as a defect report.

// FUNCTION TEMPLATE invoke
#pragma warning(push) // TRANSITION, DevCom-936696
#pragma warning(disable : 28278) // Function '%s' appears with no prototype in scope
enum class _Invoker_strategy {
    _Functor,
    _Pmf_object,
    _Pmf_refwrap,
    _Pmf_pointer,
    _Pmd_object,
    _Pmd_refwrap,
    _Pmd_pointer
};

struct _Invoker_functor {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Functor;

    template &lt;class _Callable, class... _Types&gt;
    static constexpr auto _Call(_Callable&amp;&amp; _Obj, _Types&amp;&amp;... _Args) noexcept(
        noexcept(static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)(static_cast&lt;_Types&amp;&amp;&gt;(_Args)...)))
        -&gt; decltype(static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)(static_cast&lt;_Types&amp;&amp;&gt;(_Args)...)) {
        return static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)(static_cast&lt;_Types&amp;&amp;&gt;(_Args)...);
    }
};

struct _Invoker_pmf_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_object;

    template &lt;class _Decayed, class _Ty1, class... _Types2&gt;
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept(
        noexcept((static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)))
        -&gt; decltype((static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)) {
        return (static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    }
};

struct _Invoker_pmf_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_refwrap;

    template &lt;class _Decayed, class _Refwrap, class... _Types2&gt;
    static constexpr auto _Call(_Decayed _Pmf, _Refwrap _Rw, _Types2&amp;&amp;... _Args2) noexcept(
        noexcept((_Rw.get().*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)))
        -&gt; decltype((_Rw.get().*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)) {
        return (_Rw.get().*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    }
};

struct _Invoker_pmf_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmf_pointer;

    template &lt;class _Decayed, class _Ty1, class... _Types2&gt;
    static constexpr auto _Call(_Decayed _Pmf, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept(
        noexcept(((*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)))
        -&gt; decltype(((*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)) {
        return ((*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Pmf)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    }
};

struct _Invoker_pmd_object {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_object;

    template &lt;class _Decayed, class _Ty1&gt;
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&amp;&amp; _Arg1) noexcept -&gt; decltype(static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Pmd) {
        return static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Pmd;
    }
};

struct _Invoker_pmd_refwrap {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_refwrap;

    template &lt;class _Decayed, class _Refwrap&gt;
    static constexpr auto _Call(_Decayed _Pmd, _Refwrap _Rw) noexcept -&gt; decltype(_Rw.get().*_Pmd) {
        return _Rw.get().*_Pmd;
    }
};

struct _Invoker_pmd_pointer {
    static constexpr _Invoker_strategy _Strategy = _Invoker_strategy::_Pmd_pointer;

    template &lt;class _Decayed, class _Ty1&gt;
    static constexpr auto _Call(_Decayed _Pmd, _Ty1&amp;&amp; _Arg1) noexcept(noexcept((*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Pmd))
        -&gt; decltype((*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Pmd) {
        return (*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Pmd;
    }
};

template &lt;class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t&lt;_Callable&gt;,
    bool _Is_pmf = is_member_function_pointer_v&lt;_Removed_cvref&gt;,
    bool _Is_pmd = is_member_object_pointer_v&lt;_Removed_cvref&gt;&gt;
struct _Invoker1;

template &lt;class _Callable, class _Ty1, class _Removed_cvref&gt;
struct _Invoker1&lt;_Callable, _Ty1, _Removed_cvref, true, false&gt;
    : conditional_t&lt;is_base_of_v&lt;typename _Is_memfunptr&lt;_Removed_cvref&gt;::_Class_type, remove_reference_t&lt;_Ty1&gt;&gt;,
          _Invoker_pmf_object,
          conditional_t&lt;_Is_specialization_v&lt;_Remove_cvref_t&lt;_Ty1&gt;, reference_wrapper&gt;, _Invoker_pmf_refwrap,
              _Invoker_pmf_pointer&gt;&gt; {}; // pointer to member function

template &lt;class _Callable, class _Ty1, class _Removed_cvref&gt;
struct _Invoker1&lt;_Callable, _Ty1, _Removed_cvref, false, true&gt;
    : conditional_t&lt;
          is_base_of_v&lt;typename _Is_member_object_pointer&lt;_Removed_cvref&gt;::_Class_type, remove_reference_t&lt;_Ty1&gt;&gt;,
          _Invoker_pmd_object,
          conditional_t&lt;_Is_specialization_v&lt;_Remove_cvref_t&lt;_Ty1&gt;, reference_wrapper&gt;, _Invoker_pmd_refwrap,
              _Invoker_pmd_pointer&gt;&gt; {}; // pointer to member data

template &lt;class _Callable, class _Ty1, class _Removed_cvref&gt;
struct _Invoker1&lt;_Callable, _Ty1, _Removed_cvref, false, false&gt; : _Invoker_functor {};

template &lt;class _Callable&gt;
_CONSTEXPR17 auto invoke(_Callable&amp;&amp; _Obj) noexcept(noexcept(static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)()))
    -&gt; decltype(static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)()) {
    return static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)();
}

template &lt;class _Callable, class _Ty1, class... _Types2&gt;
_CONSTEXPR17 auto invoke(_Callable&amp;&amp; _Obj, _Ty1&amp;&amp; _Arg1, _Types2&amp;&amp;... _Args2) noexcept(
    noexcept(_Invoker1&lt;_Callable, _Ty1&gt;::_Call(
        static_cast&lt;_Callable&amp;&amp;&gt;(_Obj), static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1), static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)))
    -&gt; decltype(_Invoker1&lt;_Callable, _Ty1&gt;::_Call(
        static_cast&lt;_Callable&amp;&amp;&gt;(_Obj), static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1), static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...)) {
    if constexpr (_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Functor) {
        return static_cast&lt;_Callable&amp;&amp;&gt;(_Obj)(static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1), static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    } else if constexpr (_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Pmf_object) {
        return (static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Obj)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    } else if constexpr (_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Pmf_refwrap) {
        return (_Arg1.get().*_Obj)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    } else if constexpr (_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Pmf_pointer) {
        return ((*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Obj)(static_cast&lt;_Types2&amp;&amp;&gt;(_Args2)...);
    } else if constexpr (_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Pmd_object) {
        return static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1).*_Obj;
    } else if constexpr (_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Pmd_refwrap) {
        return _Arg1.get().*_Obj;
    } else {
        static_assert(_Invoker1&lt;_Callable, _Ty1&gt;::_Strategy == _Invoker_strategy::_Pmd_pointer, "bug in invoke");
        return (*static_cast&lt;_Ty1&amp;&amp;&gt;(_Arg1)).*_Obj;
    }
}
#pragma warning(pop) // TRANSITION, DevCom-936696

// TYPE TRAITS FOR invoke()
#pragma warning(push)
#pragma warning(disable : 4242) // '%s': conversion from '%s' to '%s', possible loss of data (/Wall)
#pragma warning(disable : 4244) // '%s': conversion from '%s' to '%s', possible loss of data (Yes, duplicated message.)
#pragma warning(disable : 4365) // '%s': conversion from '%s' to '%s', signed/unsigned mismatch (/Wall)
#pragma warning(disable : 5215) // '%s' a function parameter with a volatile qualified type is deprecated in C++20

#ifdef __clang__
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-volatile"
#endif // __clang__

template &lt;class _To&gt;
void _Implicitly_convert_to(_To) noexcept; // not defined

template &lt;class _From, class _To, bool = is_convertible_v&lt;_From, _To&gt;, bool = is_void_v&lt;_To&gt;&gt;
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to&lt;_To&gt;(_STD declval&lt;_From&gt;()));

#ifdef __clang__
#pragma clang diagnostic pop
#endif // __clang__

#pragma warning(pop)

template &lt;class _From, class _To, bool _IsVoid&gt;
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v&lt;_From, _To, false, _IsVoid&gt; = false;

template &lt;class _From, class _To&gt;
_INLINE_VAR constexpr bool _Is_nothrow_convertible_v&lt;_From, _To, true, true&gt; = true;

template &lt;class _From, class _To&gt;
struct _Is_nothrow_convertible : bool_constant&lt;_Is_nothrow_convertible_v&lt;_From, _To&gt;&gt; {
    // determine whether _From is nothrow-convertible to _To
};

#if _HAS_CXX20
template &lt;class _From, class _To&gt;
inline constexpr bool is_nothrow_convertible_v = _Is_nothrow_convertible_v&lt;_From, _To&gt;;

template &lt;class _From, class _To&gt;
using is_nothrow_convertible = _Is_nothrow_convertible&lt;_From, _To&gt;;
#endif // _HAS_CXX20

template &lt;class _Ty&gt;
_Ty _Returns_exactly() noexcept; // not defined

template &lt;class _From, class _To, class = void&gt;
struct _Invoke_convertible : false_type {};

template &lt;class _From, class _To&gt;
struct _Invoke_convertible&lt;_From, _To, void_t&lt;decltype(_Implicitly_convert_to&lt;_To&gt;(_Returns_exactly&lt;_From&gt;()))&gt;&gt;
    : true_type {};

template &lt;class _From, class _To&gt;
struct _Invoke_nothrow_convertible : bool_constant&lt;noexcept(_Implicitly_convert_to&lt;_To&gt;(_Returns_exactly&lt;_From&gt;()))&gt; {};

template &lt;class _Result, bool _Nothrow&gt;
struct _Invoke_traits_common {
    using type                  = _Result;
    using _Is_invocable         = true_type;
    using _Is_nothrow_invocable = bool_constant&lt;_Nothrow&gt;;
    template &lt;class _Rx&gt;
    using _Is_invocable_r = bool_constant&lt;disjunction_v&lt;is_void&lt;_Rx&gt;, _Invoke_convertible&lt;type, _Rx&gt;&gt;&gt;;
    template &lt;class _Rx&gt;
    using _Is_nothrow_invocable_r = bool_constant&lt;conjunction_v&lt;_Is_nothrow_invocable,
        disjunction&lt;is_void&lt;_Rx&gt;,
            conjunction&lt;_Invoke_convertible&lt;type, _Rx&gt;, _Invoke_nothrow_convertible&lt;type, _Rx&gt;&gt;&gt;&gt;&gt;;
};

template &lt;class _Void, class _Callable&gt;
struct _Invoke_traits_zero {
    // selected when _Callable isn't callable with zero _Args
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template &lt;class _Rx&gt;
    using _Is_invocable_r = false_type;
    template &lt;class _Rx&gt;
    using _Is_nothrow_invocable_r = false_type;
};

template &lt;class _Callable&gt;
using _Decltype_invoke_zero = decltype(_STD declval&lt;_Callable&gt;()());

template &lt;class _Callable&gt;
struct _Invoke_traits_zero&lt;void_t&lt;_Decltype_invoke_zero&lt;_Callable&gt;&gt;, _Callable&gt;
    : _Invoke_traits_common&lt;_Decltype_invoke_zero&lt;_Callable&gt;, noexcept(_STD declval&lt;_Callable&gt;()())&gt; {};

template &lt;class _Void, class... _Types&gt;
struct _Invoke_traits_nonzero {
    // selected when _Callable isn't callable with nonzero _Args
    using _Is_invocable         = false_type;
    using _Is_nothrow_invocable = false_type;
    template &lt;class _Rx&gt;
    using _Is_invocable_r = false_type;
    template &lt;class _Rx&gt;
    using _Is_nothrow_invocable_r = false_type;
};

template &lt;class _Callable, class _Ty1, class... _Types2&gt;
using _Decltype_invoke_nonzero = decltype(
    _Invoker1&lt;_Callable, _Ty1&gt;::_Call(_STD declval&lt;_Callable&gt;(), _STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Types2&gt;()...));

template &lt;class _Callable, class _Ty1, class... _Types2&gt;
struct _Invoke_traits_nonzero&lt;void_t&lt;_Decltype_invoke_nonzero&lt;_Callable, _Ty1, _Types2...&gt;&gt;, _Callable, _Ty1,
    _Types2...&gt; : _Invoke_traits_common&lt;_Decltype_invoke_nonzero&lt;_Callable, _Ty1, _Types2...&gt;,
                      noexcept(_Invoker1&lt;_Callable, _Ty1&gt;::_Call(
                          _STD declval&lt;_Callable&gt;(), _STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Types2&gt;()...))&gt; {};

template &lt;class _Callable, class... _Args&gt;
using _Select_invoke_traits = conditional_t&lt;sizeof...(_Args) == 0, _Invoke_traits_zero&lt;void, _Callable&gt;,
    _Invoke_traits_nonzero&lt;void, _Callable, _Args...&gt;&gt;;

#if _HAS_DEPRECATED_RESULT_OF
// STRUCT TEMPLATE result_of
template &lt;class _Fty&gt;
struct _CXX17_DEPRECATE_RESULT_OF result_of { // explain usage
    static_assert(_Always_false&lt;_Fty&gt;, "result_of&lt;CallableType&gt; is invalid; use "
                                       "result_of&lt;CallableType(zero or more argument types)&gt; instead.");
};

#define _RESULT_OF(CALL_OPT, X1, X2, X3)                                                                    \
    template &lt;class _Callable, class... _Args&gt;                                                              \
    struct _CXX17_DEPRECATE_RESULT_OF result_of&lt;_Callable CALL_OPT(_Args...)&gt;                               \
        : _Select_invoke_traits&lt;_Callable, _Args...&gt; { /* template to determine result of call operation */ \
    };

_NON_MEMBER_CALL(_RESULT_OF, X1, X2, X3)
#undef _RESULT_OF

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
using result_of_t _CXX17_DEPRECATE_RESULT_OF = typename result_of&lt;_Ty&gt;::type;
_STL_RESTORE_DEPRECATED_WARNING
#endif // _HAS_DEPRECATED_RESULT_OF

template &lt;class _Callable, class... _Args&gt;
using _Invoke_result_t = typename _Select_invoke_traits&lt;_Callable, _Args...&gt;::type;

template &lt;class _Rx, class _Callable, class... _Args&gt;
using _Is_invocable_r_ = typename _Select_invoke_traits&lt;_Callable, _Args...&gt;::template _Is_invocable_r&lt;_Rx&gt;;

template &lt;class _Rx, class _Callable, class... _Args&gt;
struct _Is_invocable_r : _Is_invocable_r_&lt;_Rx, _Callable, _Args...&gt; {
    // determines whether _Callable is callable with _Args and return type _Rx
};

#if _HAS_CXX17
// STRUCT TEMPLATE invoke_result
template &lt;class _Callable, class... _Args&gt;
struct invoke_result : _Select_invoke_traits&lt;_Callable, _Args...&gt; {
    // determine the result type of invoking _Callable with _Args
};

template &lt;class _Callable, class... _Args&gt;
using invoke_result_t = typename _Select_invoke_traits&lt;_Callable, _Args...&gt;::type;

// STRUCT TEMPLATE is_invocable
template &lt;class _Callable, class... _Args&gt;
struct is_invocable : _Select_invoke_traits&lt;_Callable, _Args...&gt;::_Is_invocable {
    // determines whether _Callable is callable with _Args
};

template &lt;class _Callable, class... _Args&gt;
inline constexpr bool is_invocable_v = _Select_invoke_traits&lt;_Callable, _Args...&gt;::_Is_invocable::value;

// STRUCT TEMPLATE is_nothrow_invocable
template &lt;class _Callable, class... _Args&gt;
struct is_nothrow_invocable : _Select_invoke_traits&lt;_Callable, _Args...&gt;::_Is_nothrow_invocable {
    // determines whether _Callable is nothrow-callable with _Args
};

template &lt;class _Callable, class... _Args&gt;
inline constexpr bool is_nothrow_invocable_v = _Select_invoke_traits&lt;_Callable, _Args...&gt;::_Is_nothrow_invocable::value;

// STRUCT TEMPLATE is_invocable_r
template &lt;class _Rx, class _Callable, class... _Args&gt;
struct is_invocable_r : _Is_invocable_r_&lt;_Rx, _Callable, _Args...&gt; {
    // determines whether _Callable is callable with _Args and return type _Rx
};

template &lt;class _Rx, class _Callable, class... _Args&gt;
inline constexpr bool is_invocable_r_v = _Is_invocable_r_&lt;_Rx, _Callable, _Args...&gt;::value;

// STRUCT TEMPLATE is_nothrow_invocable_r
template &lt;class _Rx, class _Callable, class... _Args&gt;
struct is_nothrow_invocable_r : _Select_invoke_traits&lt;_Callable, _Args...&gt;::template _Is_nothrow_invocable_r&lt;_Rx&gt; {
    // determines whether _Callable is nothrow-callable with _Args and return type _Rx
};

template &lt;class _Rx, class _Callable, class... _Args&gt;
inline constexpr bool is_nothrow_invocable_r_v =
    _Select_invoke_traits&lt;_Callable, _Args...&gt;::template _Is_nothrow_invocable_r&lt;_Rx&gt;::value;
#endif // _HAS_CXX17

#if _HAS_CXX20
#ifndef __EDG__ // TRANSITION, VSO-1268984
#ifndef __clang__ // TRANSITION, LLVM-48860
// STRUCT TEMPLATE is_layout_compatible
template &lt;class _Ty1, class _Ty2&gt;
struct is_layout_compatible : bool_constant&lt;__is_layout_compatible(_Ty1, _Ty2)&gt; {};

template &lt;class _Ty1, class _Ty2&gt;
inline constexpr bool is_layout_compatible_v = __is_layout_compatible(_Ty1, _Ty2);

// STRUCT TEMPLATE is_pointer_interconvertible_base_of
template &lt;class _Base, class _Derived&gt;
struct is_pointer_interconvertible_base_of : bool_constant&lt;__is_pointer_interconvertible_base_of(_Base, _Derived)&gt; {};

template &lt;class _Base, class _Derived&gt;
inline constexpr bool is_pointer_interconvertible_base_of_v = __is_pointer_interconvertible_base_of(_Base, _Derived);

// FUNCTION TEMPLATE is_pointer_interconvertible_with_class
template &lt;class _ClassTy, class _MemberTy&gt;
_NODISCARD constexpr bool is_pointer_interconvertible_with_class(_MemberTy _ClassTy::*_Pm) noexcept {
    return __is_pointer_interconvertible_with_class(_ClassTy, _Pm);
}

// FUNCTION TEMPLATE is_corresponding_member
template &lt;class _ClassTy1, class _ClassTy2, class _MemberTy1, class _MemberTy2&gt;
_NODISCARD constexpr bool is_corresponding_member(_MemberTy1 _ClassTy1::*_Pm1, _MemberTy2 _ClassTy2::*_Pm2) noexcept {
    return __is_corresponding_member(_ClassTy1, _ClassTy2, _Pm1, _Pm2);
}
#endif // __clang__
#endif // __EDG__
#endif // _HAS_CXX20

// ALIAS TEMPLATE _Weak_types
template &lt;class _Ty&gt;
struct _Function_args {}; // determine whether _Ty is a function

#define _FUNCTION_ARGS(CALL_OPT, CV_OPT, REF_OPT, NOEXCEPT_OPT)                                           \
    template &lt;class _Ret, class... _Types&gt;                                                                \
    struct _Function_args&lt;_Ret CALL_OPT(_Types...) CV_OPT REF_OPT NOEXCEPT_OPT&gt; : _Arg_types&lt;_Types...&gt; { \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret _RESULT_TYPE_NAME;                                 \
    };

_NON_MEMBER_CALL_CV_REF_NOEXCEPT(_FUNCTION_ARGS)
#undef _FUNCTION_ARGS

#define _FUNCTION_ARGS_ELLIPSIS(CV_REF_NOEXCEPT_OPT)                                                            \
    template &lt;class _Ret, class... _Types&gt;                                                                      \
    struct _Function_args&lt;_Ret(_Types..., ...) CV_REF_NOEXCEPT_OPT&gt; { /* no calling conventions for ellipsis */ \
        _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Ret _RESULT_TYPE_NAME;                                       \
    };

_CLASS_DEFINE_CV_REF_NOEXCEPT(_FUNCTION_ARGS_ELLIPSIS)
#undef _FUNCTION_ARGS_ELLIPSIS

template &lt;class _Ty, class = void&gt;
struct _Weak_result_type {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Weak_result_type&lt;_Ty, void_t&lt;typename _Ty::result_type&gt;&gt; { // defined if _Ty::result_type exists
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::result_type _RESULT_TYPE_NAME;
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Ty, class = void&gt;
struct _Weak_argument_type : _Weak_result_type&lt;_Ty&gt; {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Weak_argument_type&lt;_Ty, void_t&lt;typename _Ty::argument_type&gt;&gt; : _Weak_result_type&lt;_Ty&gt; {
    // defined if _Ty::argument_type exists
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::argument_type _ARGUMENT_TYPE_NAME;
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Ty, class = void&gt;
struct _Weak_binary_args : _Weak_argument_type&lt;_Ty&gt; {}; // default definition

_STL_DISABLE_DEPRECATED_WARNING
template &lt;class _Ty&gt;
struct _Weak_binary_args&lt;_Ty, void_t&lt;typename _Ty::first_argument_type,
                                  typename _Ty::second_argument_type&gt;&gt;
    : _Weak_argument_type&lt;_Ty&gt; { // defined if both types exist
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::first_argument_type _FIRST_ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef typename _Ty::second_argument_type _SECOND_ARGUMENT_TYPE_NAME;
};
_STL_RESTORE_DEPRECATED_WARNING

template &lt;class _Ty&gt;
using _Weak_types = conditional_t&lt;is_function_v&lt;remove_pointer_t&lt;_Ty&gt;&gt;, _Function_args&lt;remove_pointer_t&lt;_Ty&gt;&gt;,
    conditional_t&lt;is_member_function_pointer_v&lt;_Ty&gt;, _Is_memfunptr&lt;remove_cv_t&lt;_Ty&gt;&gt;, _Weak_binary_args&lt;_Ty&gt;&gt;&gt;;

// CLASS TEMPLATE reference_wrapper
template &lt;class _Ty&gt;
void _Refwrap_ctor_fun(_Identity_t&lt;_Ty&amp;&gt;) noexcept;
template &lt;class _Ty&gt;
void _Refwrap_ctor_fun(_Identity_t&lt;_Ty&amp;&amp;&gt;) = delete;

template &lt;class _Ty, class _Uty, class = void&gt;
struct _Refwrap_has_ctor_from : false_type {};

template &lt;class _Ty, class _Uty&gt;
struct _Refwrap_has_ctor_from&lt;_Ty, _Uty, void_t&lt;decltype(_Refwrap_ctor_fun&lt;_Ty&gt;(_STD declval&lt;_Uty&gt;()))&gt;&gt; : true_type {};

template &lt;class _Ty&gt;
class reference_wrapper
#if !_HAS_CXX20
    : public _Weak_types&lt;_Ty&gt;
#endif // !_HAS_CXX20
{
public:
    static_assert(is_object_v&lt;_Ty&gt; || is_function_v&lt;_Ty&gt;,
        "reference_wrapper&lt;T&gt; requires T to be an object type or a function type.");

    using type = _Ty;

    template &lt;class _Uty, enable_if_t&lt;conjunction_v&lt;negation&lt;is_same&lt;_Remove_cvref_t&lt;_Uty&gt;, reference_wrapper&gt;&gt;,
                                          _Refwrap_has_ctor_from&lt;_Ty, _Uty&gt;&gt;,
                              int&gt; = 0&gt;
    _CONSTEXPR20 reference_wrapper(_Uty&amp;&amp; _Val) noexcept(noexcept(_Refwrap_ctor_fun&lt;_Ty&gt;(_STD declval&lt;_Uty&gt;()))) {
        _Ty&amp; _Ref = static_cast&lt;_Uty&amp;&amp;&gt;(_Val);
        _Ptr      = _STD addressof(_Ref);
    }

    _CONSTEXPR20 operator _Ty&amp;() const noexcept {
        return *_Ptr;
    }

    _NODISCARD _CONSTEXPR20 _Ty&amp; get() const noexcept {
        return *_Ptr;
    }

private:
    _Ty* _Ptr{};

public:
    template &lt;class... _Types&gt;
    _CONSTEXPR20 auto operator()(_Types&amp;&amp;... _Args) const
        noexcept(noexcept(_STD invoke(*_Ptr, static_cast&lt;_Types&amp;&amp;&gt;(_Args)...))) // strengthened
        -&gt; decltype(_STD invoke(*_Ptr, static_cast&lt;_Types&amp;&amp;&gt;(_Args)...)) {
        return _STD invoke(*_Ptr, static_cast&lt;_Types&amp;&amp;&gt;(_Args)...);
    }
};

#if _HAS_CXX17
template &lt;class _Ty&gt;
reference_wrapper(_Ty&amp;) -&gt; reference_wrapper&lt;_Ty&gt;;
#endif // _HAS_CXX17

// FUNCTION TEMPLATES ref AND cref
template &lt;class _Ty&gt;
_NODISCARD _CONSTEXPR20 reference_wrapper&lt;_Ty&gt; ref(_Ty&amp; _Val) noexcept {
    return reference_wrapper&lt;_Ty&gt;(_Val);
}

template &lt;class _Ty&gt;
void ref(const _Ty&amp;&amp;) = delete;

template &lt;class _Ty&gt;
_NODISCARD _CONSTEXPR20 reference_wrapper&lt;_Ty&gt; ref(reference_wrapper&lt;_Ty&gt; _Val) noexcept {
    return _STD ref(_Val.get());
}

template &lt;class _Ty&gt;
_NODISCARD _CONSTEXPR20 reference_wrapper&lt;const _Ty&gt; cref(const _Ty&amp; _Val) noexcept {
    return reference_wrapper&lt;const _Ty&gt;(_Val);
}

template &lt;class _Ty&gt;
void cref(const _Ty&amp;&amp;) = delete;

template &lt;class _Ty&gt;
_NODISCARD _CONSTEXPR20 reference_wrapper&lt;const _Ty&gt; cref(reference_wrapper&lt;_Ty&gt; _Val) noexcept {
    return _STD cref(_Val.get());
}

#if _HAS_CXX20
// STRUCT TEMPLATE unwrap_reference
template &lt;class _Ty&gt;
struct unwrap_reference {
    using type = _Ty;
};
template &lt;class _Ty&gt;
struct unwrap_reference&lt;reference_wrapper&lt;_Ty&gt;&gt; {
    using type = _Ty&amp;;
};
template &lt;class _Ty&gt;
using unwrap_reference_t = typename unwrap_reference&lt;_Ty&gt;::type;

// STRUCT TEMPLATE unwrap_ref_decay
template &lt;class _Ty&gt;
using unwrap_ref_decay_t = unwrap_reference_t&lt;decay_t&lt;_Ty&gt;&gt;;
template &lt;class _Ty&gt;
struct unwrap_ref_decay {
    using type = unwrap_ref_decay_t&lt;_Ty&gt;;
};
#endif // _HAS_CXX20

// STRUCT TEMPLATE _Is_swappable
template &lt;class _Ty&gt;
struct _Is_swappable;

// STRUCT TEMPLATE _Is_nothrow_swappable
template &lt;class _Ty&gt;
struct _Is_nothrow_swappable;

// FUNCTION TEMPLATE swap
#if _HAS_CXX17
template &lt;class _Ty, enable_if_t&lt;is_move_constructible_v&lt;_Ty&gt; &amp;&amp; is_move_assignable_v&lt;_Ty&gt;, int&gt; = 0&gt;
#else // ^^^ _HAS_CXX17 / !_HAS_CXX17 vvv
template &lt;class _Ty, int _Enabled = 0&gt;
#endif // _HAS_CXX17
_CONSTEXPR20 void swap(_Ty&amp;, _Ty&amp;) noexcept(is_nothrow_move_constructible_v&lt;_Ty&gt;&amp;&amp; is_nothrow_move_assignable_v&lt;_Ty&gt;);

template &lt;class _Ty, size_t _Size, enable_if_t&lt;_Is_swappable&lt;_Ty&gt;::value, int&gt; = 0&gt;
_CONSTEXPR20 void swap(_Ty (&amp;)[_Size], _Ty (&amp;)[_Size]) noexcept(_Is_nothrow_swappable&lt;_Ty&gt;::value);

// STRUCT TEMPLATE _Swappable_with_helper
template &lt;class _Ty1, class _Ty2, class = void&gt;
struct _Swappable_with_helper : false_type {}; // swap(declval&lt;_Ty1&gt;(), declval&lt;_Ty2&gt;()) is not valid

template &lt;class _Ty1, class _Ty2&gt;
struct _Swappable_with_helper&lt;_Ty1, _Ty2, void_t&lt;decltype(swap(_STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Ty2&gt;()))&gt;&gt;
    : true_type {}; // swap(declval&lt;_Ty1&gt;(), declval&lt;_Ty2&gt;()) is valid

// STRUCT TEMPLATE _Is_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct _Is_swappable_with
    : bool_constant&lt;conjunction_v&lt;_Swappable_with_helper&lt;_Ty1, _Ty2&gt;, _Swappable_with_helper&lt;_Ty2, _Ty1&gt;&gt;&gt; {
    // Determine if expressions with type and value category _Ty1 and _Ty2 can be swapped (and vice versa)
};

// STRUCT TEMPLATE _Is_swappable
template &lt;class _Ty&gt;
struct _Is_swappable : _Is_swappable_with&lt;add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;_Ty&gt;&gt;::type {
    // Determine if _Ty lvalues satisfy is_swappable_with
};

// STRUCT TEMPLATE _Swap_cannot_throw
template &lt;class _Ty1, class _Ty2&gt;
struct _Swap_cannot_throw : bool_constant&lt;noexcept(swap(_STD declval&lt;_Ty1&gt;(), _STD declval&lt;_Ty2&gt;())) //
                                    &amp;&amp; noexcept(swap(_STD declval&lt;_Ty2&gt;(), _STD declval&lt;_Ty1&gt;()))&gt; {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // (presumed to satisfy is_swappable_with) can be swapped without emitting exceptions
};

// STRUCT TEMPLATE _Is_nothrow_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct _Is_nothrow_swappable_with
    : bool_constant&lt;conjunction_v&lt;_Is_swappable_with&lt;_Ty1, _Ty2&gt;, _Swap_cannot_throw&lt;_Ty1, _Ty2&gt;&gt;&gt; {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

// STRUCT TEMPLATE _Is_nothrow_swappable
template &lt;class _Ty&gt;
struct _Is_nothrow_swappable
    : _Is_nothrow_swappable_with&lt;add_lvalue_reference_t&lt;_Ty&gt;, add_lvalue_reference_t&lt;_Ty&gt;&gt;::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};

#if _HAS_CXX17
// STRUCT TEMPLATE is_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct is_swappable_with : _Is_swappable_with&lt;_Ty1, _Ty2&gt;::type {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // can be swapped (and vice versa)
};

template &lt;class _Ty1, class _Ty2&gt;
inline constexpr bool is_swappable_with_v =
    conjunction_v&lt;_Swappable_with_helper&lt;_Ty1, _Ty2&gt;, _Swappable_with_helper&lt;_Ty2, _Ty1&gt;&gt;;

// STRUCT TEMPLATE is_swappable
template &lt;class _Ty&gt;
struct is_swappable : _Is_swappable&lt;_Ty&gt;::type {}; // Determine if _Ty lvalues satisfy is_swappable_with

template &lt;class _Ty&gt;
inline constexpr bool is_swappable_v = _Is_swappable&lt;_Ty&gt;::value;

// STRUCT TEMPLATE is_nothrow_swappable_with
template &lt;class _Ty1, class _Ty2&gt;
struct is_nothrow_swappable_with : _Is_nothrow_swappable_with&lt;_Ty1, _Ty2&gt;::type {
    // Determine if expressions with type and value category _Ty1 and _Ty2
    // satisfy is_swappable_with, and can be swapped without emitting exceptions
};

template &lt;class _Ty1, class _Ty2&gt;
inline constexpr bool is_nothrow_swappable_with_v = _Is_nothrow_swappable_with&lt;_Ty1, _Ty2&gt;::value;

// STRUCT TEMPLATE is_nothrow_swappable
template &lt;class _Ty&gt;
struct is_nothrow_swappable : _Is_nothrow_swappable&lt;_Ty&gt;::type {
    // Determine if _Ty lvalues satisfy is_nothrow_swappable_with
};

template &lt;class _Ty&gt;
inline constexpr bool is_nothrow_swappable_v = _Is_nothrow_swappable&lt;_Ty&gt;::value;
#endif // _HAS_CXX17

// TYPE TRAIT _Is_trivially_swappable
namespace _Has_ADL_swap_detail {
    void swap(); // undefined (deliberate shadowing)

    template &lt;class, class = void&gt;
    struct _Has_ADL_swap : false_type {};
    template &lt;class _Ty&gt;
    struct _Has_ADL_swap&lt;_Ty, void_t&lt;decltype(swap(_STD declval&lt;_Ty&amp;&gt;(), _STD declval&lt;_Ty&amp;&gt;()))&gt;&gt; : true_type {};
} // namespace _Has_ADL_swap_detail
using _Has_ADL_swap_detail::_Has_ADL_swap;

template &lt;class _Ty&gt;
_INLINE_VAR constexpr bool _Is_trivially_swappable_v = conjunction_v&lt;is_trivially_destructible&lt;_Ty&gt;,
    is_trivially_move_constructible&lt;_Ty&gt;, is_trivially_move_assignable&lt;_Ty&gt;, negation&lt;_Has_ADL_swap&lt;_Ty&gt;&gt;&gt;;

template &lt;class _Ty&gt;
struct _Is_trivially_swappable : bool_constant&lt;_Is_trivially_swappable_v&lt;_Ty&gt;&gt; {
    // true_type if and only if it is valid to swap two _Ty lvalues by exchanging object representations.
};

// BITMASK OPERATIONS
#define _BITMASK_OPS(_BITMASK)                                                                                      \
    _NODISCARD constexpr _BITMASK operator&amp;(_BITMASK _Left, _BITMASK _Right) noexcept { /* return _Left &amp; _Right */ \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(static_cast&lt;_IntTy&gt;(_Left) &amp; static_cast&lt;_IntTy&gt;(_Right));                     \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr _BITMASK operator|(_BITMASK _Left, _BITMASK _Right) noexcept { /* return _Left | _Right */ \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(static_cast&lt;_IntTy&gt;(_Left) | static_cast&lt;_IntTy&gt;(_Right));                     \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr _BITMASK operator^(_BITMASK _Left, _BITMASK _Right) noexcept { /* return _Left ^ _Right */ \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(static_cast&lt;_IntTy&gt;(_Left) ^ static_cast&lt;_IntTy&gt;(_Right));                     \
    }                                                                                                               \
                                                                                                                    \
    constexpr _BITMASK&amp; operator&amp;=(_BITMASK&amp; _Left, _BITMASK _Right) noexcept { /* return _Left &amp;= _Right */        \
        return _Left = _Left &amp; _Right;                                                                              \
    }                                                                                                               \
                                                                                                                    \
    constexpr _BITMASK&amp; operator|=(_BITMASK&amp; _Left, _BITMASK _Right) noexcept { /* return _Left |= _Right */        \
        return _Left = _Left | _Right;                                                                              \
    }                                                                                                               \
                                                                                                                    \
    constexpr _BITMASK&amp; operator^=(_BITMASK&amp; _Left, _BITMASK _Right) noexcept { /* return _Left ^= _Right */        \
        return _Left = _Left ^ _Right;                                                                              \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr _BITMASK operator~(_BITMASK _Left) noexcept { /* return ~_Left */                          \
        using _IntTy = _STD underlying_type_t&lt;_BITMASK&gt;;                                                            \
        return static_cast&lt;_BITMASK&gt;(~static_cast&lt;_IntTy&gt;(_Left));                                                  \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr bool _Bitmask_includes(                                                                    \
        _BITMASK _Left, _BITMASK _Elements) noexcept { /* return (_Left &amp; _Elements) != _BITMASK{} */               \
        return (_Left &amp; _Elements) != _BITMASK{};                                                                   \
    }                                                                                                               \
                                                                                                                    \
    _NODISCARD constexpr bool _Bitmask_includes_all(                                                                \
        _BITMASK _Left, _BITMASK _Elements) noexcept { /* return (_Left &amp; _Elements) == _Elements */                \
        return (_Left &amp; _Elements) == _Elements;                                                                    \
    }

// FNV-1a UTILITIES
// These functions are extremely performance sensitive, check examples like
// that in VSO-653642 before making changes.
#if defined(_WIN64)
_INLINE_VAR constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
_INLINE_VAR constexpr size_t _FNV_prime        = 1099511628211ULL;
#else // defined(_WIN64)
_INLINE_VAR constexpr size_t _FNV_offset_basis = 2166136261U;
_INLINE_VAR constexpr size_t _FNV_prime        = 16777619U;
#endif // defined(_WIN64)

_NODISCARD inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First,
    const size_t _Count) noexcept { // accumulate range [_First, _First + _Count) into partial FNV-1a hash _Val
    for (size_t _Idx = 0; _Idx &lt; _Count; ++_Idx) {
        _Val ^= static_cast&lt;size_t&gt;(_First[_Idx]);
        _Val *= _FNV_prime;
    }

    return _Val;
}

template &lt;class _Ty&gt;
_NODISCARD size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First,
    const _Ty* const _Last) noexcept { // accumulate range [_First, _Last) into partial FNV-1a hash _Val
    static_assert(is_trivial_v&lt;_Ty&gt;, "Only trivial types can be directly hashed.");
    const auto _Firstb = reinterpret_cast&lt;const unsigned char*&gt;(_First);
    const auto _Lastb  = reinterpret_cast&lt;const unsigned char*&gt;(_Last);
    return _Fnv1a_append_bytes(_Val, _Firstb, static_cast&lt;size_t&gt;(_Lastb - _Firstb));
}

template &lt;class _Kty&gt;
_NODISCARD size_t _Fnv1a_append_value(
    const size_t _Val, const _Kty&amp; _Keyval) noexcept { // accumulate _Keyval into partial FNV-1a hash _Val
    static_assert(is_trivial_v&lt;_Kty&gt;, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(_Val, &amp;reinterpret_cast&lt;const unsigned char&amp;&gt;(_Keyval), sizeof(_Kty));
}

// FUNCTION TEMPLATE _Hash_representation
template &lt;class _Kty&gt;
_NODISCARD size_t _Hash_representation(const _Kty&amp; _Keyval) noexcept { // bitwise hashes the representation of a key
    return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
}

// FUNCTION TEMPLATE _Hash_array_representation
template &lt;class _Kty&gt;
_NODISCARD size_t _Hash_array_representation(
    const _Kty* const _First, const size_t _Count) noexcept { // bitwise hashes the representation of an array
    static_assert(is_trivial_v&lt;_Kty&gt;, "Only trivial types can be directly hashed.");
    return _Fnv1a_append_bytes(
        _FNV_offset_basis, reinterpret_cast&lt;const unsigned char*&gt;(_First), _Count * sizeof(_Kty));
}

// STRUCT TEMPLATE _Conditionally_enabled_hash
template &lt;class _Kty&gt;
struct hash;

template &lt;class _Kty, bool _Enabled&gt;
struct _Conditionally_enabled_hash { // conditionally enabled hash base
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef _Kty _ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;

    _NODISCARD size_t operator()(const _Kty&amp; _Keyval) const
        noexcept(noexcept(hash&lt;_Kty&gt;::_Do_hash(_Keyval))) /* strengthened */ {
        return hash&lt;_Kty&gt;::_Do_hash(_Keyval);
    }
};

template &lt;class _Kty&gt;
struct _Conditionally_enabled_hash&lt;_Kty, false&gt; { // conditionally disabled hash base
    _Conditionally_enabled_hash()                                   = delete;
    _Conditionally_enabled_hash(const _Conditionally_enabled_hash&amp;) = delete;
    _Conditionally_enabled_hash(_Conditionally_enabled_hash&amp;&amp;)      = delete;
    _Conditionally_enabled_hash&amp; operator=(const _Conditionally_enabled_hash&amp;) = delete;
    _Conditionally_enabled_hash&amp; operator=(_Conditionally_enabled_hash&amp;&amp;) = delete;
};

// STRUCT TEMPLATE hash
template &lt;class _Kty&gt;
struct hash
    : _Conditionally_enabled_hash&lt;_Kty,
          !is_const_v&lt;_Kty&gt; &amp;&amp; !is_volatile_v&lt;_Kty&gt; &amp;&amp; (is_enum_v&lt;_Kty&gt; || is_integral_v&lt;_Kty&gt; || is_pointer_v&lt;_Kty&gt;)&gt; {
    // hash functor primary template (handles enums, integrals, and pointers)
    static size_t _Do_hash(const _Kty&amp; _Keyval) noexcept {
        return _Hash_representation(_Keyval);
    }
};

template &lt;&gt;
struct hash&lt;float&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef float _ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
    _NODISCARD size_t operator()(const float _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval); // map -0 to 0
    }
};

template &lt;&gt;
struct hash&lt;double&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef double _ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
    _NODISCARD size_t operator()(const double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval); // map -0 to 0
    }
};

template &lt;&gt;
struct hash&lt;long double&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef long double _ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
    _NODISCARD size_t operator()(const long double _Keyval) const noexcept {
        return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval); // map -0 to 0
    }
};

template &lt;&gt;
struct hash&lt;nullptr_t&gt; {
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef nullptr_t _ARGUMENT_TYPE_NAME;
    _CXX17_DEPRECATE_ADAPTOR_TYPEDEFS typedef size_t _RESULT_TYPE_NAME;
    _NODISCARD size_t operator()(nullptr_t) const noexcept {
        void* _Null{};
        return _Hash_representation(_Null);
    }
};

// STRUCT TEMPLATE _Is_nothrow_hashable
template &lt;class _Kty, class = void&gt;
struct _Is_nothrow_hashable : false_type {}; // tests if std::hash can hash _Kty with noexcept

template &lt;class _Kty&gt;
struct _Is_nothrow_hashable&lt;_Kty, void_t&lt;decltype(hash&lt;_Kty&gt;{}(_STD declval&lt;const _Kty&amp;&gt;()))&gt;&gt;
    : bool_constant&lt;noexcept(hash&lt;_Kty&gt;{}(_STD declval&lt;const _Kty&amp;&gt;()))&gt; {};

// vvvvvvvvvv DERIVED FROM corecrt_internal_fltintrn.h vvvvvvvvvv

template &lt;class _FloatingType&gt;
struct _Floating_type_traits;

template &lt;&gt;
struct _Floating_type_traits&lt;float&gt; {
    static constexpr int32_t _Mantissa_bits           = 24; // FLT_MANT_DIG
    static constexpr int32_t _Exponent_bits           = 8; // sizeof(float) * CHAR_BIT - FLT_MANT_DIG
    static constexpr int32_t _Maximum_binary_exponent = 127; // FLT_MAX_EXP - 1
    static constexpr int32_t _Minimum_binary_exponent = -126; // FLT_MIN_EXP - 1
    static constexpr int32_t _Exponent_bias           = 127;
    static constexpr int32_t _Sign_shift              = 31; // _Exponent_bits + _Mantissa_bits - 1
    static constexpr int32_t _Exponent_shift          = 23; // _Mantissa_bits - 1

    using _Uint_type = uint32_t;

    static constexpr uint32_t _Exponent_mask             = 0x000000FFu; // (1u &lt;&lt; _Exponent_bits) - 1
    static constexpr uint32_t _Normal_mantissa_mask      = 0x00FFFFFFu; // (1u &lt;&lt; _Mantissa_bits) - 1
    static constexpr uint32_t _Denormal_mantissa_mask    = 0x007FFFFFu; // (1u &lt;&lt; (_Mantissa_bits - 1)) - 1
    static constexpr uint32_t _Special_nan_mantissa_mask = 0x00400000u; // 1u &lt;&lt; (_Mantissa_bits - 2)
    static constexpr uint32_t _Shifted_sign_mask         = 0x80000000u; // 1u &lt;&lt; _Sign_shift
    static constexpr uint32_t _Shifted_exponent_mask     = 0x7F800000u; // _Exponent_mask &lt;&lt; _Exponent_shift
};

template &lt;&gt;
struct _Floating_type_traits&lt;double&gt; {
    static constexpr int32_t _Mantissa_bits           = 53; // DBL_MANT_DIG
    static constexpr int32_t _Exponent_bits           = 11; // sizeof(double) * CHAR_BIT - DBL_MANT_DIG
    static constexpr int32_t _Maximum_binary_exponent = 1023; // DBL_MAX_EXP - 1
    static constexpr int32_t _Minimum_binary_exponent = -1022; // DBL_MIN_EXP - 1
    static constexpr int32_t _Exponent_bias           = 1023;
    static constexpr int32_t _Sign_shift              = 63; // _Exponent_bits + _Mantissa_bits - 1
    static constexpr int32_t _Exponent_shift          = 52; // _Mantissa_bits - 1

    using _Uint_type = uint64_t;

    static constexpr uint64_t _Exponent_mask             = 0x00000000000007FFu; // (1ULL &lt;&lt; _Exponent_bits) - 1
    static constexpr uint64_t _Normal_mantissa_mask      = 0x001FFFFFFFFFFFFFu; // (1ULL &lt;&lt; _Mantissa_bits) - 1
    static constexpr uint64_t _Denormal_mantissa_mask    = 0x000FFFFFFFFFFFFFu; // (1ULL &lt;&lt; (_Mantissa_bits - 1)) - 1
    static constexpr uint64_t _Special_nan_mantissa_mask = 0x0008000000000000u; // 1ULL &lt;&lt; (_Mantissa_bits - 2)
    static constexpr uint64_t _Shifted_sign_mask         = 0x8000000000000000u; // 1ULL &lt;&lt; _Sign_shift
    static constexpr uint64_t _Shifted_exponent_mask     = 0x7FF0000000000000u; // _Exponent_mask &lt;&lt; _Exponent_shift
};

template &lt;&gt;
struct _Floating_type_traits&lt;long double&gt; : _Floating_type_traits&lt;double&gt; {};

// ^^^^^^^^^^ DERIVED FROM corecrt_internal_fltintrn.h ^^^^^^^^^^

#if _HAS_TR1_NAMESPACE
_STL_DISABLE_DEPRECATED_WARNING
namespace _DEPRECATE_TR1_NAMESPACE tr1 {
    using _STD add_const;
    using _STD add_cv;
    using _STD add_pointer;
    using _STD add_volatile;
    using _STD aligned_storage;
    using _STD alignment_of;
    using _STD conditional;
    using _STD decay;
    using _STD enable_if;
    using _STD extent;
    using _STD false_type;
    using _STD has_virtual_destructor;
    using _STD integral_constant;
    using _STD is_abstract;
    using _STD is_arithmetic;
    using _STD is_array;
    using _STD is_base_of;
    using _STD is_class;
    using _STD is_compound;
    using _STD is_const;
    using _STD is_convertible;
    using _STD is_empty;
    using _STD is_enum;
    using _STD is_floating_point;
    using _STD is_function;
    using _STD is_fundamental;
    using _STD is_integral;
    using _STD is_member_function_pointer;
    using _STD is_member_object_pointer;
    using _STD is_member_pointer;
    using _STD is_object;
    using _STD is_pod;
    using _STD is_pointer;
    using _STD is_polymorphic;
    using _STD is_reference;
    using _STD is_same;
    using _STD is_scalar;
    using _STD is_signed;
    using _STD is_union;
    using _STD is_unsigned;
    using _STD is_void;
    using _STD is_volatile;
    using _STD make_signed;
    using _STD make_unsigned;
    using _STD rank;
    using _STD remove_all_extents;
    using _STD remove_const;
    using _STD remove_cv;
    using _STD remove_extent;
    using _STD remove_pointer;
    using _STD remove_reference;
    using _STD remove_volatile;
    using _STD true_type;
    using _STD cref;
    using _STD ref;
    using _STD reference_wrapper;
#if _HAS_DEPRECATED_RESULT_OF
    using _STD result_of;
#endif // _HAS_DEPRECATED_RESULT_OF
    using _STD hash;
} // namespace tr1
_STL_RESTORE_DEPRECATED_WARNING
#endif // _HAS_TR1_NAMESPACE

_STD_END

#pragma pop_macro("new")
_STL_RESTORE_CLANG_WARNINGS
#pragma warning(pop)
#pragma pack(pop)

#endif // _STL_COMPILER_PREPROCESSOR
#endif // _TYPE_TRAITS_</pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>
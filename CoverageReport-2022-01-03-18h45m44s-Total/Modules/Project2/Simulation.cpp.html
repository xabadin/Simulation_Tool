<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>Simulation.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include "Simulation.h"
#include &lt;fstream&gt;

//Alternate constructor
Simulation::Simulation(Parameters* parameters)
<span style = "background-color:#dfd">{
	this-&gt;parameters = parameters;
	fillVecUsers();
	fillVecJobs();</span>
	//sort the jobs vector with the submission time
<span style = "background-color:#dfd">	std::sort(jobs.begin(), jobs.end(), [](Job* job1, Job* job2) {return job1-&gt;getSubmissionTime() &lt; job2-&gt;getSubmissionTime(); });
	scheduler();</span>


<span style = "background-color:#dfd">}</span>

//Randomly generates the users and inserts them in a vector. The percentage of generated users is assumed to be approximately 10/16 students, 5/16 researchers and 1/16 IT staff.
void Simulation::fillVecUsers()
<span style = "background-color:#dfd">{</span>
	// Creates users, IT users are created with an unlimited budget.
<span style = "background-color:#dfd">	for (unsigned int i = 0; i &lt; parameters-&gt;getNumberOfUsers(); ++i)</span>
	{
<span style = "background-color:#dfd">		int randomNumber = randomNumGenerator(0, 15);
		if (randomNumber &gt;= 0 &amp;&amp; randomNumber &lt;= 9)</span>
		{
<span style = "background-color:#dfd">			User* user = new User(i, UserType::Student, parameters-&gt;getStudentBudget(), parameters-&gt;getStudentMaxNodes());
			this-&gt;users.push_back(user);
		}
		else if (randomNumber &gt;= 10 &amp;&amp; randomNumber &lt;= 14)</span>
		{
<span style = "background-color:#dfd">			User* user = new User(i, UserType::Researcher, parameters-&gt;getResearcherBudget(), parameters-&gt;getResearcherMaxNodes());
			this-&gt;users.push_back(user);
		}</span>
		else
		{
<span style = "background-color:#dfd">			User* user = new User(i, UserType::IT, DBL_MAX, parameters-&gt;getNumberOfNodes());
			this-&gt;users.push_back(user);</span>
		}
<span style = "background-color:#dfd">	}
}</span>

void Simulation::fillVecJobs()
<span style = "background-color:#dfd">{
	for (unsigned int i = 0; i &lt; parameters-&gt;getNumberOfJobs(); ++i)</span>
	{
<span style = "background-color:#dfd">		bool isGPUJob = false;
		unsigned int nodesRequired = 0;
		unsigned int jobDuration = 0;</span>
		//Generates a random number to distribute the jobs according to the assumed ratio in the requirements.
		//Following a normal distribution gives the number of nodes and the duration time of the job according to the queue
<span style = "background-color:#dfd">		int randomNumber = randomNumGenerator(0, 99);
		if (randomNumber &gt;= 0 &amp;&amp; randomNumber &lt;= 9)</span>
		{
			//Creates short jobs (2 nodes max and up to two hours)
<span style = "background-color:#dfd">			while (nodesRequired &lt;= 0 || nodesRequired &gt; 2 || jobDuration &lt;= 0 || jobDuration &gt; ONE_HOUR_IN_SEC * 2)</span>
			{
<span style = "background-color:#dfd">				nodesRequired = (int)normalDistribution(1.5, 0.5);
				jobDuration = (int)normalDistribution(ONE_HOUR_IN_SEC, 1000.0);
			}
		}
		else if (randomNumber &gt;= 10 &amp;&amp; randomNumber &lt;= 39)</span>
		{
			//Creates medium jobs (10% of total number of nodes max and up to 8 hours)
<span style = "background-color:#dfd">			while (nodesRequired &lt;= 0 || nodesRequired &gt;= parameters-&gt;getNumberOfMediumNodes() || jobDuration &lt;= ONE_HOUR_IN_SEC * 2 || jobDuration &gt; EIGHT_HOURS_IN_SEC)</span>
			{
				//The mean of the normal distribution is 5% of the total node count
<span style = "background-color:#dfd">				nodesRequired = (int)normalDistribution((double)parameters-&gt;getNumberOfMediumNodes() / 2.0, 3.0);
				jobDuration = (int)normalDistribution(EIGHT_HOURS_IN_SEC / 2, 7000.0);
			}
		}
		else if (randomNumber &gt;= 40 &amp;&amp; randomNumber &lt;= 89)</span>
		{
			//Creates large jobs (50% of total number of nodes max and up to 16 hours)
<span style = "background-color:#dfd">			while (nodesRequired &lt;= 0 || nodesRequired &gt;= parameters-&gt;getNumberOfLargeNodes() || jobDuration &lt;= EIGHT_HOURS_IN_SEC || jobDuration &gt; SIXTEEN_HOURS_IN_SEC)</span>
			{
				//The mean of the normal distribution is 25% of the total node count
<span style = "background-color:#dfd">				nodesRequired = (int)normalDistribution((double)parameters-&gt;getNumberOfLargeNodes() / 2.0, 15.0);
				jobDuration = (int)normalDistribution(ONE_HOUR_IN_SEC * 12, 7000.0);
			}
		}
		else if (randomNumber &gt;= 90 &amp;&amp; randomNumber &lt;= 96)</span>
		{
<span style = "background-color:#dfd">			isGPUJob = true;</span>
			//Creates GPU jobs (8 nodes max and up to 16 hours)
<span style = "background-color:#dfd">			while (nodesRequired &lt;= 0 || nodesRequired &gt;= parameters-&gt;getNumberOfGPUNodes() || jobDuration &lt;= 0 || jobDuration &gt; SIXTEEN_HOURS_IN_SEC)</span>
			{
				//The mean of the normal distribution is half the number of GPU nodes
<span style = "background-color:#dfd">				nodesRequired = (int)normalDistribution((double)parameters-&gt;getNumberOfGPUNodes() / 2.0, 2.0);
				jobDuration = (int)normalDistribution(ONE_HOUR_IN_SEC * 4.0, 7000.0);
			}
		}</span>
		else
		{
			//Creates huge jobs (More than 16 hours and more than 50% of the node count)
<span style = "background-color:#dfd">			while (nodesRequired &lt; parameters-&gt;getNumberOfLargeNodes() || nodesRequired &gt; parameters-&gt;getNumberOfHugeNodes() || jobDuration &lt;= SIXTEEN_HOURS_IN_SEC || jobDuration &gt; SIXTY_FOUR_HOURS_IN_SEC)</span>
			{
				//The mean of the normal distribution is : (number of nodes - GPU nodes - 50% of the node count) / 2) + 50 % of the node count
<span style = "background-color:#dfd">				nodesRequired = (int)normalDistribution((((double)parameters-&gt;getNumberOfHugeNodes() - (double)parameters-&gt;getNumberOfLargeNodes()) / 2.0) + (double)parameters-&gt;getNumberOfLargeNodes(), 15.0);
				jobDuration = (int)normalDistribution(60.0 * 60.0 * 64.0 / 2, 50000.0);
			}</span>
		}

		//I need to choose a correct value for the exponential distribution (0.0000016 gives an average of a week)
<span style = "background-color:#dfd">		double lambda = 0.0000016;
		unsigned int submissionTime = (unsigned int)exponentialDistribution(lambda);
		Job* job = new Job(submissionTime, jobDuration, nodesRequired, isGPUJob);
		int index = 0;</span>
		//IT users can't submit jobs
<span style = "background-color:#dfd">		while (index &lt; users.size() &amp;&amp; users[index]-&gt;getType() == UserType::IT || !users[index]-&gt;checkBudget(job) || !users[index]-&gt;checkNumMaxNodes(job))</span>
		{
<span style = "background-color:#dfd">			index++;
			if (index &gt;= users.size()) {</span>
<span style = "background-color:#fdd">				break;</span>
			}
<span style = "background-color:#dfd">		}
		if (index &lt; users.size()) {
			job-&gt;setUser(users[index]);
			users[index]-&gt;decreaseBudget(job);
			jobs.push_back(job);</span>
		}
<span style = "background-color:#dfd">	}
}</span>

void Simulation::scheduler()
<span style = "background-color:#dfd">{
	for (int i = 0; i &lt; jobs.size(); ++i)</span>
	{
<span style = "background-color:#dfd">		unsigned int j = 0;
		unsigned int time = jobs[i]-&gt;getSubmissionTime();
		if (jobs[i]-&gt;isHugeJob())</span>
		{
			//Assigns the huge jobs
<span style = "background-color:#dfd">			int indexNodeCount = findNext(time, j);
			startHugeJob(indexNodeCount, *jobs[i], time);
			submitNodeCount(time, *jobs[i], indexNodeCount, i);
		}</span>
		else
		{
			//Assigns the large, GPU, medium and short jobs
<span style = "background-color:#dfd">			int indexNodeCount = findNext(time, j);
			if (indexNodeCount != nodeCounts.size())</span>
			{
<span style = "background-color:#dfd">				startJob(indexNodeCount, *jobs[i], time);
				while (!enoughTime(time, *jobs[i], indexNodeCount))</span>
				{
<span style = "background-color:#dfd">					startJob(indexNodeCount, *jobs[i], time);
				}</span>
			}
<span style = "background-color:#dfd">			submitNodeCount(time, *jobs[i], indexNodeCount, i);</span>
		}
<span style = "background-color:#dfd">	}
}</span>

unsigned int Simulation::nextWeekEnd(unsigned int time)
<span style = "background-color:#dfd">{
	if (time &lt; WEEKEND_START_IN_SEC)</span>
	{
<span style = "background-color:#dfd">		time = WEEKEND_START_IN_SEC;
	}</span>
	else
	{
<span style = "background-color:#dfd">		int quotient = time / WEEK_START_IN_SEC;
		time = (quotient + 1) * WEEK_START_IN_SEC + WEEKEND_START_IN_SEC;</span>
	}
<span style = "background-color:#dfd">	return time;
}</span>

// Refreshes the value of the nodecounts impacted by the job and Inserts the node count into the nodecount vector, and then sorts the vector nodecount with the time parameter
void Simulation::submitNodeCount(unsigned int time, Job&amp; job, int indexNodeCount, unsigned int jobID)
<span style = "background-color:#dfd">{
	job.setStartTime(time);
	job.setEndTime(time + job.getJobDuration());</span>
	//Refresh values
<span style = "background-color:#dfd">	int endIndex = indexNodeCount;
	bool isRefresh = false;</span>
	//this while is not working never going in it (hence, never refreshing the values)
<span style = "background-color:#dfd">	unsigned int endTime = time + job.getJobDuration();
	while (endIndex &lt; nodeCounts.size() &amp;&amp; nodeCounts[endIndex].getTime() &lt; endTime &amp;&amp; isSpaceAvailable(job, nodeCounts[endIndex]))</span>
	{
<span style = "background-color:#dfd">		isRefresh = true;
		nodeCounts[endIndex].refreshNodeCount(job);
		endIndex++;
	}</span>
	//creates Nodecounts
<span style = "background-color:#dfd">	if (indexNodeCount == 0)</span>
	{
<span style = "background-color:#dfd">		NodeCount* startNodeCount = new NodeCount(parameters, job, true, jobID);
		NodeCount* endNodeCount = new NodeCount(*startNodeCount, job, false, jobID);
		nodeCounts.push_back(*startNodeCount);
		nodeCounts.push_back(*endNodeCount);
	}
	else if (job.isHugeJob())</span>
	{
<span style = "background-color:#dfd">		NodeCount* startNodeCount = new NodeCount(nodeCounts[indexNodeCount - 1], job, true, jobID);
		NodeCount* endNodeCount = new NodeCount(*startNodeCount, job, false, jobID);
		nodeCounts.push_back(*startNodeCount);
		nodeCounts.push_back(*endNodeCount);
	}</span>
	else
	{
<span style = "background-color:#dfd">		NodeCount* startNodeCount = new NodeCount(nodeCounts[indexNodeCount - 1], job, true, jobID);
		if (!isRefresh)</span>
		{
<span style = "background-color:#dfd">			NodeCount* endNodeCount = new NodeCount(*startNodeCount, job, false, jobID);
			nodeCounts.push_back(*endNodeCount);
		}</span>
		else {
<span style = "background-color:#dfd">			NodeCount* endNodeCount = new NodeCount(nodeCounts[endIndex - 1], job, false, jobID);
			nodeCounts.push_back(*endNodeCount);</span>
		}
<span style = "background-color:#dfd">		nodeCounts.push_back(*startNodeCount);</span>
	}

<span style = "background-color:#dfd">	std::sort(nodeCounts.begin(), nodeCounts.end(), [](NodeCount nodeCount1, NodeCount nodeCount2) {return nodeCount1.getTime() &lt; nodeCount2.getTime(); });
}</span>

//Checks if there are enough ressources long enoug in the queue to compute this job
bool Simulation::enoughTime(unsigned int time, Job job, int&amp; indexNodeCount)
<span style = "background-color:#dfd">{
	int i = indexNodeCount;
	int j = i;
	bool enoughTime = false;
	unsigned int endTime = time + job.getJobDuration();
	while (i &lt; nodeCounts.size() &amp;&amp; nodeCounts[i].getTime() &lt;= endTime)</span>
	{
<span style = "background-color:#dfd">		if (isSpaceAvailable(job, nodeCounts[i]))</span>
		{
<span style = "background-color:#dfd">			j++;</span>
		}
<span style = "background-color:#dfd">		i++;
	}
	if (nodeCounts.size() == j || nodeCounts[j].getTime() &gt; job.getJobDuration() + time)</span>
	{
<span style = "background-color:#dfd">		enoughTime = true;
	}</span>
	else {
<span style = "background-color:#dfd">		indexNodeCount++;</span>
	}
<span style = "background-color:#dfd">	return enoughTime;
}</span>

//checks if there are enough nodes to run the given job
bool Simulation::isSpaceAvailable(Job job, NodeCount nodeCount)
<span style = "background-color:#dfd">{
	int availableNodes = 0;
	if (job.isGPUJob())</span>
	{
<span style = "background-color:#dfd">		availableNodes = nodeCount.getGPUNodesNum() - job.getNodesRequired();
	}
	else if (job.isLargeJob()) {
		availableNodes = nodeCount.getLargeNodesNum() - job.getNodesRequired();
	}
	else if (job.isMediumJob()) {
		availableNodes = nodeCount.getMediumNodesNum() - job.getNodesRequired();
	}
	else if (job.isShortJob()) {
		availableNodes = nodeCount.getShortNodesNum() - job.getNodesRequired();
	}
	else if (job.isHugeJob())</span>
	{
<span style = "background-color:#dfd">		availableNodes = nodeCount.getHugeNodesNum() - job.getNodesRequired();</span>
	}
<span style = "background-color:#dfd">	return availableNodes &gt;= 0;
}</span>

//Used to find the index of the next NodeCount in the vector (which is starting just after the given time)
int Simulation::findNext(unsigned int time, int j)
<span style = "background-color:#dfd">{
	while (j &lt; nodeCounts.size() &amp;&amp; nodeCounts[j].getTime() &lt;= time)</span>
	{
<span style = "background-color:#dfd">		j++;
	}
	return j;
}</span>

//Finds when there are enough available nodes to start the job
void Simulation::startJob(int&amp; indexNodeCount, Job job, unsigned int&amp; time)
<span style = "background-color:#dfd">{
	int j = indexNodeCount;
	while (j != 0 &amp;&amp; j - 1 &lt; nodeCounts.size() &amp;&amp; !isSpaceAvailable(job, nodeCounts[j - 1]))</span>
	{
<span style = "background-color:#dfd">		j++;
		time = nodeCounts[j - 1].getTime();
	}
	if (weekEnd(time + job.getJobDuration()))</span>
	{
<span style = "background-color:#dfd">		time = nextWeek(time);
		j = findNext(time, j);
		startJob(j, job, time);</span>
	}
<span style = "background-color:#dfd">	if (j != 0 &amp;&amp; j != nodeCounts.size())</span>
	{
<span style = "background-color:#dfd">		if (nodeCountExists(time))</span>
		{
<span style = "background-color:#dfd">			time++;
			j = findNext(time, j);
			startJob(j, job, time);</span>
		}
	}
<span style = "background-color:#dfd">	indexNodeCount = j;
}</span>

//Recursive method
void Simulation::startHugeJob(int&amp; indexNodeCount, Job job, unsigned int&amp; time)
<span style = "background-color:#dfd">{
	int j = indexNodeCount;
	time = nextWeekEnd(time);
	j = findNext(time, j);
	while (j != 0 &amp;&amp; j - 1 &lt; nodeCounts.size() &amp;&amp; !isSpaceAvailable(job, nodeCounts[j - 1]))</span>
	{
<span style = "background-color:#dfd">		j++;
		time = nodeCounts[j - 1].getTime();
	}
	if (!weekEnd(time + job.getJobDuration()))</span>
	{
<span style = "background-color:#dfd">		time = nextWeekEnd(time);
		j = findNext(time, j);
		startHugeJob(j, job, time);</span>
	}
<span style = "background-color:#dfd">	if (j != 0 &amp;&amp; j != nodeCounts.size())</span>
	{
<span style = "background-color:#dfd">		if (nodeCountExists(time))</span>
		{
<span style = "background-color:#dfd">			time++;
			j = findNext(time, j);
			startHugeJob(j, job, time);</span>
		}
	}
<span style = "background-color:#dfd">	indexNodeCount = j;
}</span>

bool Simulation::nodeCountExists(unsigned int&amp; time)
<span style = "background-color:#dfd">{
	bool nodeCountExists = false;</span>

<span style = "background-color:#dfd">	for (unsigned int i = 0; i &lt; nodeCounts.size(); ++i)</span>
	{
<span style = "background-color:#dfd">		if (nodeCounts[i].getTime() == time)</span>
		{
<span style = "background-color:#dfd">			nodeCountExists = true;</span>
		}
<span style = "background-color:#dfd">	}
	return nodeCountExists;
}</span>
//Takes the time and returns the time in seconds the next monday at 9 am
unsigned int Simulation::nextWeek(unsigned int time)
<span style = "background-color:#dfd">{
	if (time &lt; WEEK_START_IN_SEC)</span>
	{
<span style = "background-color:#dfd">		time = WEEK_START_IN_SEC;
	}</span>
	else
	{
<span style = "background-color:#dfd">		int quotient = time / WEEK_START_IN_SEC;
		time = (quotient + 1) * WEEK_START_IN_SEC;</span>
	}
<span style = "background-color:#dfd">	return time;
}</span>

//Checks if the given time is during the weekend
bool Simulation::weekEnd(unsigned int time)
<span style = "background-color:#dfd">{
	bool weekEnd = false;
	time = time % WEEK_START_IN_SEC;
	if (time &gt;= (unsigned int)WEEKEND_START_IN_SEC &amp;&amp; time &lt;= (unsigned int)WEEK_START_IN_SEC)</span>
	{
<span style = "background-color:#dfd">		weekEnd = true;</span>
	}
<span style = "background-color:#dfd">	return weekEnd;
}</span>

int Simulation::randomNumGenerator(int min, int max)
<span style = "background-color:#dfd">{
	int randomNumber = 0;
	std::random_device random; // It is used to obtain a seed to generate random numbers
	std::mt19937 generator(random());
	std::uniform_int_distribution&lt;&gt; distrib(min, max);
	randomNumber = distrib(generator);
	return randomNumber;
}</span>

double Simulation::exponentialDistribution(double lambda)
<span style = "background-color:#dfd">{
	std::random_device random; // It is used to obtain a seed to generate random numbers
	std::mt19937 generator(random());
	std::exponential_distribution&lt;double&gt; expDistribution(lambda);
	return expDistribution(generator);
}</span>

double Simulation::normalDistribution(double mean, double stdDeviation)
<span style = "background-color:#dfd">{
	double randomNumber = 0.0;
	std::random_device random; // It is used to obtain a seed to generate random numbers
	std::mt19937 generator(random());
	std::normal_distribution&lt;double&gt; distribution(mean, stdDeviation);
	return distribution(generator);
}</span>

std::vector&lt;Job*&gt; Simulation::getVecJobs()
<span style = "background-color:#dfd">{
	return this-&gt;jobs;
}</span>

std::vector&lt;User*&gt; Simulation::getVecUsers()
<span style = "background-color:#fdd">{
	return this-&gt;users;
}</span>

std::vector&lt;NodeCount&gt; Simulation::getVecNodeCounts()
<span style = "background-color:#dfd">{
	return this-&gt;nodeCounts;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>
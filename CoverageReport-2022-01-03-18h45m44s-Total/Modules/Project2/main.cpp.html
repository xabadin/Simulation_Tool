<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
	<head>
        <meta charset="utf-8"/>
	    <title>main.cpp</title>
	    <link href="../../third-party/google-code-prettify/prettify-CppCoverage.css" type="text/css" rel="stylesheet" />
	    <script type="text/javascript" src="../../third-party/google-code-prettify/prettify.js"></script>
	</head>
    <body onload="prettyPrint()">
        <h4></h4>
        <pre class="prettyprint lang-cpp linenums">
#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;fstream&gt;
#include &lt;cmath&gt;
#include "float.h"
#include "Simulation.h"
#include "Parameters.h"

std::vector&lt;double&gt; input();
double checkInput(double input, double min = 0.0, double max = DBL_MAX);
void clearInput();
void outputNodeCountsCsv(Simulation* simulation);
void outputJobsCsv(Simulation* simulation);
std::vector&lt;int&gt; computeNumberOfJobsInEachQueue(Simulation* simulation);
double computeNumberOfNodeHoursConsumed(Simulation* simulation);
double computeUtilizationRatio(Simulation* simulation);
double computeTotalPricePaidByUsers(Simulation* simulation);
std::vector&lt;long double&gt; computeAvgWaitTimeInEachQueue(Simulation* simulation);
double computeAvgTurnAroundTimeRatio(Simulation* simulation);
double computeEconomicBalanceOfCentre(Simulation* simulation);

/*
  Used to create the simulation for the IT staff
*/
<span style = "background-color:#dfd">int main() {</span>
	// Time is set to t = 0 because it is assumed that each simulation starts a monday at midnight. 
<span style = "background-color:#dfd">	unsigned int time = 0;</span>

	// ask user for his input
<span style = "background-color:#dfd">	std::vector&lt;double&gt; param = input();
	Parameters* parameters = new Parameters(param[0], param[1], param[2], param[3], param[4], param[5], param[6], param[7], param[8]);</span>
	// run the simulation
<span style = "background-color:#dfd">	Simulation* simulation = new Simulation(parameters);</span>

	// Create and fill csv files with the different allocation of ressources throughout the simulation
<span style = "background-color:#dfd">	outputNodeCountsCsv(simulation);</span>
	// Create and fill csv files with the different jobs created throughout the simulation
<span style = "background-color:#dfd">	outputJobsCsv(simulation);</span>

	// Creation of the file receiving the required outputs
<span style = "background-color:#dfd">	std::ofstream Outputs("../outputs/Outputs.csv");</span>

<span style = "background-color:#dfd">	Outputs &lt;&lt; "Queue;Short;Medium;Large;Huge;GPU" &lt;&lt; std::endl;</span>

	// Output of the number of jobs processed in each queue
	int numjobsShort, numjobsMedium, numjobsLarge, numjobsHuge, numjobsGPU;
<span style = "background-color:#dfd">	std::vector&lt;int&gt; numJobs = computeNumberOfJobsInEachQueue(simulation);
	Outputs &lt;&lt; "Number of jobs processed;" &lt;&lt; numJobs[0] &lt;&lt; ";" &lt;&lt; numJobs[1] &lt;&lt; ";" &lt;&lt; numJobs[2] &lt;&lt; ";" &lt;&lt; numJobs[3] &lt;&lt; ";" &lt;&lt; numJobs[4] &lt;&lt; std::endl;</span>

	// Output of the average wait time in each queue
	int avgShort, avgMedium, avgLarge, avgHuge, avgGPU;
<span style = "background-color:#dfd">	std::vector&lt;long double&gt; avgWaitTime = computeAvgWaitTimeInEachQueue(simulation);
	Outputs &lt;&lt; "Average wait time (s);" &lt;&lt; avgWaitTime[0] &lt;&lt; ";" &lt;&lt; avgWaitTime[1] &lt;&lt; ";" &lt;&lt; avgWaitTime[2] &lt;&lt; ";" &lt;&lt; avgWaitTime[3] &lt;&lt; ";" &lt;&lt; avgWaitTime[4] &lt;&lt; std::endl &lt;&lt; std::endl;
	Outputs &lt;&lt; "Number of node-hours consumed by user jobs;Utilization ratio;Resulting price paid by the users;Average turnaround time ratio;Economic balance of the centre" &lt;&lt; std::endl;</span>

	// Computing of the actual number of node-hours consumed by user jobs
<span style = "background-color:#dfd">	double totalNumberOfNodeHoursConsumed = computeNumberOfNodeHoursConsumed(simulation);</span>
	// Computing of the utilisation ratio
	// Not working
<span style = "background-color:#dfd">	double utilizationRatio = computeUtilizationRatio(simulation);</span>
	// Computing of the resulting price paid by the users
<span style = "background-color:#dfd">	double resultingPricePaidByUsers = computeTotalPricePaidByUsers(simulation);</span>
	// Computing of the average turnaround time ratio
	// Problem with result
<span style = "background-color:#dfd">	double avgTurnAroundTimeRatio = computeAvgTurnAroundTimeRatio(simulation);</span>
	// Computing of the economic balance of the centre
<span style = "background-color:#dfd">	double economicBalanceOfCentre = computeEconomicBalanceOfCentre(simulation);</span>

<span style = "background-color:#dfd">	Outputs &lt;&lt; totalNumberOfNodeHoursConsumed &lt;&lt; ";" &lt;&lt; utilizationRatio &lt;&lt; ";" &lt;&lt; resultingPricePaidByUsers &lt;&lt; " £;" &lt;&lt; avgTurnAroundTimeRatio &lt;&lt; ";" &lt;&lt; economicBalanceOfCentre &lt;&lt; " £";</span>

<span style = "background-color:#dfd">	std::cout &lt;&lt; "Simulation complete" &lt;&lt; std::endl;
	std::cout &lt;&lt; "You will find the outputs of the simulation in the Outputs directory" &lt;&lt; std::endl;</span>

<span style = "background-color:#dfd">	return 0;
}</span>

<span style = "background-color:#dfd">std::vector&lt;double&gt; input() {
	Data data;
	std::vector&lt;double&gt; inputs;
	double input = 0;</span>

<span style = "background-color:#dfd">	std::cout &lt;&lt; "Welcome to the supercomputer simulation software" &lt;&lt; std::endl;
	std::cout &lt;&lt; "Before running the simulation, you are able to set different parameters to fit your need" &lt;&lt; std::endl;
	std::cout &lt;&lt; "Be careful, if the values you enter are absurd, you will get absurd results" &lt;&lt; std::endl &lt;&lt; std::endl;</span>

	// Number of users
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The first parameter is the number of users that will be sending job requests to your supercomputer" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.NUMBER_OF_USERS &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the number of users you want: " &lt;&lt; std::endl;
	double numberofUsers = checkInput(input);
	inputs.push_back(numberofUsers);</span>

	// Number of jobs
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The second parameter is the total number of jobs that will be sent by users throughout the simulation" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.NUMBER_OF_JOBS &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the number of jobs you want: " &lt;&lt; std::endl;
	double numberOfJobs = checkInput(input);
	inputs.push_back(numberOfJobs);</span>

	// Number of nodes
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The third parameter is the total number of nodes that the supercomputer will be able to use to run the jobs" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The minimum being is " &lt;&lt; data.MIN_NUMBER_OF_NODES &lt;&lt; " and the maximum value " &lt;&lt; data.MAX_NUMBER_OF_NODES &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.MIN_NUMBER_OF_NODES &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the number of nodes you want: " &lt;&lt; std::endl;
	double numberOfNodes = checkInput(input, data.MIN_NUMBER_OF_NODES, data.MAX_NUMBER_OF_NODES);
	inputs.push_back(numberOfNodes);</span>

	// Traditional node cost
<span style = "background-color:#dfd">	std::cout &lt;&lt; "Knowing that the supercomputer uses traditional nodes and accelerated nodes, " &lt;&lt; std::endl;
	std::cout &lt;&lt; "The fourth parameter is the cost (per hour) of a traditional node" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.TRADITIONAL_NODE_COST * 3600 &lt;&lt; " pounds/h" &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the cost you want: " &lt;&lt; std::endl;
	double traditionalNodeCost = checkInput(input);
	inputs.push_back(traditionalNodeCost);</span>

	// Accelerated node cost
<span style = "background-color:#dfd">	std::cout &lt;&lt; "Now the fifth parameter is the cost (per hour) of an accelerated node" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.ACCELERATED_NODE_COST * 3600 &lt;&lt; " pounds/h" &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the cost you want: " &lt;&lt; std::endl;
	double acceleratedNodeCost = checkInput(input);
	inputs.push_back(acceleratedNodeCost);</span>

	// Student budget
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The sixth parameter is the budget allowed to students" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.STUDENT_BUDGET &lt;&lt; " pounds" &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the cost you want: " &lt;&lt; std::endl;
	double studentBudget = checkInput(input);
	inputs.push_back(studentBudget);</span>

	// Student max nodes
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The seventh parameter is the number maximum of nodes students are allowed to use a the same time" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.STUDENT_MAX_NODES &lt;&lt; " pounds" &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the cost you want: " &lt;&lt; std::endl;
	double studentMaxNodes = checkInput(input);
	inputs.push_back(studentMaxNodes);</span>

	// Reasearcher budget
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The eighth parameter is the budget allowed to reasearchers" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.RESEARCHER_BUDGET &lt;&lt; " pounds" &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the cost you want: " &lt;&lt; std::endl;
	double researcherBudget = checkInput(input);
	inputs.push_back(researcherBudget);</span>

	// Reasearcher max nodes
<span style = "background-color:#dfd">	std::cout &lt;&lt; "The last parameter is the number maximum of nodes reasearchers are allowed to use a the same time" &lt;&lt; std::endl;
	std::cout &lt;&lt; "The default value is " &lt;&lt; data.RESEARCHER_MAX_NODES &lt;&lt; " pounds" &lt;&lt; std::endl;
	std::cout &lt;&lt; "If you wish to keep this value, type 0, otherwise, enter the cost you want: " &lt;&lt; std::endl;
	double researcherMaxNodes = checkInput(input);
	inputs.push_back(researcherMaxNodes);</span>

<span style = "background-color:#dfd">	return inputs;</span>

<span style = "background-color:#dfd">}</span>

<span style = "background-color:#dfd">double checkInput(double input, double min, double max) {
	if (std::cin &gt;&gt; input) {
		if (input == 0) {
			std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
			return input;</span>
		}
<span style = "background-color:#fdd">		if (min != 0.0 || max != DBL_MAX) {
			if (input &gt;= min &amp;&amp; input &lt;= max) {
				std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
				return input;
			}</span>
			else {
<span style = "background-color:#fdd">				std::cout &lt;&lt; "Invalid Input! Please input a value that respects the min (" &lt;&lt; min &lt;&lt; ") and max (" &lt;&lt; max &lt;&lt; ") boundaries ." &lt;&lt; std::endl;
				clearInput();
				double newInput = 0;
				return checkInput(newInput, min, max);</span>
			}
<span style = "background-color:#fdd">		}</span>
		else {
<span style = "background-color:#fdd">			if (input &gt;= 0) {
				std::cout &lt;&lt; std::endl &lt;&lt; std::endl;
				return input;
			}</span>
			else {
<span style = "background-color:#fdd">				std::cout &lt;&lt; "Invalid Input! Please input a positive value." &lt;&lt; std::endl;
				clearInput();
				double newInput = 0;
				return checkInput(newInput);</span>
			}
		}
<span style = "background-color:#fdd">	}</span>
	else {

<span style = "background-color:#fdd">		std::cout &lt;&lt; "Invalid Input! Please input a numerical value." &lt;&lt; std::endl;
		clearInput();
		double newInput = 0;
		if (min != 0.0 || max != DBL_MAX) {
			return checkInput(newInput, min, max);
		}</span>
		else {
<span style = "background-color:#fdd">			return checkInput(newInput);</span>
		}
	}
<span style = "background-color:#dfd">}</span>

<span style = "background-color:#fdd">void clearInput() {
	std::cin.clear();
	while (std::cin.get() != '\n');
}</span>

<span style = "background-color:#dfd">void outputNodeCountsCsv(Simulation* simulation) {
	std::ofstream NodeCounts("../outputs/Nodecounts.csv");
	NodeCounts &lt;&lt; "Time;Huge;GPU;Large;Medium;Short;isStart;ID" &lt;&lt; std::endl;
	for (int i = 0; i &lt; simulation-&gt;getVecNodeCounts().size(); ++i)</span>
	{
<span style = "background-color:#dfd">		NodeCounts &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getTime() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getHugeNodesNum() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getGPUNodesNum() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getLargeNodesNum() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getMediumNodesNum() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getShortNodesNum() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getIsStart() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecNodeCounts()[i].getJobID() &lt;&lt; std::endl;
	}
}</span>

<span style = "background-color:#dfd">void outputJobsCsv(Simulation* simulation) {
	std::ofstream jobs("../outputs/Jobs.csv");
	jobs &lt;&lt; "ID;submissionTime;duration;startTime;endTime;nodesRequired" &lt;&lt; std::endl;
	for (int i = 0; i &lt; simulation-&gt;getVecJobs().size(); ++i)</span>
	{
<span style = "background-color:#dfd">		jobs &lt;&lt; i &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecJobs()[i]-&gt;getSubmissionTime() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecJobs()[i]-&gt;getJobDuration() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecJobs()[i]-&gt;getStartTime() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecJobs()[i]-&gt;getEndTime() &lt;&lt; ";" &lt;&lt; simulation-&gt;getVecJobs()[i]-&gt;getNodesRequired() &lt;&lt; std::endl;
	}
}</span>

<span style = "background-color:#dfd">std::vector&lt;int&gt; computeNumberOfJobsInEachQueue(Simulation* simulation) {</span>
	int numShort, numMedium, numLarge, numHuge, numGPU;
<span style = "background-color:#dfd">	numShort = numMedium = numLarge = numHuge = numGPU = 0;
	std::vector&lt;Job*&gt; jobVector = simulation-&gt;getVecJobs();
	for (int i = 0; i &lt; jobVector.size(); ++i)</span>
	{
<span style = "background-color:#dfd">		if (jobVector[i]-&gt;isShortJob()) {
			numShort++;
		}
		else if (jobVector[i]-&gt;isMediumJob()) {
			numMedium++;
		}
		else if (jobVector[i]-&gt;isLargeJob()) {
			numLarge++;
		}
		else if (jobVector[i]-&gt;isHugeJob()) {
			numHuge++;
		}
		else if (jobVector[i]-&gt;isGPUJob()) {
			numGPU++;</span>
		}
<span style = "background-color:#dfd">	}
	std::vector&lt;int&gt; res = { numShort, numMedium, numLarge, numHuge, numGPU };
	return res;
}</span>

<span style = "background-color:#dfd">double computeNumberOfNodeHoursConsumed(Simulation* simulation) {
	double totalNumberOfNodeHoursConsumed = 0.0;
	std::vector&lt;Job*&gt; jobVector = simulation-&gt;getVecJobs();
	for (int i = 0; i &lt; jobVector.size(); ++i) {
		double nodes = (double)jobVector[i]-&gt;getNodesRequired();
		double hours = (double)jobVector[i]-&gt;getJobDuration();
		totalNumberOfNodeHoursConsumed += nodes / hours;
	}
	return totalNumberOfNodeHoursConsumed;
}</span>

<span style = "background-color:#dfd">double computeUtilizationRatio(Simulation* simulation) {</span>
	/*Data data;
	std::vector&lt;NodeCount&gt; nodeCountVector = simulation-&gt;getVecNodeCounts();
	double nodeHoursConsumed = computeNumberOfNodeHoursConsumed(simulation);
	double nodeHoursAvailable = (nodeCountVector[nodeCountVector.size() - 1].getTime() / 3600) * data.MIN_NUMBER_OF_NODES;
	return nodeHoursConsumed / nodeHoursAvailable;*/

<span style = "background-color:#dfd">	return 0;
}</span>


<span style = "background-color:#dfd">double computeTotalPricePaidByUsers(Simulation* simulation) {
	int totalPrice = 0;
	std::vector&lt;Job*&gt; jobVector = simulation-&gt;getVecJobs();
	for (int i = 0; i &lt; jobVector.size(); ++i) {
		totalPrice += jobVector[i]-&gt;computePrice();
	}
	return totalPrice;
}</span>

<span style = "background-color:#dfd">std::vector&lt;long double&gt; computeAvgWaitTimeInEachQueue(Simulation* simulation) {</span>
	long double waitShort, waitMedium, waitLarge, waitHuge, waitGPU;
<span style = "background-color:#dfd">	waitShort = waitMedium = waitLarge = waitHuge = waitGPU = 0;</span>

	long int sizeShort, sizeMedium, sizeLarge, sizeHuge, sizeGPU;
<span style = "background-color:#dfd">	sizeShort = sizeMedium = sizeLarge = sizeHuge = sizeGPU = 0;</span>

<span style = "background-color:#dfd">	std::vector&lt;Job*&gt; jobVector = simulation-&gt;getVecJobs();
	for (int i = 0; i &lt; jobVector.size(); ++i)</span>
	{
<span style = "background-color:#dfd">		if (jobVector[i]-&gt;isShortJob()) {
			waitShort += jobVector[i]-&gt;getStartTime() - jobVector[i]-&gt;getSubmissionTime();
			sizeShort++;
		}
		else if (jobVector[i]-&gt;isMediumJob()) {
			waitMedium += jobVector[i]-&gt;getStartTime() - jobVector[i]-&gt;getSubmissionTime();
			sizeMedium++;
		}
		else if (jobVector[i]-&gt;isLargeJob()) {
			waitLarge += jobVector[i]-&gt;getStartTime() - jobVector[i]-&gt;getSubmissionTime();
			sizeLarge++;
		}
		else if (jobVector[i]-&gt;isHugeJob()) {
			waitHuge += jobVector[i]-&gt;getStartTime() - jobVector[i]-&gt;getSubmissionTime();
			sizeHuge++;
		}
		else if (jobVector[i]-&gt;isGPUJob()) {
			waitGPU += jobVector[i]-&gt;getStartTime() - jobVector[i]-&gt;getSubmissionTime();
			sizeGPU++;</span>
		}
<span style = "background-color:#dfd">	}
	long double avgShort = (long double)waitShort / (long double)sizeShort;
	long double avgMedium = (long double)waitMedium / (long double)sizeMedium;
	long double avgLarge = (long double)waitLarge / (long double)sizeLarge;
	long double avgHuge = (long double)waitHuge / (long double)sizeHuge;
	long double avgGPU = (long double)waitGPU / (long double)sizeGPU;</span>

<span style = "background-color:#dfd">	std::vector&lt;long double&gt; res = { avgShort, avgMedium, avgLarge, avgHuge, avgGPU };
	return res;
}
double computeAvgTurnAroundTimeRatio(Simulation* simulation) {</span>
	double total, count;
<span style = "background-color:#dfd">	total = count = 0.0;
	std::vector&lt;Job*&gt; jobVector = simulation-&gt;getVecJobs();
	for (int i = 0; i &lt; jobVector.size(); ++i) {
		double a = (double)jobVector[i]-&gt;getEndTime() - (double)jobVector[i]-&gt;getSubmissionTime();
		double b = (double)jobVector[i]-&gt;getEndTime() - (double)jobVector[i]-&gt;getStartTime();
		total += a - b;
		count++;
	}
	return total / count;
}</span>

<span style = "background-color:#dfd">double computeEconomicBalanceOfCentre(Simulation* simulation) {
	Data data;
	std::vector&lt;NodeCount&gt; nodeCountVector = simulation-&gt;getVecNodeCounts();
	double overallOperatingCost = (nodeCountVector[nodeCountVector.size() - 1].getTime() * data.OPERATING_COST);
	return computeTotalPricePaidByUsers(simulation) - overallOperatingCost;
}</span></pre>
        <hr />
        <table width="100%">
            <thead>
                <tr>
                    <th align="center">
                        <small>Generated by</small>
                        <a href="https://github.com/OpenCppCoverage/OpenCppCoverage/releases">
                            <strong>OpenCppCoverage (Version: 0.9.9.0)</strong>
                        </a>
                    </th>
                </tr>
            </thead>
        </table>
    </body>
</html>